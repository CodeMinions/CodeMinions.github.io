<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>初学者</title>
  
  
  <link href="http://codeminions.github.io/atom.xml" rel="self"/>
  
  <link href="http://codeminions.github.io/"/>
  <updated>2021-02-25T15:37:52.951Z</updated>
  <id>http://codeminions.github.io/</id>
  
  <author>
    <name>minions</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识MQTT</title>
    <link href="http://codeminions.github.io/2021/02/25/mqtt/"/>
    <id>http://codeminions.github.io/2021/02/25/mqtt/</id>
    <published>2021-02-25T09:53:32.000Z</published>
    <updated>2021-02-25T15:37:52.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近的小项目中需要使用mqtt作为服务端到硬件模块的传输协议，于是对MQTT进行了一些了解。<br>一开始总是云里雾里，通过知乎，论坛等平台文章进行了解后，记录下从我的角度第一次接触了解该协议需要了解理解的东西</p></blockquote><p><a href="https://www.emqx.cn/mqtt"><img src="/2021/02/25/mqtt/emqx-mqtt.png" alt="Emqx的MQTT介绍"></a><br><strong>MQTT协议是基于TCP建立的应用层协议，比TCP晚了25年。</strong>1999年IoT的概念刚被提出，Mqtt出现恰逢其时。</p><a id="more"></a><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031">Mqtt英文文档</a><br><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/">Mqtt中文文档</a></p><h1 id="TCP与MQTT的区别"><a href="#TCP与MQTT的区别" class="headerlink" title="TCP与MQTT的区别"></a>TCP与MQTT的区别</h1><h2 id="设计背景"><a href="#设计背景" class="headerlink" title="设计背景"></a>设计背景</h2><p>TCP最初被设计用于卫星基站间的通信，实现不同的短硬件之间可以互相通信。<br>Mqtt最初被设计用于石油管道的监控，将管道上的传感器信息传输到服务器上，实现石油管道的无人值守。需要实现：</p><ul><li>沿途鲜有网络设施，使用卫星通信更加经济，但需要注意流量的开销成本</li><li>管道线路长，传感器数量大，即客户端数量庞大，服务器要支持大量的客户端连接</li><li>通信频率低，且传输数据量较小</li><li>现场采集的网关数量大，cpu与存储资源有限。因此协议的客户端软件需要能在资源有限的单片机，RTU上运行</li><li>高轨卫星延迟高，低轨卫星覆盖面低，因此切换卫星时会出现网络中断。Server和Client需要具备保留消息收发状态的功能，保证恢复网络后的续传</li><li>需提供不同等级的消息服务质量，即优先级，且保证高优消息在恶劣网络环境中的可靠性</li></ul><blockquote><p>需要传输协议能够异步管理消息。在卫星通信中断时：MQTT网络中的服务器/代理可以保存和转发从客户端到客户端的消息，如果断开连接，它将能够在以后重新连接时获取消息。</p></blockquote><p><a href="https://www.zhihu.com/question/23373904/answer/636518156">参考文章</a></p><h2 id="协议定位"><a href="#协议定位" class="headerlink" title="协议定位"></a>协议定位</h2><p>TCP作为一种传输层的协议，以包package为传输单位。主要处理异构网络下的丢包，阻塞，乱序，重复问题<br>Mqtt作为一种应用层协议，以消息为单位。主要解决<strong>在低带宽延迟不可靠的资源有限的硬件环境下，进行相对可可靠的数据传输</strong>。<br>TCP通过ACK与重传机制，保证发送的数据可靠稳定收到；<strong>Mqtt提供三种可选的消息发布的Qos服务等级，Mqtt客户端和Mqtt代理服务器通过seeion机制保证消息的传输可靠性</strong>。</p><h1 id="消息服务等级"><a href="#消息服务等级" class="headerlink" title="消息服务等级"></a>消息服务等级</h1><p>由上所述，MQTT支持不同等级的消息服务。通过将消息等级分为qos0，qos1，qos2，简化消息发送不同等级质量的工作量。<br>Mqtt客户端和Broker端底层通过session保障不同的qos等级。</p><ul><li>根据<strong>topic</strong>划分消息业务，又灵活的topic订阅机制</li><li>异常情况下有LWT遗嘱机制，通知相应的topic订阅者客户端已离线</li><li>支持TLS，保证安全性</li></ul><p><a href="https://www.jianshu.com/p/6cf5a4c740f6">Qos机制讲解</a></p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>由于基于TCP实现，所以具有其拥有的缺点</p><ul><li>对网络环境要求较高</li><li>存在RST攻击，容易被运营商拦截</li><li>相对UDP消耗大，需要建立维护断开连接</li></ul><blockquote><p>MQTT就是观察者模式的网络放大版</p></blockquote><p><a href="https://www.runoob.com/w3cnote/mqtt-intro.html"><img src="/2021/02/25/mqtt/runoob-mqtt.png" alt="mqtt"></a><br>这是MQTT在实际应用中的<a href="https://zhuanlan.zhihu.com/p/110063556">一个例子</a>，可以从架构层面感受一下MQTT协议在实际应用中的位置。</p><h1 id="MQTT服务器"><a href="#MQTT服务器" class="headerlink" title="MQTT服务器"></a>MQTT服务器</h1><p>之后我打算通过实际的使用协议进行通信，实践中更好的体会一下。<br>Arduino社区有一位大佬写了<a href="https://www.arduino.cn/thread-82851-1-1.html">一篇帖子</a>，讲了一下从TCP到MQTT的连接以及关于Esp8266的编程。</p><h2 id="MQTT-nodejs实现broker"><a href="#MQTT-nodejs实现broker" class="headerlink" title="MQTT nodejs实现broker"></a>MQTT nodejs实现broker</h2><p>使用依赖：mosca mqtt<br>mosca相当于是nodejs下一个已实现的Mqtt Server实现。<a href="https://www.jianshu.com/p/8315acec4e6b">介绍</a></p><blockquote><p><a href="https://link.jianshu.com?t=https://github.com/mcollina/mosca">Mosca</a>是MQTT在Node.js中的一个Broker的开源实现，通俗讲也就是MQTT中的Server实现。<br> 同时作者也维护着<a href="https://link.jianshu.com?t=https://github.com/mqttjs/MQTT.js">MQTT.js</a>这一模块，这一模块大家可理解为MQTT的Client实现。而纵观整个Node.js的module中比较有分量的也就以上两个module.</p></blockquote><p>首先通过<code>new mosca.Server(&#123;port: xx&#125;)</code>的方式创建一个MqttServer实例，其中以json的格式配置port信息。然后一个mqtt服务器算是建立起来了</p><p>然后可以进行事件监听。目前知道几个事件tag</p><ul><li>clientConnected    有客户端连接时回调，回调参数是client，大概是客户端的实例，可以通过<code>client.id</code>获取客户端id</li><li>published        有消息推送到服务器时回调，参数是packet和client，大概是消息和客户端的实例。可以通过<code>packet.topic</code>获取时事件的主题</li><li>ready        server运行时回调</li></ul><p>订阅和发送MQTT消息时，甚至更加容易。<br>首先<code>mqtt.connect(&quot;mqtt://127.0.0.1:port&quot;)</code>连接到创建的服务器，得到一个client实例，然后可以通过该实例进行消息订阅和推送。<br>同样可以进行事件监听</p><ul><li>connect        服务器连接成功时的回调</li><li>message        收到消息时回调，当然，只会收到订阅过的消息<br><a href="https://blog.csdn.net/unforgettable2010/article/details/103918143">更多使用</a></li></ul><p>代码示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----创建MQTT服务器-----</span></span><br><span class="line"><span class="keyword">const</span> mosca = <span class="built_in">require</span>(<span class="string">&quot;mosca&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> mosca.Server(&#123;</span><br><span class="line">  port: <span class="number">1883</span></span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">&quot;clientConnected&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 客户端连接回调</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;A client connected..&quot;</span>, client.id);</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">&quot;published&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">packet, client</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> topic = packet.topic;</span><br><span class="line">  <span class="keyword">switch</span>(topic) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;MyTopic&quot;</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----连接MQTT服务器并订阅/推送消息-----</span></span><br><span class="line"><span class="keyword">const</span> mqtt = <span class="built_in">require</span>(<span class="string">&quot;mqtt&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> client = mqtt.connect(<span class="string">&quot;mqtt://127.0.0.1:1883&quot;</span>);</span><br><span class="line">client.on(<span class="string">&quot;connect&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 服务器连接成功回调</span></span><br><span class="line">  <span class="comment">// 订阅主题为MyTopic的消息</span></span><br><span class="line">  client.subscribe(<span class="string">&quot;MyTopic&quot;</span>, &#123;<span class="attr">qos</span>: <span class="number">1</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">client.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">top, message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;主题：&quot;</span> + top);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;内容：&quot;</span> + message.toString());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 推送主题为MyTopic的消息</span></span><br><span class="line">client.publish(<span class="string">&quot;MyTopic&quot;</span>, <span class="string">&quot;Hello World&quot;</span>, &#123;<span class="attr">qos</span>: <span class="number">0</span>, <span class="attr">retain</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="EMQX在线mqtt平台"><a href="#EMQX在线mqtt平台" class="headerlink" title="EMQX在线mqtt平台"></a>EMQX在线mqtt平台</h2><p>有很多提供Mqtt服务器的平台，例如这个<a href="https://www.emqx.cn/mqtt/public-mqtt5-broker">EMQX</a>（附<a href="https://blog.csdn.net/qq_46042542/article/details/107564395">使用介绍</a>）。实际上他也有客户端版本，可以支持在本地创建服务器，但是我没有下。<a href="http://tools.emqx.io/">tools.emqx.io</a>这个是该平台基于WebSocket实现的版本，一个免费的公共服务器，使用的远程第三方服务器。</p><p>相当于远程创建一个Mqtt服务器后，网页上以其中一个连接到该服务器的客户端呈现，可以发送自定义主题的消息，也可以创建subscriber，以对话的形式显示订阅消息的显示。</p><p>实际上创建这么一个服务器以后，理论上也是可以通过nodejs在本地订阅和发布的。但是我尝试了几种URI却没能连上服务器（也是在这里才知道这里用的是远程服务器）</p><p>后来通过<a href="https://zhuanlan.zhihu.com/p/259186061">这篇文章</a>了解到，协议应该是<strong><code>ws</code></strong>（WebSocket）而不是mqtt。因此使用以下方式可以连接到该公共服务器（<code>/mqtt</code>是网页配置的路径，其上可以看到）。<br>（可是多了一个子路径之后，有些库api要求只有ip和端口，应该怎么调用呢？？）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> client = mqtt.connect(<span class="string">&quot;ws://broker.emqx.io:8083/mqtt&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上几个比较重要的信息</p><ul><li>MQTT是基于TCP的应用层协议</li><li>MQTT由于报文紧凑等原因可以在低带宽高延迟的网络环境进行稳定传输，适用于大多数物联网开发数据传输</li><li>主要的通信模式是：存在一个MQTT服务器，连接到该服务端的终端通过消息订阅与推送机制收发消息</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近的小项目中需要使用mqtt作为服务端到硬件模块的传输协议，于是对MQTT进行了一些了解。&lt;br&gt;一开始总是云里雾里，通过知乎，论坛等平台文章进行了解后，记录下从我的角度第一次接触了解该协议需要了解理解的东西&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.emqx.cn/mqtt&quot;&gt;&lt;img src=&quot;/2021/02/25/mqtt/emqx-mqtt.png&quot; alt=&quot;Emqx的MQTT介绍&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;strong&gt;MQTT协议是基于TCP建立的应用层协议，比TCP晚了25年。&lt;/strong&gt;1999年IoT的概念刚被提出，Mqtt出现恰逢其时。&lt;/p&gt;</summary>
    
    
    
    <category term="Code" scheme="http://codeminions.github.io/categories/Code/"/>
    
    
    <category term="Network" scheme="http://codeminions.github.io/tags/Network/"/>
    
    <category term="秘籍帖" scheme="http://codeminions.github.io/tags/%E7%A7%98%E7%B1%8D%E5%B8%96/"/>
    
    <category term="MQTT" scheme="http://codeminions.github.io/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>Arduino+Esp8266实现远程的模块控制</title>
    <link href="http://codeminions.github.io/2021/02/14/Arduino/"/>
    <id>http://codeminions.github.io/2021/02/14/Arduino/</id>
    <published>2021-02-13T16:00:00.000Z</published>
    <updated>2021-02-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近尝试使用Arduino配合esp8266实现远程控制Arduino上外接的某些模块，于是开始一边摸索一遍折腾开始了一周的尝试，期间得到很一些对自己很有用的经验，遂记录。<br>本次使用的策略是Arduino通过串口与esp8266通信，esp8266通过wifi连接到网络，然后通过mqtt协议订阅模块的操作信息，客户端就可以通过远程向mqtt发送相关主题的操作信息从而控制Arduino做出相应的约定动作。</p></blockquote><a id="more"></a><h1 id="使用硬件信息"><a href="#使用硬件信息" class="headerlink" title="使用硬件信息"></a>使用硬件信息</h1><ul><li>国版Ardunio Uno Rev3【<a href="https://www.arduino.cc/en/guide/MacOSX?setlang=cn">MacOS搭建ardunio环境</a>】</li><li>Esp8266-01s</li><li>动作模块使用舵机（或者灯泡等）</li></ul><h2 id="关于ESP8266"><a href="#关于ESP8266" class="headerlink" title="关于ESP8266"></a>关于ESP8266</h2><p>ESP8266存在3中工作模式：STA，AP，STA+AP<br>Sta模式: Station，类似于无线终端，本身不接受无线接入，可连接到AP，也就是可以连接wifi。一般无线网卡即工作在该模式<br>AP模式：相当于路由器，自己发射WiFi，终端可以连接上它，但是无法像sta模式那样连接其他WiFi。<br>STA+AP模式：既可以自己发射WiFi供其他终端连接，又可以做终端连接其他WiFi。这也是默认的出厂模式。 </p><p>ESP8266默认携带AT固件，支持AT指令，通过AT指令可以实现模式切换，修改波特率，Wifi连接，TCP连接等功能。<br>当然，使用不同的固件实现的功能也将不同。例如这里的<a href="http://www.piaoyi.org/iot/ESP8266-MQTT-AT-lewei50.html">支持mqtt的AT固件</a></p><h1 id="Arduino与8266的串口通信"><a href="#Arduino与8266的串口通信" class="headerlink" title="Arduino与8266的串口通信"></a>Arduino与8266的串口通信</h1><p>ESP8266与Arduino的接线，软硬串口的通信可以参见<a href="https://www.jianshu.com/p/cde9f7072eab">这篇文章</a>。</p><h2 id="ESP8266AT指令不可用"><a href="#ESP8266AT指令不可用" class="headerlink" title="ESP8266AT指令不可用"></a>ESP8266AT指令不可用</h2><p>Arduino接上8266之后，通过串口发送AT指令没有响应。于是尝试重刷esp8266的支持AT指令固件</p><div class="note info">            <p><strong>ESP8266重刷固件</strong></p><ul><li>在乐鑫官网获取<a href="https://www.espressif.com/zh-hans/support/download/other-tools?keys=flash+&amp;field_type_tid%5B%5D=14">下载工具</a>【需要在windows下使用】</li><li>同样在乐鑫官网获取所需的<a href="https://www.espressif.com/zh-hans/support/download/at">AT固件</a></li><li>下载工具和固件使用方式可以参考<a href="http://www.piaoyi.org/iot/espressif-ESP8266-MQTT-AT.html">这篇文章</a>。烧录使用的连接模块，我使用的是学弟借的ESP专用的U转串模块，插上即用（下图）。也有人使用pl2303。<br><img src="/2021/02/14/Arduino/IOT MCU.png" alt="IOTMCU CH340C ESP8266 ESP-01 Prog WIFI下载器"></li></ul>          </div><div class="note warning">            <p>重刷了固件之后AT指令还是没有生效。排除了接线问题，看到<a href="https://blog.csdn.net/Sandman06/article/details/112132550">这篇文章</a>提示，有可能是<strong>供电不足的原因</strong>。<br>重新紧了一下线，重插电源线（3.3V），8266的蓝灯一闪，然后微弱发光，这时候AT指令就生效了。（我使用的是MBP笔记本雷电口+usb转接器）<br><a href="https://www.bilibili.com/video/av50778938/">b站有个大佬</a>提供了一个使用外部电源输入的实现方式。<br><strong>所以AT指令不生效的情况，可以考虑一下供电的问题</strong></p>          </div><h1 id="ESP8266连接wifi与MQTT服务器"><a href="#ESP8266连接wifi与MQTT服务器" class="headerlink" title="ESP8266连接wifi与MQTT服务器"></a>ESP8266连接wifi与MQTT服务器</h1><p>紧接着是8266上的代码编写，需要实现</p><ul><li>Wifi连接</li><li>MQTT服务通信</li><li>通过串口发送消息到Arduino</li></ul><h2 id="ESP8266代码烧录"><a href="#ESP8266代码烧录" class="headerlink" title="ESP8266代码烧录"></a>ESP8266代码烧录</h2><h3 id="ESP8266代码编写"><a href="#ESP8266代码编写" class="headerlink" title="ESP8266代码编写"></a>ESP8266代码编写</h3><p>ESP8266的代码可以使用ArduinoIDE编写，同时支持8266板的库函数管理相关。也可以使用VSCode安装PlatformIO扩展，然后在PlatformIO里安装相关应用库。<br>使用ArduinoIDE，需要先安装esp8266的开发板支持。否则使用如<code>ESP8266WiFi.h</code>这样的库函数会报错<code>sketch_apr17a:15:10: error: ESP8266WiFi.h: No such file or directory</code></p><ul><li>打开Arduino的设置页，在<code>附加开发版管理网址</code>中填入<code>http://arduino.esp8266.com/stable/package_esp8266com_index.json</code></li><li>打开<code>工具&gt;开发板&gt;开发板管理器</code>搜索esp8266，点击安装</li><li>安装成功以后即可在开发板选项中看到<code>ESP8266 Board</code>，选择<code>ESP8266 Module</code>，就可以使用8266的库函数进行开发。注意esp8266代码编译和上传（烧录）时，需要确认开发板和端口的选择，否则可能会失败</li></ul><div class="note warning">            <p><strong>8266开发板支持包下载失败</strong><br>曾经在学校安装支持包速度蹭蹭，在家却是龟速+反复失败。于是想到了<a href="http://www.gaohaiyan.com/2573.html">手动下载安装</a>：</p><ul><li>浏览器打开<code>http://arduino.esp8266.com/stable/package_esp8266com_index.json</code>，可以看到其实是一大段记录支持包所需要的依赖包的地址（有点类似npm的package.json）</li><li>最主要的<code>esp8266-2.7.4.zip</code>，通过github下载其实速度还是感人。后来使用迅雷，10秒结束战斗！！真是个防止浪费生命的神器。</li><li>需要放到<code>/Library/Arduino15/staging/packages</code>目录下，再点击安装，就会跳过这个包了</li><li>还有一些零碎的依赖，看起来主要是根据不同的编译环境的一些不同包，上边的博客中提到可以把所有带osx，apple的都下下来。经过实际测试，应该不需要，主要是以下几个包。（测试使用笨方法，即点击安装，下载过程会在上述文件中生成文件，然后经过文件名到上边依赖包目录找到对应文件及地址进行下载，所以可能有一些比较小下载极快的这里就不列出来）<ul><li>x86_64-apple-darwin14.xtensa-lx106-elf-b40a506.1563313032.tar.gz</li><li>x86_64-apple-darwin14.mkspiffs-7fefeac.1563313032.tar.gz</li><li>x86_64-apple-darwin14.mklittlefs-fe5bb56.1578453304.tar.gz</li><li>python3-macosx-portable.tar.gz</li></ul></li></ul>          </div><div class="note warning">            <p><strong>pyserial or esptool directories not found next to this upload.py tool</strong><br>编译代码时出现以上报错。翻阅一堆博客论坛，找到了解决方法，并且有可能是MacOSBigSur的问题。</p><ol><li>下载 <a href="https://github.com/espressif/esptool/archive/v3.0.zip">https://github.com/espressif/esptool/archive/v3.0.zip</a></li><li>下载 <a href="https://github.com/pyserial/pyserial/archive/v3.4.zip">https://github.com/pyserial/pyserial/archive/v3.4.zip</a></li><li>下载解压出文件夹<code>esptool/</code>和<code>pyserial/</code>放到<code>~/Library/Arduino15/packages/esp8266/hardware/esp8266/2.7.4/tools/</code>文件夹下，替换原有的文件，具体点进目录中，根据文件名应该就明白了<br><strong><a href="https://www.esp8266.com/viewtopic.php?p=89446">参考链接</a></strong></li></ol>          </div><h3 id="Esp8266代码烧录"><a href="#Esp8266代码烧录" class="headerlink" title="Esp8266代码烧录"></a>Esp8266代码烧录</h3><p>esp8266通过Arduino板子连接PC进行代码烧录，始终出现问题。说始终是因为前几个月就因为这个问题导致有个小项目搁置，所以出现这个问题也算是意料之中吧。<br>主要现象是代码编译通过以后点击上传，始终出现<code>Connecting...</code>打点，过会就出现<strong><code>Failed to connect to ESP32: Timed out waiting for packet header</code></strong>的报错，上传失败。使用的接线是</p><blockquote><p>将UTXD接到串口模块的TX上，CH_PD和VCC接3.3V，GND和GPIO0接GND<br>这是烧录模式，如果要工作的话请将GPIO0脚悬空，即断开，否则设备不会正常工作！</p></blockquote><p>找到<a href="https://randomnerdtutorials.com/solved-failed-to-connect-to-esp32-timed-out-waiting-for-packet-header/">一篇帖子</a>，其中说解决方式是在8266<code>EN</code>和<code>GND</code>之间外接一个10uF的电容。感觉…不太实际，没有尝试。</p><p>后来看<a href="http://www.gaohaiyan.com/2573.html">这篇博客</a>时，发现它实际上也有说到这个问题。提到需要先断开8266的<code>EN</code>和<code>IO0</code>，然后在<code>Connecting..</code>打点时，<code>IO0</code>接地，<code>EN</code>接3.3V，程序可以继续烧录，否则会出现以上报错。帖子中提到该方式的成功率不高，确实我一直没有成功，它说还是使用U转串（下载器）进行烧录比较好。（我…怎么没有想到）</p><p>帖子中提到的，需要安装驱动，但是我没有，直接插上，点击上传就烧录了==，很成功，就像重刷固件一样，connecting之后log会显示烧写的地址位。同样，需要注意切换端口。</p><p><strong>实际上我看了<a href="https://blog.csdn.net/weixin_39098367/article/details/87521226">这篇博客</a>才意识到了（是的 才），实际上烧录程序和输入固件是一样的，固件实际上也是包装好的程序，比如AT固件实际上只是就只通过接受串口的固定格式的数据（AT指令），然后操作并返回结果信息的程序罢了，而所谓的需要注意默认的波特率，是因为程序中<code>Serial.begin</code>同样的使用了该波特率罢了。</strong></p><p>走通了代码的编写和烧录流程，接下来终于可以愉快的写代码了。</p><h2 id="ESP8266代码编写-1"><a href="#ESP8266代码编写-1" class="headerlink" title="ESP8266代码编写"></a>ESP8266代码编写</h2><h3 id="ESP8266串口通信"><a href="#ESP8266串口通信" class="headerlink" title="ESP8266串口通信"></a>ESP8266串口通信</h3><p>在8266上发送串口数据和Arduino其实一样<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Serial.begin();<span class="comment">// 指定串口波特率，注意通信的另一端（Arduino）需要统一波特率</span></span><br><span class="line">Serial.println();<span class="comment">// 输出数据。此外8266上的Serial对象还支持printf格式化输出方式</span></span><br></pre></td></tr></table></figure></p><h3 id="ESP8266连接Wifi"><a href="#ESP8266连接Wifi" class="headerlink" title="ESP8266连接Wifi"></a>ESP8266连接Wifi</h3><p>使用8266开发板自带库函数头文件<code>ESP8266Wifi.h</code>，很方便实现Wifi连接。基本代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WiFi.begin(<span class="keyword">char</span>* ssid, <span class="keyword">char</span>* password);<span class="comment">// 传入Wifi名和密码，开始连接</span></span><br><span class="line"><span class="keyword">if</span> (Wifi.status() != WL_CONNECTED)<span class="comment">// 确认连接状态</span></span><br></pre></td></tr></table></figure><br>具体代码示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ssid     = <span class="string">&quot;ESP8266 需要连接的WIFI的SSID&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* password = <span class="string">&quot;Wifi密码&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  delay(<span class="number">10</span>);</span><br><span class="line">  Serial.print(<span class="string">&quot;Connecting to &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 明确将ESP8266设置为WiFi客户端，否则默认情况下，它将尝试同时充当客户端和接入点，并可能导致WiFi网络上的其他WiFi设备出现网络问题 */</span></span><br><span class="line">  WiFi.mode(WIFI_STA);</span><br><span class="line">  <span class="comment">// 开始连接</span></span><br><span class="line">  WiFi.begin(ssid, password);</span><br><span class="line">  <span class="comment">// 状态确认</span></span><br><span class="line">  <span class="keyword">while</span> (WiFi.status() != WL_CONNECTED) &#123;</span><br><span class="line">    delay(<span class="number">500</span>);</span><br><span class="line">    Serial.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 连接成功</span></span><br><span class="line">  Serial.println(<span class="string">&quot;WiFi connected&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;IP address: &quot;</span>);</span><br><span class="line">  Serial.println(WiFi.localIP());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> whetherConnect = <span class="number">0</span>;</span><br><span class="line">WiFiClient client;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint16_t</span> port = <span class="number">8082</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * host = <span class="string">&quot;你的IP&quot;</span>; <span class="comment">// ip or dns</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 确认socket连接状态</span></span><br><span class="line">  <span class="keyword">if</span> (client.connected() == <span class="literal">true</span>)</span><br><span class="line">    whetherConnect = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    whetherConnect = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (whetherConnect == <span class="number">0</span>) &#123;</span><br><span class="line">    Serial.print(<span class="string">&quot;connecting to &quot;</span> + host);</span><br><span class="line">    <span class="keyword">if</span> (!client.connect(host, port)) &#123;</span><br><span class="line">      Serial.println(<span class="string">&quot;connection failed \n wait 5 sec...&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      whetherConnect = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Serial.available()) &#123;</span><br><span class="line">    <span class="comment">// 读取硬串口</span></span><br><span class="line">    <span class="keyword">if</span> (Serial.read() == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取ssid列表</span></span><br><span class="line">      <span class="keyword">int</span> n = WiFi.scanNetworks();</span><br><span class="line">      Serial.println(<span class="string">&quot;scan done&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        client.println(<span class="string">&quot;no networks found&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        client.println(n + <span class="string">&quot; networks found&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">          <span class="comment">// Print SSID and RSSI for each network found</span></span><br><span class="line">          client.print(WiFi.SSID(i));</span><br><span class="line">          client.println(WiFi.RSSI(i));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// This will send the request to the server</span></span><br><span class="line">      client.println(<span class="string">&quot;------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//read back one line from server</span></span><br><span class="line">      Serial.println(client.readStringUntil(<span class="string">&#x27;\r&#x27;</span>));</span><br><span class="line">      Serial.println(<span class="string">&quot;closing connection&quot;</span>);</span><br><span class="line">      client.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ESP8266与MQTT协议"><a href="#ESP8266与MQTT协议" class="headerlink" title="ESP8266与MQTT协议"></a>ESP8266与MQTT协议</h3><p>库管理中导入<code>PubSubClient.h</code>头文件，实现MQTT服务端的连接以及消息的订阅和发布。代码也不复杂<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WiFiClient espClient;</span><br><span class="line"><span class="function">PubSubClient <span class="title">client</span><span class="params">(espClient)</span></span>;</span><br><span class="line"></span><br><span class="line">client.setServer(<span class="keyword">char</span>* server_ip, <span class="keyword">int</span> port);<span class="comment">// 设置服务器IP和端口（思考，如果IP下还带有子目录该如何实现？）</span></span><br><span class="line">client.setCallback(callback);<span class="comment">// 设置回调，当有消息传入时会执行该回调</span></span><br><span class="line">client.connected();<span class="comment">// 判断连接状态</span></span><br><span class="line">client.connect(String clientId);<span class="comment">// 开始连接，传入客户端ID</span></span><br><span class="line">client.publish(<span class="keyword">char</span>* topic, <span class="keyword">char</span>* msg);<span class="comment">// 消息发布</span></span><br><span class="line">client.subscribe(<span class="keyword">char</span>* topic);<span class="comment">// 消息订阅</span></span><br><span class="line">client.loop();<span class="comment">// 处理保持活动信号，以及处理传入消息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">char</span> *topic, byte * payload, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span> </span>&#123;&#125;<span class="comment">// 主题，消息，消息长度</span></span><br></pre></td></tr></table></figure><br>具体代码示例：<a href="https://www.emqx.cn/blog/esp8266-connects-to-the-public-mqtt-broker">参考</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;PubSubClient.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ssid     = <span class="string">&quot;ESP8266 需要连接的WIFI的SSID&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* password = <span class="string">&quot;Wifi密码&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* mqtt_server = <span class="string">&quot;MQTT服务器IP&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mqtt_port     = MQTT服务端口;</span><br><span class="line"></span><br><span class="line">WiFiClient espClient;</span><br><span class="line"><span class="function">PubSubClient <span class="title">client</span><span class="params">(espClient)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting to &quot;</span>);</span><br><span class="line">  </span><br><span class="line">  connectWiFi();<span class="comment">// wifi连接如上文</span></span><br><span class="line"></span><br><span class="line">  client.setServer(mqtt_server, mqtt_port);</span><br><span class="line">  client.setCallback(callback);</span><br><span class="line">  <span class="keyword">while</span> (!client.connected()) &#123;</span><br><span class="line">    String client_id = String(WiFi.macAddress());</span><br><span class="line">    Serial.println(<span class="string">&quot;Connecting to public emqx mqtt broker.....&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (client.connect(client_id.c_str())) &#123;</span><br><span class="line">      Serial.println(<span class="string">&quot;Public emqx mqtt broker connected&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.print(<span class="string">&quot;failed with state &quot;</span>);</span><br><span class="line">      Serial.print(client.state());</span><br><span class="line">      delay(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;start to subsc&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span>* topic = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  client.publish(topic, <span class="string">&quot;hello emqx&quot;</span>);</span><br><span class="line">  client.subscribe(topic);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">char</span> *topic, byte * payload, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  Serial.print(<span class="string">&quot;Message arrived in topic: &quot;</span>);</span><br><span class="line">  Serial.println(topic);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;Message:(%d)  &quot;</span>, length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    Serial.print((<span class="keyword">char</span>) payload[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println();</span><br><span class="line">  Serial.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  client.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>还有大佬对PubSubClient库进行进一步封装实现了一个库。<a href="https://www.arduino.cn/thread-85101-1-2.html">可以看看这个</a><br>以及大佬编写的，关于客户端状态返回码的注释。如果连接MQTT服务器失败返回了状态码可以参考一下</p><blockquote><p>int - 客户端状态，可以采用以下值 (常量定义在 PubSubClient.h):<br>-4 : MQTT_ CONNECTION_ TIMEOUT - 服务器在保持活动时间内没有响应。<br>-3 : MQTT_ CONNECTION_ LOST - 网络连接中断。<br>-2 : MQTT_ CONNECT_ FAILED - 网络连接失败。<br>-1 : MQTT_ DISCONNECTED - 客户端干净地断开连接。<br>0 : MQTT_ CONNECTED - 客户端已连接。<br>1 : MQTT_ CONNECT_ BAD_ PROTOCOL - 服务器不支持请求的MQTT版本。<br>2 : MQTT_ CONNECT_ BAD_ CLIENT_ ID - 服务器拒绝了客户端标识符。<br>3 : MQTT_ CONNECT_ UNAVAILABLE - 服务器无法接受连接。<br>4 : MQTT_ CONNECT_ BAD_ CREDENTIALS - 用户名/密码被拒绝。<br>5 : MQTT_ CONNECT_ UNAUTHORIZED - 客户端无权连接。</p></blockquote><h2 id="关于MQTT"><a href="#关于MQTT" class="headerlink" title="关于MQTT"></a>关于MQTT</h2><p>对于MQTT，此前一直不了解，这几天查了些资料，根据自己的理解对MQTT进行了简单的介绍，大概是对TCP协议进一步封装的一个应用层协议，主要是消息订阅与发布广播的机制。可以看看<a href="../../../../2021/02/25/mqtt/">我对于MQTT的认识</a></p><p>查阅过程中，看到Arduino社区一位大佬写下的<a href="https://www.arduino.cn/thread-82851-1-1.html">科普贴</a>，觉得对理解MQTT还是很有帮助。<br>以及如果有node.js的环境，也可以使用node.js搭建MQTT服务器和客户端，实现消息的发送订阅。使用<code>mosca</code>库3 5行就可以实现。</p><h1 id="Arduino接收信息并输出"><a href="#Arduino接收信息并输出" class="headerlink" title="Arduino接收信息并输出"></a>Arduino接收信息并输出</h1><h2 id="Arduino接收串口信息"><a href="#Arduino接收串口信息" class="headerlink" title="Arduino接收串口信息"></a>Arduino接收串口信息</h2><p>实际上Arduino通过软串口连接8266的示例在<a href="#Arduino与8266的串口通信">上边</a>以及提供了，但我还是提供一下<a href="#代码示例">我的实现方式</a>。</p><h2 id="Arduino处理数据并控制动作模块"><a href="#Arduino处理数据并控制动作模块" class="headerlink" title="Arduino处理数据并控制动作模块"></a>Arduino处理数据并控制动作模块</h2><h4 id="Arduino-舵机"><a href="#Arduino-舵机" class="headerlink" title="Arduino+舵机"></a>Arduino+舵机</h4><p>舵机图如下，能通过pin口接收一个角度值然后将旋桨旋转到该角度。<a href="https://arduino.nxez.com/2016/12/20/use-arduino-to-control-the-steering-gear.html">舵机细节讲解</a><br><img src="/2021/02/14/Arduino/Servo.png" alt="舵机"><br>控制代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Servo.h&gt;// 头文件</span></span></span><br><span class="line">Servo myServo;</span><br><span class="line">pinMode(<span class="keyword">int</span> pin, myServo);<span class="comment">// 和控制led灯类似，需传入对应的pin口号</span></span><br><span class="line">myServo.write(<span class="keyword">int</span> angle);<span class="comment">// 写入角度值，进行旋转</span></span><br></pre></td></tr></table></figure></p><h4 id="Arduino处理串口数据"><a href="#Arduino处理串口数据" class="headerlink" title="Arduino处理串口数据"></a>Arduino处理串口数据</h4><p>说实话通过串口接受的数据处理也是废了不少脑筋。<br>经过测试，通过SoftwareSerial.read()读取的数据实际上是byte的字节流，需要强转为char类型，组装为原文字符串；而Serial.print()方法打印的数据，稍有不慎会出现乱序和重复的问题。然而这些问题都还没有结论，我也暂时没有深究。</p><p>由于在8266中输出的字符串文本接受时都是零散的字符，因此我输出文本时，将每一段文本都加上<code>#</code>开头，在Arduino接收时以一个<code>#</code>以及一个结尾的<code>\n</code>作为一句文本的标志，以此获得完整的字符串。<br>然而如果是要接受一段mqtt协议相关的消息，那么一段消息我需要得到的最主要信息就是<code>topic</code>和<code>message</code>至少两个部分。因此我决定让8266输出的信息拼装为一个json串，然后Arduino上以json的方式取用数据。</p><p><a href="#舵机">最后实现代码</a></p><div class="note primary">            <p>实际上这个地方大可不必如此麻烦，直接让8266发送角度值，Arduino接受后送给舵机发动就好了，没必要整花里胡哨的。但我是考虑了如果Arduino上如果连接了多个外设，那就需要区分topic和消息内容了，索性折腾了一下</p>          </div><div class="note info">            <p><strong>Arduino上的Json库：ArduinoJson</strong><br>同样的库管理中下载该库。由于网上大部分都是v5版本，为此还在其官网徜徉了一番，找到<a href="https://arduinojson.org/v6/doc/upgrade/">版本变更点</a>，以及<a href="https://arduinojson.org/v6/example/parser/">v6正确打开方式</a>。<br>十分详尽，此处不过多介绍使用了</p>          </div><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><h2 id="实现esp8266wifi连接且通过软串口输出到ardunio"><a href="#实现esp8266wifi连接且通过软串口输出到ardunio" class="headerlink" title="实现esp8266wifi连接且通过软串口输出到ardunio"></a>实现esp8266wifi连接且通过软串口输出到ardunio</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ESP8266代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ssid = <span class="string">&quot;ssid&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pwd = <span class="string">&quot;password&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line"></span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting to &quot;</span>);</span><br><span class="line">  WiFi.begin(ssid, pwd);</span><br><span class="line">  <span class="keyword">while</span>(WiFi.status() != WL_CONNECTED) &#123;</span><br><span class="line">    delay(<span class="number">500</span>);</span><br><span class="line">    Serial.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;Wifi connected&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;IP address: &quot;</span>);</span><br><span class="line">  Serial.println(WiFi.localIP());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ardunio代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SoftwareSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">SoftwareSerial <span class="title">mySerial</span><span class="params">(<span class="number">10</span>, <span class="number">11</span>)</span></span>; <span class="comment">// TX,RX</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  <span class="keyword">while</span> (!Serial) &#123;&#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;Goodnight moon!&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  delay(<span class="number">300</span>);</span><br><span class="line">  mySerial.begin(<span class="number">9600</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mySerial.available()) &#123;</span><br><span class="line">    Serial.write(mySerial.read());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Serial.available()) &#123;</span><br><span class="line">    mySerial.write(Serial.read());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/14/Arduino/first.png" alt="首次成功"></p><p><strong>值得注意的是，一直以来很多论坛说的Ardunio和ESP8266的RX和TX需要反着接，但是尝试之后好像不是这样的。并且成功的最后一步操作是，把两条反接的线再反过来一次，即TX对TX，RX对RX。这里不是很明白，望交流告知</strong>。因此如果没有反应，可以尝试把RX和TX反过来试试。</p><h2 id="舵机"><a href="#舵机" class="headerlink" title="舵机"></a>舵机</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ESP8266端代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;PubSubClient.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ssid = <span class="string">&quot;ssid&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pwd = <span class="string">&quot;pwd&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* mqtt_server = <span class="string">&quot;192.168.1.103&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mqtt_port = <span class="number">1883</span>;</span><br><span class="line"></span><br><span class="line">WiFiClient espClient;</span><br><span class="line"><span class="function">PubSubClient <span class="title">client</span><span class="params">(espClient)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectWifi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  WiFi.begin(ssid, pwd);</span><br><span class="line">  <span class="keyword">while</span> (WiFi.status() != WL_CONNECTED) &#123;</span><br><span class="line">    delay(<span class="number">500</span>);</span><br><span class="line">    Serial.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;Wifi connected&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Serial.println(<span class="string">&quot;IP address: &quot;</span>);</span><br><span class="line">  Serial.println(WiFi.localIP());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reConnectMqtt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!client.connected()) &#123;</span><br><span class="line">    String client_id = <span class="string">&quot;esp8266-client-&quot;</span>;</span><br><span class="line">    client_id += String(WiFi.macAddress());</span><br><span class="line">    Serial.println(<span class="string">&quot;Connecting to public emqx mqtt broker.....&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (client.connect(client_id.c_str())) &#123;</span><br><span class="line">      Serial.println(<span class="string">&quot;Public emqx mqtt broker connected&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.print(<span class="string">&quot;failed with state &quot;</span>);</span><br><span class="line">      Serial.print(client.state());</span><br><span class="line">      delay(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;start to subsc&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span>* topic = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  client.publish(topic, <span class="string">&quot;hello emqx&quot;</span>);</span><br><span class="line">  client.subscribe(topic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting to &quot;</span>);</span><br><span class="line"></span><br><span class="line">  connectWifi();</span><br><span class="line"></span><br><span class="line">  client.setServer(mqtt_server, mqtt_port);</span><br><span class="line">  client.setCallback(callback);</span><br><span class="line">  reConnectMqtt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">char</span> *topic, byte * payload, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  String content = <span class="string">&quot;#&#123;\&quot;topic\&quot;:\&quot;&quot;</span> + String(topic) + <span class="string">&quot;\&quot;, \&quot;msg\&quot;:\&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    content += (<span class="keyword">char</span>) payload[i];</span><br><span class="line">  &#125;</span><br><span class="line">  content += <span class="string">&quot;\&quot;, \&quot;other\&quot;:213&#125;&quot;</span>;</span><br><span class="line">  Serial.println(content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!client.connected()) &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;Reconnenct&quot;</span>);</span><br><span class="line">reConnectMqtt();</span><br><span class="line">  &#125;</span><br><span class="line">  client.loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================</span></span><br><span class="line"><span class="comment">// Arduino端代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SoftwareSerial.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ArduinoJson.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Servo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Servo myServo;</span><br><span class="line"><span class="keyword">int</span> ServoPin = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SoftwareSerial <span class="title">mySerial</span><span class="params">(<span class="number">10</span>, <span class="number">11</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  pinMode(ServoPin, OUTPUT);</span><br><span class="line">  myServo.attach(ServoPin);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!Serial) &#123;&#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;Goodnight moon!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  delay(<span class="number">300</span>);</span><br><span class="line">  mySerial.begin(<span class="number">9600</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String con = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 0：未记录</span></span><br><span class="line"><span class="comment"> * 1：记录日志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> note = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(String)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mySerial.available()) &#123;</span><br><span class="line">    <span class="keyword">char</span> a = mySerial.read();</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;\n&#x27;</span> &amp;&amp; note == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 记录中且读到/n：关闭记录且输出，并清空缓存；</span></span><br><span class="line">      note = <span class="number">0</span>;</span><br><span class="line">      handler(con);</span><br><span class="line">      con = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">&#x27;#&#x27;</span> &amp;&amp; note == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 记录中又读到一个#：输出当前，清空缓存</span></span><br><span class="line">      handler(con);</span><br><span class="line">      con = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">      note = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (note == <span class="number">1</span>) &#123;</span><br><span class="line">      con += a;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StaticJsonDocument&lt;<span class="number">200</span>&gt; doc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* con = str.c_str();</span><br><span class="line">  <span class="keyword">auto</span> error = deserializeJson(doc, con);</span><br><span class="line">  Serial.println(str);</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;parseJson Fail&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* topic = doc[<span class="string">&quot;topic&quot;</span>];</span><br><span class="line">  <span class="keyword">char</span>* msg = doc[<span class="string">&quot;msg&quot;</span>];</span><br><span class="line">  <span class="keyword">int</span> other = doc[<span class="string">&quot;other&quot;</span>];</span><br><span class="line">  Serial.println(<span class="string">&quot;**&quot;</span> + String(topic) + <span class="string">&quot;**&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;**&quot;</span> + String(msg) + <span class="string">&quot;**&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;**&quot;</span> + String(other) + <span class="string">&quot;**&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (String(topic) == <span class="string">&quot;hello&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> te = atoi(msg);</span><br><span class="line">    <span class="comment">// Serial.println(&quot;Servo Angle &quot; + te);// 若是打开这句输出，串口输出就会乱掉，不解</span></span><br><span class="line">    myServo.write(te);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/14/Arduino/end.png" alt="实物图"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次折腾了快一周，算是很有收获，搞清楚了之前一直云里雾里的8266编程和他的AT指令以及串口通信的使用。</p><p><strong>ESP8266和Arduino就像是两个的单片机，如果需要做AT指令不好完成的操作，当然需要另外编写代码烧录到8266中。而如果只是连接Wifi还是可以通过AT指令完成的，甚至进行MQTT通信，也可以使用对应的AT固件完成。</strong></p><p>实际上在各种查阅时候，确实看到某大佬自己编写的支持8266进行mqtt通信的指令固件，参见<a href="http://wenzheng.club/2019/02/14/index/">他的站点</a>。对于这种大佬也是只有崇拜啦</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近尝试使用Arduino配合esp8266实现远程控制Arduino上外接的某些模块，于是开始一边摸索一遍折腾开始了一周的尝试，期间得到很一些对自己很有用的经验，遂记录。&lt;br&gt;本次使用的策略是Arduino通过串口与esp8266通信，esp8266通过wifi连接到网络，然后通过mqtt协议订阅模块的操作信息，客户端就可以通过远程向mqtt发送相关主题的操作信息从而控制Arduino做出相应的约定动作。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Code" scheme="http://codeminions.github.io/categories/Code/"/>
    
    
    <category term="技能帖" scheme="http://codeminions.github.io/tags/%E6%8A%80%E8%83%BD%E5%B8%96/"/>
    
    <category term="MQTT" scheme="http://codeminions.github.io/tags/MQTT/"/>
    
    <category term="Arduino" scheme="http://codeminions.github.io/tags/Arduino/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://codeminions.github.io/2021/02/12/hello-world/"/>
    <id>http://codeminions.github.io/2021/02/12/hello-world/</id>
    <published>2021-02-12T09:42:57.961Z</published>
    <updated>2021-02-12T09:42:57.961Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;</summary>
    
    
    
    <category term="Blog" scheme="http://codeminions.github.io/categories/Blog/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo 博客本地迁移</title>
    <link href="http://codeminions.github.io/2021/01/31/Hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E8%BF%81%E7%A7%BB/"/>
    <id>http://codeminions.github.io/2021/01/31/Hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E8%BF%81%E7%A7%BB/</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2021-02-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景：最近换了一台电脑，原来的主力机几近退役，故需要把工作台进行迁移。其中包括把Hexo的本地文件进行转移。经过查找总结，得出此文。</p></blockquote><h1 id="可能需保留的原文件"><a href="#可能需保留的原文件" class="headerlink" title="可能需保留的原文件"></a>可能需保留的原文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_config.yml&#x2F;&#x2F; 保存对于hexo的一些个性化设置</span><br><span class="line">package.json&#x2F;&#x2F; 记录hexo框架依赖的版本信息</span><br><span class="line">scaffolds&#x2F;&#x2F;&#x2F; 自动生成post使使用的脚手架</span><br><span class="line">source&#x2F;&#x2F;&#x2F; 文稿源文件</span><br><span class="line">themes&#x2F;&#x2F;&#x2F; 使用的主题文件</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="npm安装hexo插件"><a href="#npm安装hexo插件" class="headerlink" title="npm安装hexo插件"></a>npm安装hexo插件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure><p>该指令会通过package.json文件获取模块及版本信息，然后进行下载安装。可以使用npm update指令进行模块更新<br>如果没有package.json，也可以直接安装以下模块，可以保证hexo模块运行，但是一些其他的插件，需要自己重新安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-deployer-git --save</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-feed --save</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-sitemap --save</span></span><br></pre></td></tr></table></figure><br>通过npm安装模块之后，则会生成<strong>node_modules</strong>文件夹</p><h1 id="运行hexo"><a href="#运行hexo" class="headerlink" title="运行hexo"></a>运行hexo</h1><p>使用<strong>hexo g</strong>尝试生成部署文件（<strong>public文件夹</strong>）<br>使用<strong>hexo s</strong>在本地4000（可选择）端口运行服务<br>至此迁移工作完成～</p><h1 id="出现的一些问题"><a href="#出现的一些问题" class="headerlink" title="出现的一些问题"></a>出现的一些问题</h1><ol><li>swig插件问题<br>现象：generator过程中出现报错，且生成index.html文件不是正常的html标签<blockquote><p><code>&#123;% extends ‘_layout.swig’ %&#125; &#123;% import ‘_macro/post.swig‘ as post_template %&#125;</code></p></blockquote>类似这样的信息<br>原因是hexo5以后删除了swig，需要自己手动安装<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-renderer-swig</span></span><br></pre></td></tr></table></figure></li><li><p>图片资源问题<br>关于博客中的插图，我之前的方案是放到theme/images/中，这样打包时候可以原封不动的打包到public/images中，然后我再引用。<br>如今发现一种正确的姿势，即在<code>_config.yml</code>中设置<strong>post_asset_folder</strong>为true，然后生成post（hexo new xx）时便会在source中同时生成一个同名文件夹，其中存放该文章的插图资源等，打包时将一同打包。最后在生成的public文件中，图片与文章的index文件是在同一级文件夹下的。<br>但是存在一个问题，图片的路径默认相对根目录是/year/month/day/title/image.jpg，而虽然在博客中直接通过图片名字引用<code>![xx](image.jpg)</code>是没有问题的，因为实际上就是在统一目录下。但是这样的写法，在其他页面如预览页时图片是无法加载的（因为用的不是图片同级的index.html，自然索引不到）。手动写上/year/month/day/title/image.jpg，又感觉怪怪的，因此有大佬为hexo框架提供了一个脚本模块<strong>hexo-asset-link</strong>，帮助我们实现了md文件转换为index.html时图片路径的填充完善。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-asset-link</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装hexo-asset-link模块之后，直接通过![xx](title/iamge.jpg)则可以加载图片</span></span><br></pre></td></tr></table></figure><p>看到很多帖子使用hexo-asset-image，但是这个插件填充的路径是基于<code>_config.yml</code>中的url项绝对路径访问，很多人都再去修改了其index.js文件代码，实现相对路径的访问，私以为有些画蛇添足。也有人直接将修改后的代码，封装为一个module，即是hexo-zngw-asset-image，因此这个插件跟hexo-asset-link一样也是直接可用的，只是实现方式不同而已。</p></li><li><p>关于hexo转义的小问题<br>现象：generator时候出现报错</p><blockquote><p>  err: Template render error: (unknown path)<br>  Error: template names must be a string: undefined<br>这时候可以通过<strong>hexo g –debug</strong>，看到更多的log信息。（有人说甚至可以显示具体行数）<br>可看到我这个问题是在渲染某篇文章出现的。经排查发现是使用了<code>&#123;[%]&#125;</code>这些符号导致转义出现问题。解决方式是使用<code></code>将文本块括起来，即可解决。</p></blockquote></li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上是本次迁移Hexo博客时候出现的一些问题与部分心得体会。加深了些对Hexo的理解。后续可以把这些原文件放到另一个仓库或另一个分支中，进行版本管理及备份，方便使用。</p><hr><h1 id="NexT主题配置"><a href="#NexT主题配置" class="headerlink" title="NexT主题配置"></a>NexT主题配置</h1><h2 id="通过css设置背景透明度等"><a href="#通过css设置背景透明度等" class="headerlink" title="通过css设置背景透明度等"></a>通过css设置背景透明度等</h2><p>首先在NexT的_config.yml中启用自定义style</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define custom file paths.</span></span><br><span class="line"><span class="comment"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span></span><br><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure><p>其中显示的路径是相对根目录，即Hexo根目录的source文件夹下，新建_data文件夹（即跟<code>_post</code>文件夹放一块），其中新建styles.styl文件，写入以下代码，有一点点css基础的可以修改或者自己写（没有其实也可以）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 添加背景图片</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">      background: url(/images/wall.png);// 背景图路径，相对NexT的source目录</span><br><span class="line">      <span class="selector-tag">background-size</span>: <span class="selector-tag">cover</span>;</span><br><span class="line">      <span class="selector-tag">background-repeat</span>: <span class="selector-tag">no-repeat</span>;</span><br><span class="line">      <span class="selector-tag">background-attachment</span>: <span class="selector-tag">fixed</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 博客内容透明化</span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//侧边框的透明度设置</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.85</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//菜单栏的透明度设置</span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.85</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//搜索框（<span class="selector-tag">local-search</span>）的透明度设置</span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.85</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>旧版本的NexT是在css/_custom/里做的修改，新版本已经取消了这个文件。具体方式请百度</li><li>Linux/Mac下可以用vim编辑，Windows可以用notepad（记事本）编辑</li></ol><h2 id="文末添加结束语"><a href="#文末添加结束语" class="headerlink" title="文末添加结束语"></a>文末添加结束语</h2><p>NexT同样为我们提供了自定义结束语样式的方式</p><ul><li><p>首先在theme/_config.yml的<code>custom_file_path</code>中取消<code>postBodyEnd</code>的注释，即启用该文件，然后在<code>_data</code>文件夹中创建该文件post-body-end.swig</p></li><li><p>我希望实现在文章配置中可以设定是否启用结束语。于是先自定义一个属性比如<code>end</code>，表示该文是否已经结束</p></li><li><p>在post-body-end.swig文件中通过判断该属性以决定是否显示自定义样式的结束语【索引属性方式会在<a href="#修改swig文件">这里</a>提到】。比如我是这么写的（html是东拼西凑乱写的，如果有更好的建议可以告诉我谢谢～）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;%- if post.end != false %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot; width:100%; text-align:center; margin-left:15px; margin-right:15px;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">&quot;width:30%;vertical-align:middle; display:inline-block;&quot;</span>/&gt;</span></span><br><span class="line">    完结</span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-paw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    撒花 ฅ<span class="symbol">&amp;gt;</span>ω<span class="symbol">&amp;lt;</span>*ฅ</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">&quot;width:30%;vertical-align:middle; display:inline-block;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure><p>文章end属性不设置或设置true，则可以在文章底部看到效果如下：<img src="/2021/01/31/Hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E8%BF%81%E7%A7%BB/end.png" alt="end"></p></li></ul><h2 id="NexT配置文件"><a href="#NexT配置文件" class="headerlink" title="NexT配置文件"></a>NexT配置文件</h2><p>有点强迫症，稍微看了下NexT主题的_config.yml中的可配置项，稍作记录（基于v7.8.0）</p><p>【写完发现，已经有大佬对所有配置项进行解释，虽然版本可能没这么新，写的很详细，感谢<a href="https://blog.csdn.net/weixin_42119041/article/details/104101566">这篇文章</a>】</p><ul><li>前边minify等项配置运行时文件操作，如生出hexo generation生成的文件，缓存清理等</li><li>favicon标签：设置一些网站图标</li><li>footer：网站底部的这一部分。<br>  <img src="/2021/01/31/Hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E8%BF%81%E7%A7%BB/footer.png" alt="footer"><ul><li>since：设置起始时间</li><li>icon：指🧡图标，可修改图标，颜色，以及动画开关（跳动）</li><li>copyright：版权信息，默认使用hexo中配置的author</li><li>power：是否显示x x强力驱动信息</li><li>beian：显示备案信息</li></ul></li><li>scheme：配置主题，内置一共四款主题</li><li>darkmode：惊喜发现，居然内置了黑夜主题，并有一键开关</li><li>menu：配置菜单栏的单项，“||”之前代表跳转路径，“||”之后代表所使用的图标</li><li>sidebar：配置边栏的样式，宽度等</li><li>social：配置社交平台显示及地址</li><li>links_setting：关于友链设置。下边的links可添加友链。<ul><li>layout：多个友链的布局。块状或内联。可理解为垂直或水平</li></ul></li><li>toc：设置文章页边栏目录的展示情况<ul><li>number：目录添加序号</li><li>wrap：多级目录缩进</li><li>expand_all：直接展开全部，否则只完全展开当前小节</li></ul></li><li>tagcloud：为标签页添加标签云效果，即是以词云形式显示标签。需要集成如hexo-tag-cloud插件</li><li>calendar：设置云日历，可以显示提交日期。找到一个挺好的插件hexo-generator-calendar</li><li>codeblock：代码块样式。设置代码高亮，复制按钮，边框样式（mac）等</li><li>reading_progress：顶部显示阅读进度条</li></ul><p>以下是一些第三方插件的集成方式。最大的体验就是NexT真的是一个很成熟的主题框架，很多很多的地方都已经配置好了模版，只需要简单安装插件，配置项中启用即可！</p><h2 id="百度统计功能集成"><a href="#百度统计功能集成" class="headerlink" title="百度统计功能集成"></a>百度统计功能集成</h2><p>NexT的<a href="http://theme-next.iissnan.com/getting-started.html">官方文档</a>中即有百度统计集成方式</p><p>具体方法也是十分简单，首先进入<a href="https://tongji.baidu.com/">百度统计官网</a>，登陆后新增网址填写域名地址等信息，即可以得到一段js脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> _hmt = _hmt || [];</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> hm = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  hm.src = &quot;https://hm.baidu.com/hm.js?1af6bacc90d9688e38f7413e7080cb35&quot;;# 需要注意这段id</span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;script&quot;</span>)[<span class="number">0</span>]; </span><br><span class="line">  s.parentNode.insertBefore(hm, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>将此脚本添加到博客网站的html文件中即可。但这段脚本模版NexT已经帮我们写好，我们只需要在主题配置文件_config.yml中配置<strong>baidu_analytics</strong>字段即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_analytics:</span> <span class="comment"># 内容是脚本中的hm.src中的url中js?以后的那段id数字</span></span><br></pre></td></tr></table></figure><p>此时在浏览器中通过开发者工具查看html源码，搜索<code>baidu</code>字段即可看到该脚本已经在html中生成</p><p>根据百度官网提示，也可以通过<a href="https://tongji.baidu.com/web/help/article?id=93">这些方式</a>确认是否集成成功</p><h2 id="Gitalk评论功能集成"><a href="#Gitalk评论功能集成" class="headerlink" title="Gitalk评论功能集成"></a>Gitalk评论功能集成</h2><p>想要集成一个评论功能，看了好些第三方像畅聊，多说，网易等都停止服务了，disqus又可能因为qiang的原因不方便使用。后来发现了<strong>gitment</strong>和<strong>gitalk</strong>，都是基于github仓库的issues的评论服务，感觉很满足我的需求了，在NexT中配置gitalk比较方便，故使用之。</p><ol><li><p>首先需要在github注册OAuth Application。填写App名称，域名，和描述。两个URL需填写博客地址，其余无甚要求。注意URL需要加上https://，建议直接地址栏复制</p><p>申请成功后会得到一个Client ID和Client secrets，这是配置需要用到的两个字段</p></li><li><p>NexT的_config.yml中已经有gitalk字段，只要根据注释进行配置即可，大概是github用户名，博客地址，两个id这样。</p></li><li><p>由于是基于issues，所以每一篇文章都需要在githubc仓库的issues里进行初始化，否则会出现</p><p><img src="/2021/01/31/Hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E8%BF%81%E7%A7%BB/gitalk.png" alt="未初始化"></p></li></ol><p>此时部署成功之后，即可在文章底部看到评论栏。如果某一篇文章不开放评论功能，可以在文中设置<code>comment: false</code></p><h2 id="valine评论功能集成"><a href="#valine评论功能集成" class="headerlink" title="valine评论功能集成"></a>valine评论功能集成</h2><p>后来又发现一种更好的评论插件valine，也可以由NexT的_config.yml直接集成</p><p>valine是由cloudclean提供的评论功能，所以需要有一个Cloudclean平台账号，评论数据会存储在cloudclean平台里。因此管理（删除）评论也是直接操作平台数据库进行。</p><p>Cloudclean创建应用具体操作及配置可以参考<a href="https://www.luanzhuxian.com/post/c49d1b87.html">这篇博客</a>。</p><p>创建完应用，得到appid，appkey，就可以填入NexT的_config.yml中，enable启用，即可在页面上看到效果。且如果不开启验证的话<code>notify</code>，直接输入即可进行评论，效果将会以一个Anonymous的身份进行评论。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># For more information: https://valine.js.org, https://github.com/xCss/Valine</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">xxxxx</span> <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">xxxxx</span> <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># Mail notifier</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">language:</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># Article reading statistic</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line">  <span class="comment">#post_meta_order: 0</span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>source/categories/index.md</code>和<code>source/tags/index.md</code>里要禁用<code>comments</code>，否则分类和标签页面会显示评论框</p></blockquote><h2 id="配置站内搜索"><a href="#配置站内搜索" class="headerlink" title="配置站内搜索"></a>配置站内搜索</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="comment"># 根据输入自动发起检索不需要回车</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="comment"># 显示每篇文章中命中的前n个关键字。设置-1可展示所有结果</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>NexT主题_config.yml文件中local_search字段启用，根据提示安装插件<code>npm install hexo-generator-searchdb</code></p><h2 id="显示文章字数及阅读时间"><a href="#显示文章字数及阅读时间" class="headerlink" title="显示文章字数及阅读时间"></a>显示文章字数及阅读时间</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>同样在主题_config.xml中symbols_count_time，并安装插件<code>npm install hexo-symbols-count-time</code></p><h2 id="RSS配置"><a href="#RSS配置" class="headerlink" title="RSS配置"></a>RSS配置</h2><blockquote><p>RSS 广泛用于网上新闻频道，blog和 wiki，主要的版本有 0.91, 1.0, 2.0。使用 RSS 订阅能更快地获取信息，网站提供 RSS 输出，有利于让用户获取网站内容的最新更新。网络用户可以在客户端借助于支持 RSS 的聚合工具软件，在不打开网站内容页面的情况下阅读支持 RSS 输出的网站内容。</p></blockquote><p>RSS功能具体是干什么的，其实我还是看不明白。这里主要是配置过程中，发现一些其他的小小问题，所以顺便记录一下。</p><div class="note info">            <p>后来通过这个<a href="https://www.zhihu.com/question/19580096/answer/20490041">回答</a>，对RSS有了一些了解，确实是一种现在很少见的订阅咨询方式</p>          </div><p>同样，NexT支持直接配置rss，但还需要安装插件<strong><code>npm install hexo-generator-feed</code></strong>，然后在NexT的_config.yml中，直接取消rss的注释即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">follow_me:</span></span><br><span class="line">  <span class="attr">RSS:</span> <span class="string">/atom.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-rss</span></span><br></pre></td></tr></table></figure><p>感到奇怪的是，页面刷新了，但是没有看到在侧边栏出现RSS的图标按钮，public/下确实如其他文章所说出现了atom.xml文件。一筹莫展之际看到<a href="https://suyin-blog.club/2020/2M3YWE7/">这篇博客</a>，其中说到</p><blockquote><p>在 <code>social:</code> 下添加以上代码。在 Next v7.7.2 中将 RSS 设置在了 <code>follow_me:</code> 下，这个是在文章的结尾处显示 RSS，而且占地比较大，所以我不太喜欢这个位置，还是喜欢以前的 <code>social:</code> 这个位置，这样会显示在侧边栏里，而且占地很小。</p></blockquote><p>果不其然，follow me下设置的RSS，会出现在文章底下，而且确实有一大块。于是在_config.yml中找到social，虽然其中没有预置rss一项，但是直接将<code>follow me</code>下的rss复制过去即可。想想确实也没有毛病，符合格式，有链接，有图标，很正常</p><h2 id="修改swig文件"><a href="#修改swig文件" class="headerlink" title="修改swig文件"></a>修改swig文件</h2><p>修改主题样式时经常需要直接修改swig文件。关于swig，我其实没有见过，大概是一个用于生成html的模版文件，解释器根据该文件所以对应的布局文件进行整合，拼凑最终的html文件</p><ul><li>language的文案：在swig中，可以通过<strong><code>__(&#39;xx.xx&#39;)</code></strong>的方式获取language中配置的文本</li><li>theme/_config.yml配置：在swig中，可以通过<strong><code>theme.xx</code></strong>获取主题配置文件中的配置信息</li><li>post配置：在swig中，可以通过<strong><code>post.xx</code></strong>获取在文章中配置的信息，当然自定义的属性也可以</li></ul><h2 id="拉拉杂杂"><a href="#拉拉杂杂" class="headerlink" title="拉拉杂杂"></a>拉拉杂杂</h2><p>以下记录一下看到的一些好玩（花里胡哨）的配置。</p><ul><li><p>在线聊天插件<a href="https://www.daocloud.io/">DaoVoice</a></p><p>建站时间，在<code>/blog/themes/next/layout/_partials/footer.swig</code>中添加这部分代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;days&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show_date_time</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="string">&quot;show_date_time()&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    BirthDay=<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;04/17/2018 15:13:14&quot;</span>);<span class="comment">//修改为自己的blog建站时间</span></span><br><span class="line">    today=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    timeold=(today.getTime()-BirthDay.getTime());</span><br><span class="line">    sectimeold=timeold/<span class="number">1000</span></span><br><span class="line">    secondsold=<span class="built_in">Math</span>.floor(sectimeold);</span><br><span class="line">    msPerDay=<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span></span><br><span class="line">    e_daysold=timeold/msPerDay</span><br><span class="line">    daysold=<span class="built_in">Math</span>.floor(e_daysold);</span><br><span class="line">    e_hrsold=(e_daysold-daysold)*<span class="number">24</span>;</span><br><span class="line">    hrsold=setzero(<span class="built_in">Math</span>.floor(e_hrsold));</span><br><span class="line">    e_minsold=(e_hrsold-hrsold)*<span class="number">60</span>;</span><br><span class="line">    minsold=setzero(<span class="built_in">Math</span>.floor((e_hrsold-hrsold)*<span class="number">60</span>));</span><br><span class="line">    seconds=setzero(<span class="built_in">Math</span>.floor((e_minsold-minsold)*<span class="number">60</span>));</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;days&#x27;</span>).innerHTML=<span class="string">&quot;本站已安全运行&quot;</span>+daysold+<span class="string">&quot;天&quot;</span>+hrsold+<span class="string">&quot;小时&quot;</span>+minsold+<span class="string">&quot;分&quot;</span>+seconds+<span class="string">&quot;秒&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setzero</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;i=<span class="string">&quot;0&quot;</span> + i&#125;;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">show_date_time();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>文章加密功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;&#123;&#123; page.password &#125;&#125;&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (prompt(<span class="string">&#x27;请输入文章密码&#x27;</span>) !== <span class="string">&#x27;&#123;&#123; page.password &#125;&#125;&#x27;</span>)&#123;</span><br><span class="line">                alert(<span class="string">&#x27;密码错误！&#x27;</span>);</span><br><span class="line">                history.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改字体大小。</p><p>在<code>themes/next/source/css/_variables/base.styl</code>中的<code>font-size-headings-step</code></p><p>以及<code>themes/next/source/css/_variables/Mist.styl</code>中的<code>font-size-headings-base</code></p></li></ul><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><a href="http://theme-next.iissnan.com">官方文档</a></h2><p><a href="http://theme-next.iissnan.com/third-party-services.html#algolia-search">第三方插件配置</a>：以上配置文档基本都有说明</p><p><a href="http://theme-next.iissnan.com/tag-plugins.html">内置标签使用</a>：可以适当美化文章</p><p><a href="http://theme-next.iissnan.com/theme-settings.html">文章配置</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;背景：最近换了一台电脑，原来的主力机几近退役，故需要把工作台进行迁移。其中包括把Hexo的本地文件进行转移。经过查找总结，得出此文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;可能需保留的原文件&quot;&gt;&lt;a href=&quot;#可能需保留的原文件&quot; class=&quot;headerlink&quot; title=&quot;可能需保留的原文件&quot;&gt;&lt;/a&gt;可能需保留的原文件&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_config.yml	&amp;#x2F;&amp;#x2F; 保存对于hexo的一些个性化设置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;package.json	&amp;#x2F;&amp;#x2F; 记录hexo框架依赖的版本信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scaffolds&amp;#x2F;	&amp;#x2F;&amp;#x2F; 自动生成post使使用的脚手架&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;source&amp;#x2F;		&amp;#x2F;&amp;#x2F; 文稿源文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;themes&amp;#x2F;		&amp;#x2F;&amp;#x2F; 使用的主题文件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Blog" scheme="http://codeminions.github.io/categories/Blog/"/>
    
    
    <category term="技能帖" scheme="http://codeminions.github.io/tags/%E6%8A%80%E8%83%BD%E5%B8%96/"/>
    
    <category term="Hexo" scheme="http://codeminions.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java锁机制</title>
    <link href="http://codeminions.github.io/2020/10/24/%E6%B5%85%E8%B0%88Java%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://codeminions.github.io/2020/10/24/%E6%B5%85%E8%B0%88Java%E9%94%81%E6%9C%BA%E5%88%B6/</id>
    <published>2020-10-23T16:00:00.000Z</published>
    <updated>2021-02-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>锁的概念，来自于操作系统。<br>在操作系统中，进程是内存独立，实现进程间的通信需要通过一些其他的手段；但是线程之间是内存共享的，当有多个线程对某一临界资源（有可能被多个线程访问，存在线程安全的数据）进行读写访问时，就会出现线程安全的问题。<br><em>锁概念</em></p><a id="more"></a><p>根据锁对访问限制规则的不同，可以将锁进行分类。下面介绍一下在Java中主要的锁。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><h3 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h3><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><h2 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h2><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><h2 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h2><h1 id="Java锁实现"><a href="#Java锁实现" class="headerlink" title="Java锁实现"></a>Java锁实现</h1><p>在Java中，除了使用关键字synchronized进行加锁，在Java5以后，还引入了一个juc包，其中增加了许多适用于Java的线程安全的实现，比如一系列Lock类。<br>实现Lock的锁类型，可以通过lock.lock()或lock.unLock()进行灵活的加锁和释放锁。其底层实现原理其实是通过Java代码调用native层，再调系统接口实现的。而synchronized则主要是JVM层实现。这里主要讲一下synchronized的运作机制。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><img src="https://upload-images.jianshu.io/upload_images/2062729-b98084591219da8c.png" style="zoom:40%;" /></p><p>可以看到，经过编译以后，synchronized关键字的代码块，会被编译为两个虚拟机指令，分别对应着加锁和释放锁操作。</p><p>这里我想说一下自己对加锁的理解。Java中的加锁操作，其实是把某个对象当做锁（monitor），也就是每一个对象都是一个锁，对象头中的MaskWord中，记录着该对象的锁状态及拥有的线程信息。</p><p>当代码运行进入到同步代码块中，执行monitorenter指令，jvm会去尝试获取monitor的所有权。如果monitor的进入数为0，则线程可以拥有该monitor，并且进入数置1。synchronized是一种可重入锁，因此如果获取所有权时发现已有线程拥有，但是同一个线程，则可以直接进入，并且进入数+1。</p><p>当同步代码块运行结束，执行monitorexit，jvm会先去判断，执行该指令的必须是monitor的拥有者，然后进入数-1。如果进入数为0，则该线程不再是该monitor拥有者。</p><p><img src="https://upload-images.jianshu.io/upload_images/2062729-8b7734120fae6645.png" style="zoom:40%;" /></p><blockquote><p>两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p></blockquote><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>在Java1.6以前，synchronized的性能是比较糟糕的，比不上Lock。但是在Java1.6以后，对synchronized做了性能优化，和Lock其实是并驾齐驱的，可以根据具体场景进行选择。</p><p>在1.6中，synchronized增加了一个锁升级的过程。</p><p>首先，synchronized默认是乐观锁，可以认为是无锁，即假设没有线程竞争，通过cas操作实现。</p><p>如果锁一直只被一个线程持有，那么乐观锁转变为偏向锁。直接检测对象头里是否存在该线程id，而不是用cas操作，进而提高了性能。并且不会主动释放偏向锁。</p><p>当有其他线程访问同步代码块时，锁会升级为轻量锁，区别在于等待线程会进行自旋</p><p>自旋超过一定次数 或者有第三个线程竞争，则升级为重量锁，等待的线程直接挂起</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;锁的概念，来自于操作系统。&lt;br&gt;在操作系统中，进程是内存独立，实现进程间的通信需要通过一些其他的手段；但是线程之间是内存共享的，当有多个线程对某一临界资源（有可能被多个线程访问，存在线程安全的数据）进行读写访问时，就会出现线程安全的问题。&lt;br&gt;&lt;em&gt;锁概念&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Code" scheme="http://codeminions.github.io/categories/Code/"/>
    
    
    <category term="Java" scheme="http://codeminions.github.io/tags/Java/"/>
    
    <category term="秘籍帖" scheme="http://codeminions.github.io/tags/%E7%A7%98%E7%B1%8D%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>浅谈equals()和hashCode()</title>
    <link href="http://codeminions.github.io/2020/10/18/equals%E5%92%8ChashCode/"/>
    <id>http://codeminions.github.io/2020/10/18/equals%E5%92%8ChashCode/</id>
    <published>2020-10-17T16:00:00.000Z</published>
    <updated>2021-02-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开始思考这个问题，要从一道面试题开始，面试官问我，HashMap中存的对象没有重写hashCode()会有什么影响…</p></blockquote><a id="more"></a><h1 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h1><p>众所周知，equals()是Java中Object的基本方法，用于比较两个对象是否相等。</p><h2 id="和equals"><a href="#和equals" class="headerlink" title="==和equals()"></a>==和equals()</h2><p>经常会被问的问题是==和equals()的区别。使用==对对象进行比较时，是使用两个对象的内存地址进行比较，equals()的话，如果没有对它进行重写，其实也是比较对象的内存地址。所以一般需要我们对他根据具体的业务逻辑进行重写。</p><h1 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h1><p>这个方法很多人都知道，但不一定真的知道，比如我。<br>hashCode()也是Object的基本方法，用于计算对象的hash值，默认也是返回对象的内存地址。如果问有没有过重写hashCode的场景，我是没有的；但如果问，有没有使用HashMap存过自定义对象，那肯定是有的。但是使用HashMap存自定义对象却不重写hashCode()方法，那便有问题了。</p><h2 id="HashMap和hashCode"><a href="#HashMap和hashCode" class="headerlink" title="HashMap和hashCode()"></a>HashMap和hashCode()</h2><p>首先设定一个场景<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> k;</span><br><span class="line">    <span class="comment">// 先不对Key的equals和hashCode进行重写</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">HashMap&lt;Key, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="keyword">new</span> Key(<span class="number">1</span>), <span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.get(<span class="keyword">new</span> Key(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><br>假定int k可以唯一的标识一个Key对象（比如是身份证号），那么从业务角度说，map.get是可以get到上一行put的这个对象返回”1”的，因为认为两次new的Key是同一个对象。<br>但实际上get()返回的结果是null。为什么？<br>这要从HashMap的put操作开始说起。HashMap put对象时，会先通过hashCode()方法获取对象Hash值，进行计算得到索引位置以后存到对应位置。get对象时，仍然通过hashCode()方法获取hash值计算出索引，进而找到对象。而如果没有重写hashCode()，则默认返回对象的地址，所以以上场景，两次new的Key对象地址肯定不一样，所以get出来会是null。<br>那重写了hashCode方法，返回k.hashCode()，因为同样的k的Hash值肯定是一样的（<strong>Integer的hashCode()是返回自身的值</strong>），这个时候能否get到呢？实际上还是不能。因为还需要重写equals()。<br>上文说到HashMap方法get时通过对象的hash值找到具体位置，由于Java的HashMap实现是使用链表解决冲突，即冲突的对象们会在相应的索引位置以链表形式存储，因此hash值相同的对象可能会有多个，需要对链表元素进行遍历比较，这时候使用的便是equals()方法。由于没有重写equals()所以默认比较对象的地址，自然也不会有匹配的对象。<br>如果对equals()和hashCode()都进行重写，就能满足我们需要，返回”1”了。</p><p><img src="/Users/linweixian/Desktop/截屏2020-10-18 上午1.27.35.png" alt="code" style="zoom:45%;" /></p><h1 id="equals-与hashCode"><a href="#equals-与hashCode" class="headerlink" title="equals()与hashCode()"></a>equals()与hashCode()</h1><p>如此说来，equals()与hashCode()都能用于对象之间的比较，那么他们有何区别呢？</p><ul><li>从效果（可靠性）上说，使用equals()方法进行比较，如果结果是true的，则两个对象认为是同一个对象（业务逻辑上来说）；如果equals()比较是相等的，则hashCode()返回的结果也会是相等的，因为都是相同的数值进行计算嘛。但是如果是两个不同的对象，其hash值计算结果却是有可能相等的（否则也不会有hash冲突这一说了，这取决于计算的方式）。</li><li>从性能上来说，由于equals()的比较涉及具体的业务逻辑，更加全面往往复杂一些，效率就比较低；而hashCode()由于只是涉及hash码的计算生成，所以速度自然更快一些</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><blockquote><p>没有对equals()和hashCode()进行重写，默认都是使用对象的地址进行计算。<br>equals()返回true的两个对象一定相等，hashCode()返回true时equals()不一定返回true，即对象不一定相等，但hashCode()返回false的两个对象一定不相等<br>由于两个方法效果和性能的不同，当需要对多个对象进行比较时，可以通过先比较hashCode，如果hashCode一样再进行equals()的比较；如果hashCode都不一样，则没有必要再进行下一步比较了。从而节约一些性能。<br>需要对多个对象进行比较的场景，比如使用HashMap和HashSet进行存储，由于这两个都不允许存储相同的对象，因此存入过程中必定都涉及容器内已有对象的比较，这种时候先比较hashCode的性能优势就比较明显了。</p><p>关于hashCode()返回true，equals()返回false的场景，比如两个对象A，B，都拥有属性String a且是相等，则他们的hashCode就是相等的，实际上他们却是两个不同对象，所以equals()一定是false的。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开始思考这个问题，要从一道面试题开始，面试官问我，HashMap中存的对象没有重写hashCode()会有什么影响…&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Code" scheme="http://codeminions.github.io/categories/Code/"/>
    
    
    <category term="Java" scheme="http://codeminions.github.io/tags/Java/"/>
    
    <category term="秘籍帖" scheme="http://codeminions.github.io/tags/%E7%A7%98%E7%B1%8D%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>APT（注解处理器）学习与理解</title>
    <link href="http://codeminions.github.io/2019/11/20/APT%EF%BC%88%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%89%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3/"/>
    <id>http://codeminions.github.io/2019/11/20/APT%EF%BC%88%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%89%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3/</id>
    <published>2019-11-20T13:06:00.000Z</published>
    <updated>2021-02-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这段时间通过对注解管理器的学习，跟着网课简单实现了玉观音注解处理，对注解有更多理解。<br>同时由于该网课是基于kotlin讲解，于是也get了很多kotlin的基本操作之外的炫酷操作<br>因此这篇文章，重在自身的记录理解</p></blockquote><a id="more"></a><h1 id="Java注解基础"><a href="#Java注解基础" class="headerlink" title="Java注解基础"></a>Java注解基础</h1><p>注解可以理解为标签，用于对代码的标记识别。使用<strong>@interface</strong>定义一个注解。</p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>5种元注解，作为基本注解可以用于修饰其他的注解。</p><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>标示一个注解的存活时间，即生命周期。</p><ul><li>RetentionPolicy.SOURCE 只在源码阶段保留，编译时被编译器丢弃</li><li>RetentionPolicy.CLASS    只被保留到编译时，不会被加载到JVM中</li><li>RetentionPolicy.RUNTIME 可以被保留到运行时，故可以在运行时获取</li></ul><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>可以将注解中的内容添加到JavaDoc中去。</p><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>限定一个注解的使用场景。一般的注解使用场景不被限定，使用该注解以后使用场景被限定。</p><ul><li>ElementType.ANNOTATION_TYPE 对一个注解进行注解</li><li>ElementType.CONSTRUCTOR 对构造方法进行注解</li><li>ElementType.FIELD 对属性字段进行注解</li><li>ElementType.LOCAL_VARIABLE 对局部变量进行注解</li><li>ElementType.METHOD 对方法进行注解</li><li>ElementType.PACKAGE 对一个包进行注解</li><li>ElementType.PARAMETER 对一个方法参数进行注解</li><li>ElementType.TYPE 对一个类型进行注解，如类，接口，枚举</li></ul><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>标示该注解标示的类的子类如果没有注解的话，可以继承父类的注解。</p><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p>标示该注解可以被使用于同一位置，一般是注解的值可以有多个。实例如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Persons.class)</span></span><br><span class="line"><span class="meta">@interface</span> Person &#123;</span><br><span class="line"><span class="function">String <span class="title">role</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">Person[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中@Repeatable后的Person相当于一个容器注解，<em>即用于存放其他注解的地方</em>，其本身也是一个注解。<br>容器注解需要设置一个value字段作为注解容器，因此value需要是一个数组，并且其中的注解类型需要是被@Repeatable标示的注解。</p><h2 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h2><p>注解不存在成员方法，只有成员属性，并可以指定默认值，定义方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Person &#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="meta">@Person(value=1, msg=&quot;hi&quot;)</span></span><br></pre></td></tr></table></figure><br>当只有一个成员属性时，可以直接在括号中填写其值无需在写参数名；若没有成员属性</p><h1 id="Android中的注解"><a href="#Android中的注解" class="headerlink" title="Android中的注解"></a>Android中的注解</h1><p>apt即AnnotationProcessingTool，注释处理工具</p><ul><li>android-apt和AnnotationProcessor<br>android-apt是一位开发者开发的apt框架。AndroidGradle2.2以后提供了annotationProcessor替代android-apt，不支持使用android-apt。但是目前很多项目还是使用的android-apt。</li></ul><ul><li>注解处理器是Java层面的东西多所以无法知道kotlin层的东西，因此需要使用Builder::class.java</li><li>工具类中的Logger类中的note只能在debugger时才能生效（看看实现）</li><li>没有添加kotlin插件支持的模块，将不会处理.kt文件 apply ‘kotlin’</li><li>build/tmp/kapt3/stubs/debug/*.java 使用kapt后将kotlin代码解释为java文件后存放位置</li><li>启用kotlin插件 ‘kotlin-kapt’ 后 通过kapt project() 指定apt模块来指向我们编写的Annotation Process Tool</li><li><em>Element 元素 到底是个什么东西？</em>    <strong>其实就是注解修饰的对象，可以是成员字段，成员方法，类等</strong></li><li>对注解信息进行解析。通过对Element进行解析。TypeElement是Element的一个实现</li><li>Element.getName获取到的Name对象，其实就是一个CharSequence字符序列</li><li>Element.getPackage()获取到包名。如果是一个包，就抛出错误</li><li><p>对对成员字段进行保存排序，<strong>使用TreeSet</strong>，使得成员字段发生增删变化后，其相对顺序仍保持不变，便于开发</p></li><li><p>自定义Field字段类</p><ul><li>设置value并private set，因为其值由注解传入</li><li><em>prefix字首 字段的含义</em>    </li><li><em>TypeMirror?        TypeMirror是Java编译时对java类型的一个表示，是所有Type类的基类</em></li><li>kotlin “”” “””    将会把其中的字符串原样输出，也就是说不需要经过转义</li><li>defaultValue = “”””${optional.stringValue}”””” 是我眼拙了，一共要四个也就是最后把一个叫 “string”</li><li><p>对获取的方法进行解析，    </p></li><li><p>ActivityClass 是解析出来的类的模板，持有解析出来的类的信息（代码）</p></li></ul></li><li><p>得到是否抽象的标示，没有相关内部字段支持所以可以使用提供的api获取所有修饰符列表，判断其中是否包含abstract</p></li><li><p>得到是否kotlin代码的标示。由于kapt会对kotlin代码进行解释，出来一份带kotlin注解的代码，所以可以依次进行判断，但是该注解是个接口，只能通过反射获取</p></li><li><p>BuildProcessor</p><ul><li>对Builder修饰的元素进行遍历，首先过滤筛查出class的元素</li><li>判断该元素是否一个activity，是的话将该element放到一个map中，将element与其activityClass关联起来</li><li>对Optional修饰的对象进行遍历，还先筛出Field</li><li>通过enclosingElement得到该feild的外部类，通过它在map中找到activityClass，向其中的field（TreeSet）进行赋值</li><li>同上操作对Required注解的元素进行activityClass的填充</li><li>最后将文件输出</li></ul></li></ul><p><em>type和kind好像都有类型的意思，具体分别代表着什么</em></p><ul><li>写入到文件（将从注解中获得的信息生成真正的.java文件）<ul><li>使用ActivityClasss为信息来源，生成的java文件为ActivityBuilder.java，</li><li>先生成类信息，不对抽象类进行处理，类名，添加修饰符，基本是public，final。最后得到一个TypeSpec，携带着类的信息</li><li>编写一个ConstantBuilder专门生成常量</li><li>对生成的常量进行初始化，javapoet中使用”\$S”，S表示字符串</li><li>使用JavaFile生成文件</li></ul></li><li>在Process中对文件进行生成，使用一个全局的filer</li><li><p>至此可以生成代码Builder类，其中带有常量字段。因此终于得以一窥该注解处理器的主要目的：首先通过对一个activity中的字段注解进行解析，得到字段名对应的静态常量字段，通过这些字段作为tag，进行activity间的intent通信的媒介。为什么专门生成常量来作为tag，因为后边要通过注解处理器，接管这一通信过程，即舍去大量繁琐的putExtra()过程。因此tag的部分当然需要完全的包装起来。</p></li><li><p>通过一个start()方法启动intent的包装和activity的启动。创建一个StartMethod类存放持有所有的具体start方法，ContantBuilder来控制生成start函数</p></li><li>StartMethod 设置一个list存放所有的field。由于Optional的字段多于3个时将使用实例方法创建start()，所以需要有一个static的标志位。</li><li>Field列表的填充，从外部传入。此处使用了运算符的重载。定义对Field的操作方法，对该对象进行复制的方法：使用同样的Field，不同的name</li><li>编写build()方法。使用name创建方法，添加修饰，返回值，参数。参数需要一个TypeName，向ClassType传入包名路径获取，该类是作者编写的工具类。</li><li>方法内语句的编写，需要addStatement()添加声明。使用$T，与$S不同的是，$T可以为我们导包</li><li>通过遍历field列表，进一步增加方法参数，将需要的字段作为参数添加到方法中，并逐条进行putExtra()。前边未对field类型名称进行获取，这里补充一下：asJavaTypeName()    <strong>这里对name和asJavaType有点不明白</strong></li><li>$L 直接把值替换，$S是把值加上引号作为字符串的自变量替换</li><li>对静态方法进行区分。是静态方法，加上static；不是静态，则加上fillIntent(intent)  <strong>????</strong></li><li>最后编写启动activity的代码，需要使用Activity的实例去调用startActivity()。于是在runtime模块定义ActivityBuilder类。此处不定义kotlin类，目的在于使用时可以在app中直接依赖而不需要kotlin库。</li><li>ActivityBuilder使用单例模式，包装startActivity()方法，其实就是当不是Activity的context启动的时候，使用单例启动。所以这里应该可以直接使用startActivity()。这一部分和APT大概关系不大，从其直接被app依赖也可以看出</li><li>开始编写StartMethodBuilder，这个类主要用于控制start方法的生成，因为需要根据Optional注解的个数进行调度。</li><li>编写build()，首先实例化一个StartMethod，使用ActivityClassBuilder中定义的常量作为方法名。</li><li>使用groupBy()根据是否OptionalField进行分类。使用groupBy()后在分为两个list</li><li>先将Required注解的字段添加到startMethod()中，<strong>表示Required标示的的代码都需要进行处理</strong>，即NoOptional不可选的</li><li>这里发现了之前写的一个bug，没注意的地方。就是根据OptionalFeild分类时，始终无法识别出OptionalFeild。经过思考，感觉是对field进行写入时的问题，果然，在BuilderProcessor中对Field写入时，判断为Optional时，就直接写入OptaionalField，而我写的Field。</li><li>这里又明白一点作者的意图，就是生成多个start()方法，让使用者通过@Optional进行标示以后，可以通过选择不同的start去决定是否给Optional声明赋值。当Optional可选的个数不大于3时，可以通过传入目标字段的方式初始化指定字段；大于3时，通过传入Intent的方式，自构造Intent传入，也就是一般的做法。</li><li>这个地方理解有点问题，最终效果应该是，大于3时，生成fillIntent()方法，通过对字段的赋值，使用fillIntent()对字段进行填充。其实大体意义相似，就是实现有点区别。这里需要对是否基本类型进行判断，因为不是基本类型才能使用==Null，基本类型的话就不要判空了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityBuilder <span class="title">title</span><span class="params">(String title)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.title = title;</span><br><span class="line">rerurn <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillIntent</span><span class="params">(Intent intent)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(title == <span class="keyword">null</span>)</span><br><span class="line">intent.putExtra(<span class="string">&quot;title&quot;</span>, title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>关于TypeName不大理解</em><br>一个包装了类型名String的类。ClassName，TypeName的子类。写入方法时，需要用.returns()指明返回值，需要传入TypeName对象。传入包名+类名构造ClassName传入。</li></ul><h2 id="MY"><a href="#MY" class="headerlink" title="MY"></a>MY</h2><ul><li>因为String不是基本类型，所以需要单独领出来识别。</li><li>大写转下划线函数编写。使用了fold()方法辅助，自动为我们遍历集合，我们需要传入一个方法定义对每一个元素的操作</li></ul><h2 id="传说中的kotlin特性？"><a href="#传说中的kotlin特性？" class="headerlink" title="传说中的kotlin特性？"></a>传说中的kotlin特性？</h2><ul><li>AptUtils中的TypeUtils里通过 fun Element.simpleName():String = simpleName.toString()，使得可以在开发中直接用Element调用simpleName()方法</li><li>继承Comparabled接口，实现compareTo()方法，使对象可排序（比较）</li><li>private set 不自动生成setter方法 </li><li>?: 左值为空则调用右侧代码</li><li>kotlin “”” “””    将会把其中的字符串原样输出，也就是说不需要经过转义</li><li>运算符重载，使用特定方法名编写扩展方法，并使用operator修饰</li><li>groupBy() 方法，传入一个函数，根据函数返回的值作为键值分类，返回一个map，键是函数返回的值，对应的值是一个存放相同结果的list，即Map&lt;T, List<R>&gt;</li></ul><h2 id="Kotlin学习"><a href="#Kotlin学习" class="headerlink" title="Kotlin学习"></a>Kotlin学习</h2><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>kotlin的方法参数，可以有默认值，当传参时省略参数时会使用该默认值。<br>调用参数时，可以使用命名参数的方式传入，增强可读性：fun(arg1 = 2, arg2 = 3)<br>当返回类型可以由编译器推断，则可以不需要显式声明返回值。有代码块的方法必须显式声明，除非返回Unit</p><h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>使用vararg修饰，使用数组形式调用。一般置于参数列表最后一个，或者其后的参数使用命名参数传递，或者其后是一个函数类型（lambda）<br>直接使用数据传递，使用伸展操作符，即*数组名</p><h3 id="中缀表示法"><a href="#中缀表示法" class="headerlink" title="中缀表示法"></a>中缀表示法</h3><p>调用方法时，使用object fun arg的形式。该方法必须只有一个参数，不能有默认值，不是可变长数组。且必须指明调用者，即this不再可以省略。</p><h3 id="顶层函数"><a href="#顶层函数" class="headerlink" title="顶层函数"></a>顶层函数</h3><p>在文件顶层声明，即不需要再使用一个类实例调用</p><h3 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h3><p>在函数的内部定义的函数。内部函数可以访问外部函数的变量（闭包）。</p><h3 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h3><p>为一个第三方库编写一个函数，可以使用该库的对象调用。静态解析。</p><h3 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h3><p>对于使用尾递归的函数，kotlin中使用tailrec修饰，编译器会将其优化为循环形式实现的方式。</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>将函数当做参数或返回值的函数，即高阶函数的参数或返回值是一个函数。</p><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>(A, B) -&gt; C，表示了函数签名即参数与返回值。Unit返回类型不可省略。</p><ul><li>(Int)-&gt;((Int)-&gt; Unit) == (Int) -&gt; (Int)-&gt; Unit，因为函数类型支持右结合</li></ul><h3 id="Lambda表达式与匿名函数"><a href="#Lambda表达式与匿名函数" class="headerlink" title="Lambda表达式与匿名函数"></a>Lambda表达式与匿名函数</h3><p>函数字面值。如果函数最后一个参数为函数，则可以将lambda放在参数列表以外。lambda中单个参数可以使用it表示</p><h3 id="泛型-声明处型变-类型投影"><a href="#泛型-声明处型变-类型投影" class="headerlink" title="泛型 声明处型变 类型投影"></a>泛型 声明处型变 类型投影</h3><p>这一部分官方文档讲的极其复杂。当然没能看懂。看到最后其实就是out和in。<strong>跳过了</strong></p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>其实java中也有同样的使用方法只是一直没有注意。一般都是使用类的泛型在方法中调用，但其实可以直接定义泛型方法，<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">singleFun</span><span class="params">(arg: <span class="type">T</span>)</span></span>: T &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">sampleFun</span><span class="params">(arg: <span class="type">T</span>)</span></span>: T &#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="操作符also使用实例"><a href="#操作符also使用实例" class="headerlink" title="操作符also使用实例"></a>操作符also使用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val method = startMethod.copy(field.name)</span><br><span class="line">method.addField(field)</span><br><span class="line">method.build(typeBuilder)</span><br><span class="line"></span><br><span class="line">startMethod.copy(field.name).also &#123;  it.addFeild(feild) &#125;.build(typeBuilder)</span><br></pre></td></tr></table></figure><p>以上代码实现同样的效果，第二种只有一行且不需要创建引用<br>由于medthod需要addFeild()处理，但是该方法返回值为空（或返回对象）使得必须使用这种三段式方式实现。also操作符的意义在于此，it为对象本身且返回最后返回值为该对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startMethod.copy(field.name).staticMethod(<span class="keyword">false</span>).build(typeBuilder)</span><br></pre></td></tr></table></figure><br>而在以上代码中则不需要使用also，因为staticMethod()方法返回对象本身，一直可以直接使用返回值.build()</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这段时间通过对注解管理器的学习，跟着网课简单实现了玉观音注解处理，对注解有更多理解。&lt;br&gt;同时由于该网课是基于kotlin讲解，于是也get了很多kotlin的基本操作之外的炫酷操作&lt;br&gt;因此这篇文章，重在自身的记录理解&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Code" scheme="http://codeminions.github.io/categories/Code/"/>
    
    
    <category term="Android" scheme="http://codeminions.github.io/tags/Android/"/>
    
    <category term="Java" scheme="http://codeminions.github.io/tags/Java/"/>
    
    <category term="秘籍帖" scheme="http://codeminions.github.io/tags/%E7%A7%98%E7%B1%8D%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>View事件分发机制理解</title>
    <link href="http://codeminions.github.io/2019/10/24/View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3/"/>
    <id>http://codeminions.github.io/2019/10/24/View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3/</id>
    <published>2019-10-23T16:00:00.000Z</published>
    <updated>2019-10-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近重新学习了一遍View的事件分发机制。其实之前已经把这一块差不多看过，不好理解，几遍下来，好像都了解了，但总觉得差点意思。<br>发现其实之前看《艺术探索》十分痛苦，主要是看得不够仔细，以及书中概念和知识点较多，没有一个大题的认识，很容易被绕进去。现在水平有些长进了，找了几本书和博客，终于有了更加深刻的理解。<br><a id="more"></a></p><h1 id="事件分发的基本流程"><a href="#事件分发的基本流程" class="headerlink" title="事件分发的基本流程"></a>事件分发的基本流程</h1><p>首先要知道View的触摸事件，主要有ACTION_UP，ACTION_MOVE，ACTION_DOWN。以一个ACTION_DOWN事件开始到一个ACTION_UP事件的一系列事件作为一个事件序列。</p><p>View的事件分发，主要有三个流程，dispatchTouchEvent（分发），onInterceptTouchEvent（拦截），onTouchEvent（消费处理）。<br>Activity，View，ViewGroup处理事件的能力不全相同。<br>其中<strong>Activity和View只有dispatchTouchEvent()和onTouchEvent()</strong>方法，<strong>ViewGroup只有dispatchTouchEvent，onInterceptTouchEvent</strong>方法。</p><p>当一个点击事件产生后，事件传递顺序是：<strong>Activity -&gt; Window -&gt; View</strong>。<br>一个Activity收到一个事件后，触发dispatchTouchEvent()。该方法伪代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(getWindows.superDispatchTouchEvent(ev))</span><br><span class="line">reuturn <span class="keyword">true</span></span><br><span class="line"><span class="keyword">return</span> onTouchEvent(ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先将事件交由Window进行分发。</p><ul><li>如果返回true，则事件循环结束，因为说明点击事件已被处理。</li><li>如果返回false，则触发Activity的onTouchEvent()</li></ul><p>当一个ViewGroup接收到一个事件，则触发dispatchTouchEvent()。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">dispatchTouchEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(onInterceptTouchEvent())</span><br><span class="line"><span class="keyword">return</span> onTouchEvent()</span><br><span class="line"><span class="comment">// 实际上是调用了 super.dispatchTouchEvent()，在其中调用view.onTouchEvent()</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> child.dispatchTouchEvent()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>先根据当前的业务逻辑，调用onInterceptTouchEvent()判断是否拦截该事件<ul><li>onIntercept()返回false，即不拦截，则调用子View的dispatchTouchEvent()，将当前事件传递到子View处理。</li><li>onIntercept()返回true，即为拦截，则调用onTouchEvent()消费该事件。</li></ul></li><li>onTouchEvnet()或child.dispatchTouchEvent()返回false，说明该ViewGroup或子View没有消费该事件，则将该事件传回父容器，<em>即调用父容器的onTouchEvent()方法</em>。<br>如果所有的View都不消费该事件，则Activity的onTouchEvent()会被调用。</li></ul><p>当一个View决定处理某个事件，其处理机制大抵如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">dispatchTouchEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(onTouchListener != <span class="keyword">null</span></span><br><span class="line">&amp;&amp; onTouchListener.onTouch())</span><br><span class="line">result = <span class="keyword">true</span></span><br><span class="line"><span class="keyword">if</span>(!result &amp;&amp; onTouchEvent())</span><br><span class="line">result = <span class="keyword">true</span></span><br><span class="line"><span class="comment">// onTouchEvent()中会调用OnClickListener.onClick()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>先判断onTouchListener是否为空，不为空则调用onTouch()方法，onTouch()返回<strong>false</strong>才会调用onTouchEvent()方法。我们一般设置的OnClickListener.onClick()也是在其中被调用。也就是说onClick()方法一般是在事件传递的末端。</p><h1 id="源码探究"><a href="#源码探究" class="headerlink" title="源码探究"></a>源码探究</h1><h2 id="Activity对事件的分发"><a href="#Activity对事件的分发" class="headerlink" title="Activity对事件的分发"></a>Activity对事件的分发</h2><p>PhoneWindow是Window的唯一实现类。其中的superDispatchTouchEvent()方法实现，直接将事件传递给了DecorView。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码：PhoneWindows#superDispatchTouchEvent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>通过((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChlidAt(1)可以获取Activity所设置的View，这个mDecor显然就是getWindow().getDecorView()返回的View，而我们通过setContentView所设置的View则是他的一个子View。</p></blockquote><p>DecorView继承自FrameLayout，且是一个父View，所以事件最终会传递给顶级View，即是setContentView设置的View。</p><h2 id="ViewGroup对事件的分发"><a href="#ViewGroup对事件的分发" class="headerlink" title="ViewGroup对事件的分发"></a>ViewGroup对事件的分发</h2><p>当一个ViewGroup决定对点击事件进行拦截时，如果onTouchListener被设置，则调用onTouch()，否则调用onTouchEvent()（此过程与上文介绍的View的处理机制相似）。<strong>也就是说，如果都提供的话，onTouch会屏蔽掉onTouchEvnet()</strong>。<br>这个逻辑其实很好理解：onTouchListener是对触摸的监听，即触摸时候触发的回调；只有不对（普通）触摸做处理时，再进一步判断触摸事件，即点击，手势等。这里注意触摸和触摸事件的区别。</p><h3 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check for interception.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">   || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    intercepted = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line"><span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是ViewGroup中关于判断是否拦截事件的部分。</p><blockquote><p>当事件由ViewGroup的子View成功处理，mFirstTouchTarget会被赋值并指向子View</p></blockquote><p>这句话总是似懂非懂，简单翻了翻后边的代码，看到后边dispatchTransformedTouchEvent()中，使用super.dispatchTouchEvnet()，<del>我还以为当子View不处理事件时，会调用父View的dispatchTouchEvent()，此时就可以通过该标示得知该事件是否被处理。如果mFirstTouchTarget未被赋值，则直接intercept为true拦截该事件进行处理。</del><br>这段话写完我就产生了自我怀疑。我是在说个啥？？？<br>仔细又看一遍书后，算是明白了，这个操作其实实现的是：<strong>一个事件序列只能被一个View拦截且消耗。即一个元素拦截了某次事件，那么同一个事件序列内的所有事件都会直接被它处理</strong>。当某个View拦截了down事件，则该事件序列的后续事件都由它处理。</p><blockquote><p>一旦事件由当前ViewGroup拦截，mFirstTouchTarget != null 不成立。那么当UP和MOVE事件到来时，由于(actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)为false，则<strong>onInterceptTouchEvent()不会再被调用</strong>，并且同一序列中的其他事件都默认交由它处理。</p></blockquote><p>这里还有一种特殊情况，即是FLAG_DISALLOW_INTERCEPT。这个标志位是由requestDisallowIntercept()设置，一般用于禁止ViewGroup拦截除DOWN以外的任何事件。</p><ul><li>当分发DOWN事件时，会对该标志位进行重置，使得子View设置的标志位失效。所以面对DOWN事件，ViewGroup都会调用onInterceptTouchEvent()进行判断是否拦截</li></ul><h3 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h3><p>如果当前事件未被拦截，则开始对子View进行分发，即通过一个for循环对所有子View进行遍历。<br>首先判断当前子View是否可以接收到点击事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">|| !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>canViewReceivePointerEvents()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns true if a child view can receive pointer events.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canViewReceivePointerEvents</span><span class="params">(<span class="meta">@NonNull</span> View child)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE</span><br><span class="line">|| child.getAnimation() != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法通过判断child是否VISIBLE或者child是否处于播放动画状态。如果child不可见而且不处于动画状态（不是因为动画才在该位置不可见），那么它不是符合事件消费的条件。这样做的目的在于，即是一个child因为动画如位移而不在原来的位置可见，那也可以收到点击事件。这也解释了为什么位移动画（<strong>View动画</strong>）以后，View还可以在原来的位置接收到点击事件的原因。</p></li><li><p>isTransformedTouchPointInView()<br>判断child是否在点击范围内</p></li></ul><p>如果条件满足，则开始真正对child进行事件传递。主要调用<strong>dispatchTransformedTouchEvent()</strong>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">            View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Canceling motions is a special case.  We don&#x27;t need to perform any transformations</span></span><br><span class="line">        <span class="comment">// or filtering.  The important part is the action, not the contents.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">        <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            event.setAction(oldAction);</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该方法中先判断了child是否为null</p><ul><li>如果为null，则调用super.dispatchTouchEvent()，即View.dispatchTouchEvent()，在其中实现对触摸事件进行处理消费。在ViewGroup中对子View进行分发后，如果事件没有被子View消耗，就会调用这个方法并传入null。</li><li>如果不为null。则调用child.dispatchTouchEvent()将事件进行分发。如果该方法发返回false，则说明child未消耗，将继续进行事件的分发。如果返回true。则说明child已消耗该事件，mFirstTouchEvent被赋值，跳出对子View的遍历分发。<br>如果没有任何子View对事件进行处理，则ViewGroup会如上所说，调用dispatchTransformtouchvnet()并传入null，从ViewGroup转到View.dispatchTouEvent()，自己对事件进行处理。</li></ul><h2 id="View对事件的处理"><a href="#View对事件的处理" class="headerlink" title="View对事件的处理"></a>View对事件的处理</h2><p>当事件被分发到某一个View中，此时View可能是一个底层View，也可能是一个ViewGroup，但都作为一个单独的元素，无法在向下传递事件，必须自己在View.dispatchTouchEvent()中，完成对View触摸事件的响应处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>实现逻辑跟上文体现的差不多，先判断是否设置了OnTouchListener，如果OnTouchListener中的onTouch()返回true，则onTouchEvent()不会被调用。<strong>所以OnTouchListener.onTouch()比onTouchEvent()优先级更高，这样做的好处是方便在外界处理点击事件。</strong>因为onTouch()作为一个外部实现的回调方法，与使用者联系会更为紧密。</p><h3 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent()"></a>onTouchEvent()</h3><p>可以查看一下onTouchEvent()内部实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">setPressed(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">    <span class="comment">// A disabled view that is clickable still consumes the touch</span></span><br><span class="line">    <span class="comment">// events, it just doesn&#x27;t respond to them.</span></span><br><span class="line">    <span class="keyword">return</span> clickable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该方法一开始是实现对不可用（disabled）View的处理，可以看到不可用的View也可以消耗点击事件，只是不会作出响应。<br>并且以上代码还可以看出，无论View是否可用，只要设置了CLICKABLE或LONG_CLICKABLE，onTouchEvent()都会消耗该事件并返回true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">    performClickInternal();</span><br><span class="line">&#125;</span><br><span class="line">    mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上代码是对点击事件具体处理逻辑。没怎么看懂。。=_=（关于TOOLTIP，据说android8新添加的跟鼠标悬浮显示有关）</p><p>只知道核心代码部分即是触发了<strong>performClick()</strong>方法。在perfromClick()中，如果View设置了OnClickListener，则会调用我们一般设置的onClick()（终于，出现了点击事件中与我们接触最为频繁的）！由此也可见，onClick()方法其实是在事件分发机制中处于最最末端的。</p><h1 id="关于滑动冲突解决"><a href="#关于滑动冲突解决" class="headerlink" title="关于滑动冲突解决"></a>关于滑动冲突解决</h1><div class="note default">            <p>未完待续…</p>          </div>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;最近重新学习了一遍View的事件分发机制。其实之前已经把这一块差不多看过，不好理解，几遍下来，好像都了解了，但总觉得差点意思。&lt;br&gt;发现其实之前看《艺术探索》十分痛苦，主要是看得不够仔细，以及书中概念和知识点较多，没有一个大题的认识，很容易被绕进去。现在水平有些长进了，找了几本书和博客，终于有了更加深刻的理解。&lt;br&gt;</summary>
    
    
    
    <category term="Code" scheme="http://codeminions.github.io/categories/Code/"/>
    
    
    <category term="Android" scheme="http://codeminions.github.io/tags/Android/"/>
    
    <category term="技能帖" scheme="http://codeminions.github.io/tags/%E6%8A%80%E8%83%BD%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>来吧设计模式</title>
    <link href="http://codeminions.github.io/2019/10/14/%E6%9D%A5%E5%90%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://codeminions.github.io/2019/10/14/%E6%9D%A5%E5%90%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-10-14T10:47:01.000Z</published>
    <updated>2019-10-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于设计模式"><a href="#关于设计模式" class="headerlink" title="关于设计模式"></a>关于设计模式</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>  写了两年的Java和Android，对于面向对象的思想已然有了自己的一份体会，并在一次次的实践中，加深对这种思想的体会。每一次对代码封装复用，松耦合设计的过程中，都能感受到面向对象思想带来的愉悦，这大概就是其魅力所在。关于设计模式，也不可避免的接触了一些想观察者模式，单例模式，工厂模式等，但对于他们都是只停留在简单的实践阶段，对于其思想并没有太深刻的体会。<br>  在我看来，作为一个Java程序员，面向对象以及设计模式的思想深度，将决定其写出来的代码，是一个精致巧妙的艺术品，还是如书中所说是一团毫无弹性的意大利面。<br>  决定需要好好恶补一下关于设计模式的知识，我选择了《Head First 设计模式》，就目前所翻阅到章节看来，我选对了！<br><a id="more"></a></p><h1 id="来吧设计模式"><a href="#来吧设计模式" class="headerlink" title="来吧设计模式"></a>来吧设计模式</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>  这个模式一直有所耳闻，但一直没有了解。书中没有一开始就点明使用策略模式，最后一刻道破的时候，真的使我有种茅塞顿开的通透感。<br>  原来平时代码中面向接口，继承组合，都是在践行这种设计模式。关于定义，书中给出的描述是：</p><blockquote><p>定义了算法族，分别封装起来，使他们之间可以互相替换，使得算法的变化独立于使用该算法的用户</p></blockquote><p>我的理解是，<strong>将有可能变化的代码抽离出来与稳定不变的代码分开</strong>，成为所谓的算法族（其实就是行为组，对象的所有行为），<strong>使得新的业务逻辑的改变不会影响的旧的代码</strong>。<strong>通过组合的方式，为特定的对象赋予特定的方法组</strong>。<br>  书中使用定义多种类的鸭子作为例子，即将鸭子的行为（不同鸭子行为不同，即为可能变化的部分）抽象出来，成为一个接口，使用该接口实现不同的行为类，这是<strong>封装变化</strong>。然后在鸭子的实际类中，持有一个行为接口的引用，通过setter灵活的对该接口进行实例化，从而达到在运行时，动态的修改增加鸭子行为的效果，这是<strong>使用组合</strong>。<br>关于类的组合，看《Java编程思想》时候就有所了解，当时并不理解为什么说“少用继承，多用组合”，“‘有一个’比‘是一个’更好”，但现在终于有了自己的一点理解。使用继承，意味着可能会出现大量重复的代码，或者局部的修改影响到大部分的代码的情况；而使用组合，可以很容易的知道类的所有算法族，通过setter的方式，灵活修改算法族，并且对于新的算法族的增加，不会影响到已有的代码逻辑。这就是组合优于继承地方。关于组合的缺点，个人觉得可能与增加了类和接口的数量，或者使得类的结构变得复杂有关。</p><blockquote><p>OO设计原则<br>将代码中可能需要变化之处独立出来，不要和那些不需要变化的代码混合在一起。<br>针对接口编程，而不针对实现编程<br>多用组合，少用继承</p></blockquote><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>  这是一个相对来说已经十分熟悉的设计模式，在android中，有许多类似的实现，如button的点击事件设置等，甚至常用的接口回调，我都觉得有点观察者模式的味道。<br>  关于观察者模式，我的理解是，<strong>对象A对对象B的状态感兴趣（关注），于是A对B进行订阅，则B的状态发生变化时，则会对所有订阅的对象进行通知，订阅对象A再根据B的通知作出相应的动作。因此如果B迟迟没有发生变化，则A不会出现相应的反应。</strong><br>  再来看看书中的理解。观察者模式定义是：定义了对象间的一对多的依赖，当一个对象改变状态时，其所有依赖者将收到通知并自动更新。我认为这与我的理解基本一致。<br>  关于观察者模式的实现，书中介绍了两种方式，一种是面向接口式的实现，一种是java.util中内置的Observer实现方式。<br>  提出内置观察者模式的原因，主要为了解决，主题向观察者推送更新时，会把所有的新数据都推送给观察者，或者将一些细微的变化都推送出去，但其实有的观察者只需要其中的某几个数据足矣。因此可以使用观察者拉取的方式，观察者主动向主题拉取数据。<br>  java.util内置的Observer，只通知观察者更新，但观察者需要自己拉取的方式实现。这是我有些困惑，其本质其实相似，主题通过observer.update()方法通知observer更新的消息，并附上对象实例作为参数，让观察者用getter的方式获取部分特定的数据。<br>  重新看过这一章，发现果然有遗漏的地方。其实java.util的观察者模式，支持主题向观察者推送数据，也支持观察者自己向主题拉取数据。Observer.update(Observable, Object)方法，需要将Observable传入以告知观察者是哪一个主题的更新。<strong>如果使用主题推送的方式，则将数据以Object的方式推送给观察者，如果是观察者拉取的方式，则观察者收到通知后，自己通过主题的实例获取更新的数据。</strong>关于细微变化的推送，内置的观察者是在notify之前加了一层判断，判断当前的更新是否需要推送。<br>  有一点需要注意，<strong>不可依赖观察者接收通知的次序</strong>。毕竟主题是通过对订阅列表的遍历进行通知的，所以接收通知的次序不可被过分依赖。<br>  关于java内置的观察者，书中还提到一件事。就是其Observable是需要通过继承实现的并且其中像setChange()方法都是受保护的（protected），因此也不能通过组合的方式实现。这也就违背了“多用组合少用继承”的原则。</p><blockquote><p>因为Observable是一个类，你必须设计一个类继承它。…<strong>毕竟Java不支持多重继承，这限制了Observable的复用潜力。</strong><br>除非你继承自Observable，否则你无法创建Observable实例并组合到你的对象中来。<br>观察者模式作为一种新的模式，以松耦合的方式在一系列对象之间沟通状态。其典型的代表即为之前Android中常用的MVC模式。</p></blockquote><blockquote><p>观察者模式中，主题的状态，观察者的数目和类型都会改变，使用该模式，可以改变依赖主题状态的对象，而不用改变主题。<br>观察者模式使用组合，在运行时将观察者动态的“组合”进主题中。对象间的这种关系不是通过继承产生而是通过运行时的组合实现。<br>观察者利用主题的接口进行订阅，主题通过观察者的接口进行更新的通知。使两者之间运作正常却又松耦合。</p></blockquote><p>  又注意到一个问题，观察者模式的写法，跟回调函数好像有点相似。看了几篇博客，印证了自己的猜想。总结就是，回调模式是观察者模式的特殊实现，不同于一般的一对多的观察者模式，回调模式是一对一的观察者模式。</p><blockquote><p>OO设计原则<br>为了交互对象之间的松耦合设计而努力，即对象之间依然可以正常交互，但是不太清楚彼此的细节。</p></blockquote><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><blockquote><p>我曾以为男子汉应该用继承处理一切。后来我领教到<strong>运行时扩展，远远比编译时期的继承</strong>威力大…</p></blockquote><p>  说到装饰者模式，我依然只是有所耳闻，但始终没有去了解这是一个怎样的模式，只是隐隐觉得它好像和工厂模式或者build有所关联。<br>  这一章节中经常出现的一句话：<strong>类的设计应当对扩展开放，对修改关闭</strong>，即“开放-关闭原则”。大概意思是在需求发生变化或者新增时，应当通过扩展原有类的方式进行更新，而不是通过修改原有类的方式。但说实在，对于这句话我没有在更深层次的体会和理解，大概还是OO检验欠缺的缘故。<br>  使用装饰者模式，大概就是对类的一种扩展实现。<strong>装饰者模式，旨在使用扩展+委托的方式代替继承</strong>。书中的定义是：<strong>动态的将责任附加到对象上，提供了一种比继承更有弹性的的扩展的方案。</strong><br>  基本的实现是：首先要求装饰者与被装饰者属于同一类型（基类），通过不断使用装饰类包装（组合）被装饰类的方式，实现类功能属性的拓展更新。即实现扩展的效果，又不修改原有的类实现。<br>  关于装饰者与被装饰者需要继承同一基类，书中这样解释：</p><blockquote><p>这里利用继承达到“类型匹配”的效果，而不是利用继承获取“行为”。</p></blockquote><p>  为了装饰类可以对被装饰类进行包装去取代，需要它们有相同的类型，而行为的获得，是通过组合实现，所以这里使用继承，并不影响OO的设计原则。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被装饰者（茶）</span></span><br><span class="line">Tea tea = <span class="keyword">new</span> Tea();</span><br><span class="line"><span class="comment">// 装饰者开始装饰</span></span><br><span class="line">Decoration decoration = <span class="keyword">new</span> Milk(tea);</span><br><span class="line">decoration = <span class="keyword">new</span> Sugar(decoration);</span><br><span class="line">decoration = <span class="keyword">new</span> Soy(decoration);</span><br><span class="line">decoration = <span class="keyword">new</span> Coffee(decoration);</span><br></pre></td></tr></table></figure><br>  最简单的装饰者模式实现如上，有点奇怪，好像没有见过这种代码，又好像似曾相识。书中预示道：工厂模式和生成器模式会对装饰者模式有更好的实现方式，这便是我想起了见过生成器模式代码中相似的类的包装。<br>  如果用户需要窥视装饰者链中的每一个装饰者，可以使用一个数据结构如列表等实现方式实现。<br>  关于装饰者模式的经典实现，书中介绍了Java I/O，我立即回想起了当初使用java的文件IO流时，构造流的一系列摸不着头脑的麻烦操作，原来那个过程就是对IO流的一系列装饰以使其获得更多功能如LineNumberInputStream计算行数功能，BufferedInputStream增加缓冲输入改进性能。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>  终于啃完了这一章。工厂方法，也许是听的最早的设计模式，早在学习Java的时候，就了解过通过静态工厂方法初始化对象的操作。因此对其印象一直只是对对象实例化的封装，然而这一章的诸多概念，确看的一头雾水，一翻目录发现这一章的篇幅竟是其他的两倍！我一共读了三遍，才得以稍微理解。<br>  关于工厂模式书中介绍了三个概念，简单工厂，工厂方法模式，抽象工厂模式。</p><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>  简单工厂并不是一种设计模式，只能说是一种变成习惯，即是<strong>将对象初始化的工程封装到一个工厂类中</strong>，由该工厂对该类进行初始化。其中工厂的方法一般设为静态，即是所谓静态工厂方法。<br>  其实说白，就是将一个类的实例化（new过程），放到另一个类（工厂类）的静态方法中，使得类的初始化与客户代码分离。<br>  关于静态工厂，可以实现不创建工厂实例的情况下创建对象。但因为也因为是静态的不能通过继承扩展方法。</p><h3 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>  工厂模式，是将实际创建对象的工厂方法，从工厂类移到需要创建对象的类中，并设为抽象，由该类的子类决定其该创建具体的子类。<br>  所谓让子类决定，使用书中的比萨店的例子说，在PizzaStore中通过工厂方法实例化Pizza对象，并在orderPizza()中使用该对象。其中由于工厂方法是抽象的，所以orderPizza()在使用Pizza对象时，并不能确定该对象的类型，只有PizzaStore子类实现工厂方法时，Pizza的具体对象类型才能确定。其中，PizzaStore类即为Creator，Pizza为Product，PizzaStore的子类为ConcreteCreator，Pizza的子类为ConcreteProduct。<br>  <strong>orderPizza()方法中使用的Pizza类型是抽象的，所以它不清楚Pizza的具体类型，这就是所谓的 解耦</strong>。<br>  工厂方法：定义一个创建对象的接口，但由子类决定要实例化哪一个类。<strong>工厂方法将类的实例化推迟到子类</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂方法的一般形式，让子类处理类的创建，并必须返回一个产品。</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> Product <span class="title">factoryMethod</span><span class="params">(String type)</span></span></span><br></pre></td></tr></table></figure><br><strong>通过工厂方法对象的使用者与对象的具体创建分割开来。</strong></p><blockquote><p>一个工厂方法与其使用者的联合，可以视为一个框架；<br>此外，工厂方法将创建对象的方法封装到每一个创建者中，这样的做法也可视为一个框架。</p></blockquote><ul><li><p><strong>工厂模式与简单工厂的区别</strong><br>每一个ConcreteCreator看起来都有点像一个简单工厂，但其实有很大区别。在工厂模式中，工厂方法扩展自所有Creator共有的基类中的抽象方法，由每一个ConreteCreator负责实现，而简单工厂中的工厂，只是Creator中使用的对象。简单工厂中，将所有的事情放在一个地方全部实现，因此其代码缺乏弹性。<br>而工厂模式中，通过一个框架的形式，让子类去决定如何实现。而简单工厂仅是封装了对象的创建过程，却<strong>无法变更正在创建的产品</strong>。（其实这句话没能完全理解，可能对运行时还是没有很透彻吧）</p></li><li><p>工厂方法不一定要抽象，可以存在一个默认实现的工厂方法，由它实现默认生产的产品。</p></li></ul><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><blockquote><p>要依赖抽象，不要依赖具体类<br>不能让高层组件依赖底层组件，两者都应该依赖抽象<br>  例如在工厂方法模式中，ConcreteProduct类和Creator都依赖于Product抽象类。而一般的OO思想是Creator类依赖于ConcreteProduct，因为ConcreteProduct都在Creator中被实例化，但在工厂模式中就都依赖于抽象的Product，就是依赖倒置。因此工厂模式也是遵循对象倒置的重要手段。</p><ul><li><strong>依赖倒置原则</strong>的建议<ol><li>变量不可以持有具体类的引用（使用工厂方法可以实现这一点</li><li>不要让类派生自具体类（这样会依赖一个具体类</li><li>不要覆盖基类的方法（基类中已经实现的方法，应该被子类共享</li></ol></li></ul></blockquote><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>  创建一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。<strong>允许用户通过一组接口方法来创建一组对象，而不需要关心实际创建的对象的具体类，使得客户与创建的具体对象解耦</strong>。<br>  <strong>抽象工厂的方法经常使用工厂方法实现</strong>，由此也能看出，抽象工厂一般用于实现一组对象，工厂方法一般用于实现一种对象</p><ul><li><strong>抽象工厂与工厂方法的区别</strong><br>工厂方法通过继承创建对象，而抽象工厂使用的是对象的组合。这是说工厂方法创建具体的对象，将该对象实例化进行包装，需要继承扩展一个基类，实现其中的工厂方法。而抽象工厂需要提供一个交代了产品中的对象的生产方法的接口实现类，通过该类实现整个产品家族的创建，以这种方式实现用户与实际产品的解耦。而工厂方法不需要提供一个接口，只需要实现一个工厂方法就好了。<br>其实只要认真研读，书中的思路还是很清晰的，只能怪自己第一遍看的不仔细吧…=_=。</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>  关于单例模式大概是目前我用过的比较清晰地设计模式，因为单例模式其实很好理解，<strong>就是对外隐藏自身的构造方法，只在类的内部初始化一个唯一的实例变量并提供一个外部获取该实例的方法，实现类似全局变量的效果且在代码中只有一个唯一的对象实例</strong>。<br>  当然我也了解到，我一般使用的都还是最为基础的单例实现，关于单例模式还有很多的实现平时很少使用，如懒汉单例，线程安全的单例等。<br>  关于单例模式的使用场景，书中举例有：线程池，缓存，对话框，偏好设置或注册表的对象，日志，设备驱动或网络连接的对象等。<br>  书中的定义为：单件模式确保一个类只有一个实例，并提供一个全全局的访问点。</p><h3 id="懒汉式实现"><a href="#懒汉式实现" class="headerlink" title="懒汉式实现"></a>懒汉式实现</h3><p>  最经典的实现方式，也叫懒汉式实现，实现了一种延迟实例化的效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  该单例通过getInstance()方法获取到Singleton实例，每一次调用时判断实例对象是否为空，为空则初始化。因此，如果在代码中一直没有用到该单例，则该单例对象永远不会被初始化，即所谓的延迟实例化。</p><h3 id="线程安全的懒汉式实现"><a href="#线程安全的懒汉式实现" class="headerlink" title="线程安全的懒汉式实现"></a>线程安全的懒汉式实现</h3><p>  当然这种实现方式在多线程下是不安全的，因为当两个线程同时执行getInstance()中时，同时判断instance为空从而分别创建了对象。<br>  解决方法可以是使getInstance()方法同步，即加上synchronized修饰getInstance()。但这种解决方式的缺陷是，代码会在每次调用getInstance()时，因为同步机制消耗不必要的性能。但其实我们只需要对创建对象的过程进行同步。</p><h3 id="急切实例化的饿汉式实现"><a href="#急切实例化的饿汉式实现" class="headerlink" title="急切实例化的饿汉式实现"></a>急切实例化的饿汉式实现</h3><p>  饿汉式的实现方式，其实就是在类加载的过程中对instance进行实例化。这样实现的好处是，代码中任何时刻使用getInstance()获取单例时，单例都已经被初始化了。</p><blockquote><p>在静态初始化器中创建单件，保证了线程的安全。<br>JVM保证在任何线程访问instance之前一定对其进行初始化。</p></blockquote><h3 id="双重校验锁式实现"><a href="#双重校验锁式实现" class="headerlink" title="双重校验锁式实现"></a>双重校验锁式实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双重校验锁式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现方式，只有在第一次调用时才会进行同步。且进入同步区以后还会对instance进行检查，还是为null时才进行对象的创建。该方式可以大大减少getInstance()时的时间消耗。<br><strong>注：</strong>在Java1.5以前的jvm对volatile的实现会导致双重检查加锁的失效。因此如果对性能没有很大的要求，尽量不要使用该实现方式，因为较为繁琐还需要考虑Java的版本。</p><blockquote><p>是否可以使用类的单件代替对象的单件，即设置一个类和字段都为静态的类？<br>如果该类可以自给自足且初始化过程不是很复杂，可以使用。但是静态初始化的控制权在Java手上，当涉及较多的类时，可能出现由于类的初始化次序导致的问题。</p></blockquote><blockquote><p>因为每一个类加载器都会定义一个命名空间，所以不同的类加载器可能会加载同一个类，使得程序中出现两个单件。解决方式是，自行指定类加载器，并指定同一个类加载器。</p></blockquote><p>饿汉式实现</p><h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><div class="note default">            <p>未完待续…</p>          </div><h1 id="总结设计模式"><a href="#总结设计模式" class="headerlink" title="总结设计模式"></a>总结设计模式</h1><ul><li>愈往下读，愈发感觉<strong>继承，多态，封装</strong>这几个字更加厚重</li><li>书中介绍的<strong>设计原则</strong>，也许比介绍的设计模式更加精辟重要，因为感觉所有的设计模式，隐约都存在着共通点，而这些共通点，就是设计原则！</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;关于设计模式&quot;&gt;&lt;a href=&quot;#关于设计模式&quot; class=&quot;headerlink&quot; title=&quot;关于设计模式&quot;&gt;&lt;/a&gt;关于设计模式&lt;/h1&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;  写了两年的Java和Android，对于面向对象的思想已然有了自己的一份体会，并在一次次的实践中，加深对这种思想的体会。每一次对代码封装复用，松耦合设计的过程中，都能感受到面向对象思想带来的愉悦，这大概就是其魅力所在。关于设计模式，也不可避免的接触了一些想观察者模式，单例模式，工厂模式等，但对于他们都是只停留在简单的实践阶段，对于其思想并没有太深刻的体会。&lt;br&gt;  在我看来，作为一个Java程序员，面向对象以及设计模式的思想深度，将决定其写出来的代码，是一个精致巧妙的艺术品，还是如书中所说是一团毫无弹性的意大利面。&lt;br&gt;  决定需要好好恶补一下关于设计模式的知识，我选择了《Head First 设计模式》，就目前所翻阅到章节看来，我选对了！&lt;br&gt;</summary>
    
    
    
    <category term="Code" scheme="http://codeminions.github.io/categories/Code/"/>
    
    
    <category term="Java" scheme="http://codeminions.github.io/tags/Java/"/>
    
    <category term="秘籍帖" scheme="http://codeminions.github.io/tags/%E7%A7%98%E7%B1%8D%E5%B8%96/"/>
    
    <category term="设计模式" scheme="http://codeminions.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit2学习记录</title>
    <link href="http://codeminions.github.io/2019/07/26/Retrofit%E5%AD%A6%E4%B9%A0/"/>
    <id>http://codeminions.github.io/2019/07/26/Retrofit%E5%AD%A6%E4%B9%A0/</id>
    <published>2019-07-26T04:34:24.000Z</published>
    <updated>2019-10-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Retrofit2"><a href="#Retrofit2" class="headerlink" title="Retrofit2"></a>Retrofit2</h1><p>学习使用Retrofit和RxJava，简单记录一下重要的api和使用方法<br><a id="more"></a><br>需啊添加的依赖如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Retrofit主要类库</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:retrofit:2.0.2&#x27;</span></span><br><span class="line"><span class="comment">// Gson</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:converter-gson:2.0.2&#x27;</span></span><br><span class="line"><span class="comment">// okHttp</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.okhttp3:okhttp:3.10.0&#x27;</span></span><br><span class="line"><span class="comment">// 日志拦截器</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.okhttp3:logging-interceptor:3.9.1&#x27;</span></span><br></pre></td></tr></table></figure><br>Retrofit主要使用注解，标记请求头，请求方式，请求参数，请求格式。主要记一下请求参数和请求格式的注解意义：</p><table><thead><tr><th>注解</th><th>使用</th></tr></thead><tbody><tr><td>@Body</td><td>多用于post请求发送非表单数据,比如想要以post方式传递json格式数据</td></tr><tr><td>@Filed</td><td>多用于post请求中表单字段,Filed和FieldMap需要FormUrlEncoded结合使用</td></tr><tr><td>@FiledMap</td><td>和@Filed作用一致，用于不确定表单参数</td></tr><tr><td>@Part</td><td>用于表单字段,Part和PartMap与Multipart注解结合使用,适合文件上传的情况</td></tr><tr><td>@PartMap</td><td>用于表单字段,默认接受的类型是Map&lt;String,REquestBody&gt;，可用于实现多文件上传</td></tr><tr><td>@Path</td><td>用于url中的占位符</td></tr><tr><td>@Query</td><td>用于Get中指定参数</td></tr><tr><td>@QueryMap</td><td>和Query使用类似</td></tr><tr><td>@Url</td><td>指定请求路径</td></tr></tbody></table><hr><table><thead><tr><th>注解</th><th>使用</th></tr></thead><tbody><tr><td>@FormUrlEncoded</td><td>表示请求发送编码表单数据，每个键值对需要使用@Field注解</td></tr><tr><td>@Multipart</td><td>表示请求发送multipart数据，需要配合使用@Part</td></tr><tr><td>@Streaming</td><td>表示响应用字节流的形式返回.如果没使用该注解,默认会把数据全部载入到内存中.该注解在在下载大文件的特别有用</td></tr></tbody></table><p>使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Headers(&#123;</span></span><br><span class="line"><span class="meta">            &quot;User-Agent: android&quot;,</span></span><br><span class="line"><span class="meta">            &quot;apikey: 28&quot;,</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      设置Url的三种方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@POST()</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">post1</span><span class="params">(<span class="meta">@Url</span> String url, <span class="meta">@QueryMap</span> Map&lt;String, String&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST(&quot;api/en/login&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">post2</span><span class="params">(<span class="meta">@QueryMap</span> Map&lt;String, String&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST(&quot;api/&#123;url&#125;/login&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">post3</span><span class="params">(<span class="meta">@Path(&quot;url&quot;)</span> String url, <span class="meta">@QueryMap</span> Map&lt;String, String&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> getId Query请求参数设置，将会以&quot;?id=getId&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET(&quot;...&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">get</span><span class="params">(<span class="meta">@Header(&quot;token&quot;)</span> String token, <span class="meta">@Query(&quot;id&quot;)</span> <span class="keyword">int</span> getId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用<span class="doctag">@Body</span>注解实现传入实体，自行转化成Json</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@POST(&quot;api/&#123;url&#125;/login&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">login</span><span class="params">(<span class="meta">@Path(&quot;url&quot;)</span> String url, <span class="meta">@Body</span> Entity post)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传图片</span></span><br><span class="line"><span class="comment">     * retrofit 2.0的上传和以前略有不同，使用<span class="doctag">@Multipart</span>注解和<span class="doctag">@Part</span> MultipartBody实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Multipart</span></span><br><span class="line">    <span class="meta">@POST(&quot;&#123;url&#125;&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">upload</span><span class="params">(<span class="meta">@Path(&quot;url&quot;)</span> String url, <span class="meta">@Part</span> MultipartBody.Part file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多张图片上传</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Multipart</span></span><br><span class="line">    <span class="meta">@POST(&quot;upload&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">upload</span><span class="params">(<span class="meta">@PartMap</span> Map&lt;String, MultipartBody.Part&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传图文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Multipart</span></span><br><span class="line">    <span class="meta">@POST(&quot;&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">register</span><span class="params">(<span class="meta">@Body</span> Entity post, <span class="meta">@PartMap</span> Map&lt;String, MultipartBody.Part&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件下载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Streaming</span></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">downloadPicture</span><span class="params">(<span class="meta">@Url</span> String fileUrl)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若要下载大体积的文件，如10m以上，强烈建议使用<span class="doctag">@Streaming</span>进行注解，否则将会出现IO异常.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Streaming</span></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function">Observable&lt;Entity&gt; <span class="title">downloadPicture2</span><span class="params">(<span class="meta">@Url</span> String fileUrl)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST()</span></span><br><span class="line">    <span class="meta">@FormUrlEncoded</span></span><br><span class="line">    <span class="function">Observable&lt;Entity&gt; <span class="title">executePost</span><span class="params">(<span class="meta">@FieldMap</span> Map&lt;String, Object&gt; maps)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注：使用@Path出现url被转义问题<br>设置Url的方法中，如果这样使用,就会出现url被转义，即‘/’被转义为乱码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST(&quot;&#123;url&#125;&quot;)</span></span><br><span class="line"><span class="function">Call&lt;Entity&gt; <span class="title">post</span><span class="params">(<span class="meta">@Path(&quot;url&quot;)</span> String url)</span></span>;</span><br></pre></td></tr></table></figure><br>因此使用这种方式需要这样写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST(&quot;&#123;url&#125;&quot;)</span></span><br><span class="line"><span class="function">Call&lt;Entity&gt; <span class="title">post</span><span class="params">(<span class="meta">@Path(value = &quot;url&quot;, encoded = true)</span> String url)</span></span></span><br></pre></td></tr></table></figure></p><h1 id="使用与配置"><a href="#使用与配置" class="headerlink" title="使用与配置"></a>使用与配置</h1><p>说了这么多，终于开始具体使用。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>首先需要创建一个请求方法接口ApiService，在其中编写需要用到的请求方法接口；<br>在创建一个RetrofitService类用于初始化及启动retrofit。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRetrofitService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyRetrofitService</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">            .connectTimeout(<span class="number">10000L</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">            .readTimeout(<span class="number">10000L</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">&quot;URL&quot;</span>)</span><br><span class="line">            .client(okHttpClient)</span><br><span class="line">            <span class="comment">// 设置json转换器</span></span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>具体调用</strong> 时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ApiService api = MyRetrofitService.retrofit.create(ApiService.class);</span><br><span class="line">Call&lt;ResponseBody&gt; mData = api.get();</span><br><span class="line">mData.enqueue(<span class="keyword">new</span> Callback&lt;ResponseBody&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;ResponseBody&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="关于OkHttpClient更多具体配置"><a href="#关于OkHttpClient更多具体配置" class="headerlink" title="关于OkHttpClient更多具体配置"></a>关于OkHttpClient更多具体配置</h2><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><blockquote><p>addNetworkInterceptor 用于添加网络拦截器Network Interfacetor，它会在request和response时分别被调用一次；<br>addInterceptor 用于添加应用拦截器Application Interceptor，<strong>只会在response被调用一次</strong>。</p></blockquote><h4 id="1-日志拦截器"><a href="#1-日志拦截器" class="headerlink" title="1. 日志拦截器"></a>1. 日志拦截器</h4><p>使用addNetworkInterceptor()添加到OkHttpClient中<br>日志拦截器有两种创建方式:</p><ol><li>使用HttpLoggingInterceptor<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpLoggingInterceptor <span class="title">getHttpLoggingInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HttpLoggingInterceptor loggingInterceptor = <span class="keyword">new</span> HttpLoggingInterceptor(</span><br><span class="line">            <span class="keyword">new</span> HttpLoggingInterceptor.Logger() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;OkHttp&quot;</span>, <span class="string">&quot;log : &quot;</span> + message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</span><br><span class="line">    <span class="keyword">return</span> loggingInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>普通Interceptor<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> okhttp3.<span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">        Log.d(<span class="string">&quot;OkHttp&quot;</span>, <span class="string">&quot;HttpHelper1&quot;</span> + String.format(<span class="string">&quot;Sending request %s on %s%n%s&quot;</span>,</span><br><span class="line">                request.url(), chain.connection(), request.headers()));</span><br><span class="line"></span><br><span class="line">        okhttp3.Response response = chain.proceed(request);</span><br><span class="line">        <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        Log.d(<span class="string">&quot;OkHttp&quot;</span>, <span class="string">&quot;HttpHelper2&quot;</span> + String.format(<span class="string">&quot;Received response for %s in %.1fms%n%s&quot;</span>,</span><br><span class="line">                response.request().url(), (t2 - t1) / <span class="number">1e6d</span>, response.headers()));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-请求头拦截器"><a href="#2-请求头拦截器" class="headerlink" title="2. 请求头拦截器"></a>2. 请求头拦截器</h4>使用addInterceptor()添加到OkHttpClient中<blockquote><p>请求头拦截器为了让服务端能更好的识别该请求，服务器那边通过请求头判断该请求是否为有效请求等…</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用addHeader()不会覆盖之前设置的header,若使用header()则会覆盖之前的header</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Interceptor <span class="title">getRequestHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Interceptor headerInterceptor = <span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> okhttp3.<span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Request originalRequest = chain.request();</span><br><span class="line">            Request.Builder builder = originalRequest.newBuilder();</span><br><span class="line">            builder.addHeader(<span class="string">&quot;version&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">            builder.addHeader(<span class="string">&quot;time&quot;</span>, System.currentTimeMillis() + <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Request.Builder requestBuilder = builder.method(originalRequest.method(), originalRequest.body());</span><br><span class="line">            Request request = requestBuilder.build();</span><br><span class="line">            <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> headerInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-统一请求拦截器"><a href="#3-统一请求拦截器" class="headerlink" title="3. 统一请求拦截器"></a>3. 统一请求拦截器</h4><p>使用addInterceptor()添加到OkHttpClient中<br>统一请求拦截器的功能跟请求头拦截器相类似<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器Interceptors</span></span><br><span class="line"><span class="comment"> * 统一的请求参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Interceptor <span class="title">commonParamsInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Interceptor commonParams = <span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> okhttp3.<span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Request originRequest = chain.request();</span><br><span class="line">            Request request;</span><br><span class="line">            HttpUrl httpUrl = originRequest.url().newBuilder().</span><br><span class="line">                    addQueryParameter(<span class="string">&quot;paltform&quot;</span>, <span class="string">&quot;android&quot;</span>).</span><br><span class="line">                    addQueryParameter(<span class="string">&quot;version&quot;</span>, <span class="string">&quot;1.0.0&quot;</span>).build();</span><br><span class="line">            request = originRequest.newBuilder().url(httpUrl).build();</span><br><span class="line">            <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> commonParams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4-时间拦截器"><a href="#4-时间拦截器" class="headerlink" title="4. 时间拦截器"></a>4. 时间拦截器</h4><p>使用addInterceptor()方法添加到OkHttpClient中<br>从响应中获取服务器返回的时间<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过响应拦截器实现了从响应中获取服务器返回的time</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Interceptor <span class="title">getResponseHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Interceptor interceptor = <span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> okhttp3.<span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            okhttp3.Response response = chain.proceed(chain.request());</span><br><span class="line">            String timestamp = response.header(<span class="string">&quot;time&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (timestamp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取到响应header中的time</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li>使用okhttp缓存，先要创建Cache，然后在创建缓存拦截器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Cache</span></span><br><span class="line">File httpCacheDirectory = <span class="keyword">new</span> File(MyApp.getContext().getCacheDir(), <span class="string">&quot;OkHttpCache&quot;</span>);</span><br><span class="line">Cache cache = <span class="keyword">new</span> Cache(httpCacheDirectory, <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">httpClientBuilder.cache(cache);</span><br><span class="line"><span class="comment">// 设置缓存</span></span><br><span class="line">httpClientBuilder.addNetworkInterceptor(getCacheInterceptor2());</span><br><span class="line">httpClientBuilder.addInterceptor(getCacheInterceptor2());</span><br></pre></td></tr></table></figure></li><li>缓存拦截器<br>缓存时间自己根据情况设定<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在无网络的情况下读取缓存，有网络的情况下根据缓存的过期时间重新请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Interceptor <span class="title">getCacheInterceptor2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Interceptor commonParams = <span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> okhttp3.<span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Request request = chain.request();</span><br><span class="line">            <span class="keyword">if</span> (!NetworkUtils.isConnected()) &#123;</span><br><span class="line">                <span class="comment">//无网络下强制使用缓存，无论缓存是否过期,此时该请求实际上不会被发送出去。</span></span><br><span class="line">                request = request.newBuilder().cacheControl(CacheControl.FORCE_CACHE)</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            okhttp3.Response response = chain.proceed(request);</span><br><span class="line">            <span class="keyword">if</span> (NetworkUtils.isConnected()) &#123;<span class="comment">//有网络情况下，根据请求接口的设置，配置缓存。</span></span><br><span class="line">                <span class="comment">//这样在下次请求时，根据缓存决定是否真正发出请求。</span></span><br><span class="line">                String cacheControl = request.cacheControl().toString();</span><br><span class="line">                <span class="comment">//当然如果你想在有网络的情况下都直接走网络，那么只需要</span></span><br><span class="line">                <span class="comment">//将其超时时间这是为0即可:String cacheControl=&quot;Cache-Control:public,max-age=0&quot;</span></span><br><span class="line">                <span class="keyword">int</span> maxAge = <span class="number">60</span> * <span class="number">60</span>; <span class="comment">// read from cache for 1 minute</span></span><br><span class="line">                <span class="keyword">return</span> response.newBuilder()</span><br><span class="line">                        .header(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;public, max-age=&quot;</span> + maxAge)</span><br><span class="line">                        .removeHeader(<span class="string">&quot;Pragma&quot;</span>)</span><br><span class="line">                        .build();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//无网络</span></span><br><span class="line">                <span class="keyword">int</span> maxStale = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">28</span>; <span class="comment">// tolerate 4-weeks stale</span></span><br><span class="line">                <span class="keyword">return</span> response.newBuilder()</span><br><span class="line">                        .header(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;public,only-if-cached,max-stale=&quot;</span> + maxStale)</span><br><span class="line">                        .removeHeader(<span class="string">&quot;Pragma&quot;</span>)</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> commonParams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义CookieJar"><a href="#自定义CookieJar" class="headerlink" title="自定义CookieJar"></a>自定义CookieJar</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">httpClientBuilder.cookieJar(<span class="keyword">new</span> CookieJar() &#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;HttpUrl, List&lt;Cookie&gt;&gt; cookieStore = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveFromResponse</span><span class="params">(HttpUrl url, List&lt;Cookie&gt; cookies)</span> </span>&#123;</span><br><span class="line">        cookieStore.put(url, cookies);<span class="comment">//保存cookie</span></span><br><span class="line">        <span class="comment">//也可以使用SP保存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Cookie&gt; <span class="title">loadForRequest</span><span class="params">(HttpUrl url)</span> </span>&#123;</span><br><span class="line">        List&lt;Cookie&gt; cookies = cookieStore.get(url);<span class="comment">//取出cookie</span></span><br><span class="line">        <span class="keyword">return</span> cookies != <span class="keyword">null</span> ? cookies : <span class="keyword">new</span> ArrayList&lt;Cookie&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="使用RxJava"><a href="#使用RxJava" class="headerlink" title="使用RxJava"></a>使用RxJava</h1>使用RxJava的目的是，RxJava可以更加简洁的实现异步操作。<h2 id="RxJava的简单理解"><a href="#RxJava的简单理解" class="headerlink" title="RxJava的简单理解"></a>RxJava的简单理解</h2>Rxjava使用观察者模式实现，因此其中有几个基本概念就是Observable被观察者，Observer观察者，subscribe订阅事件。（关于观察者模式最经典的实现就是OnClickListener）Observable与Observer通过subcribe()实现订阅关系，Observable就可以在发生指定事件时通知Observer。<br>不同于传统的观察者模式，Rxjava的回调方法除了onNext()（相当于onClick()），还有onCompleted()和onError()方法。由于Rxjava会将每个事件作为一个事件队列处理，并把每个事件单独处理。以此为前提既可以理解另外两个方法：</li><li>onCompleted() 当事件队列结束，不会有新的onNext()发出时，即会触发onCompleted()方法。</li><li>onError() 当事件队列出现异常是会触发onError()，并且会同时停止事件队列，不允许新的事件发出。</li><li>那么可能会有疑问，异常以后没有事件发出，是否会调用onCompleted()。答案是不会，在一个正常的时间序列中，onCompleted()与onError()方法有且只有一个，二者互斥，即调用其中一个就不会调用另外一个，且都是事件队列中最后一个调用。</li></ul><h2 id="Rxjava的简单实现"><a href="#Rxjava的简单实现" class="headerlink" title="Rxjava的简单实现"></a>Rxjava的简单实现</h2><p>注：一下代码的实现依据rxjava版本为，io.reactivex.rxjava:1.3.8，是一个比较旧的版本了，从这以后rxjava开始2.0版本，有了一些新的改动。但是以此版本理解RxJava的使用思想还是没有问题，而且更加简易更好理解。</p><ol><li><p>创建观察者Observer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">&quot;Item: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">&quot;Completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了Observer接口，RxJava还内置了一个实现了Observer的抽象类：Subscriber。 Subscriber是Observer的扩展，但他们的基本使用方式完全一样（同上）。<br>实质上，在RxJava的subscribe过程中，Observer也总是会先被转换成一个Subscriber再使用。</p><blockquote><p>关于区别<br>onStart(): 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法，具体可以在后面的文中看到。<br>unsubscribe(): 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe()来解除引用关系，以避免内存泄露的发生。</p></blockquote></li><li><p>创建Observable被观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">&quot;Aloha&quot;</span>);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>create()方法中传入了参数<strong>OnSubscribe</strong>对象会被存储在Observable对象中，相当于一个计划表。当Observable被订阅，将回调call()方法，依次触发call中的事件序列。因此例如实际使用中，就可以在call()中进行异步操作，如网络请求，然后将请求的结果通过onNext()的参数发送出去。<br>除了使用create()方法，Rxjava还提供其他方法创建事件队列</p><ul><li>just(T…)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用等同上例</span></span><br><span class="line">Observable observable = Observable.just(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Aloha&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>from(T[]) / from(Iterable&lt;? extends T&gt;)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将传入的数组或可迭代对象拆分成具体对象后，依次发送出来。</span></span><br><span class="line">String[] words = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Aloha&quot;</span>&#125;;</span><br><span class="line">Observable observable = Observable.from(words);</span><br></pre></td></tr></table></figure></li></ul></li><li>实现订阅Subscribe<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br></pre></td></tr></table></figure><blockquote><p>这看起来是『observalbe 订阅了 observer / subscriber』，思维逻辑上虽然有些别扭，但是这有利于流式api的设计<br>Observable.subscribe()内部代码结构如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</span><br><span class="line">    subscriber.onStart();</span><br><span class="line">    onSubscribe.call(subscriber);</span><br><span class="line">    <span class="keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将传入的 Subscriber 作为 Subscription 返回。这是为了方便 unsubscribe().</p></blockquote></li></ol><h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><p>subscriber()支持不完整定义的回调，可以根据定义自动创建Subscriber。使用方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Action1&lt;String&gt; onNextAction = <span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda表达式写法，内容同上</span></span><br><span class="line">Action1&lt;Throwable&gt; onErrorAction = (e) -&gt; System.out.println(<span class="string">&quot;error&quot;</span> + e);</span><br><span class="line"></span><br><span class="line">Action0 onComAction = () -&gt; System.out.println(<span class="string">&quot;com&quot;</span>);</span><br><span class="line"></span><br><span class="line">Observable observable = Observable.just(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Aloha&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动创建Subscriber</span></span><br><span class="line">observable.subscribe(onNextAction);</span><br><span class="line">observable.subscribe(onNextAction, onErrorAction);</span><br><span class="line">observable.subscribe(onNextAction, onErrorAction, onComAction);</span><br></pre></td></tr></table></figure></p><blockquote><p>简单解释一下这段代码中出现的 Action1 和 Action0。<br>Action0 是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；由于 onCompleted() 方法也是无参无返回值的，因此 Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数（onComAction）传入 subscribe() 以实现不完整定义的回调。这样其实也可以看做将 onCompleted() 方法作为参数传进了 subscribe()，相当于其他某些语言中的『闭包』。<br>Action1 也是一个接口，它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；与 Action0 同理，由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj) 和 onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。事实上，虽然 Action0 和 Action1 在 API 中使用最广泛，但 RxJava 是提供了多个 ActionX 形式的接口 (例如 Action2, Action3) 的，它们可以被用以包装不同的无返回值的方法。</p></blockquote><p>简单来说就是一个有参一个无参的包装类，无参的类可以用于构建onCompleted()，有参的可以用于构建onNext()或onError()。subsrcribe()重载了3个关于ActionX的方法，就是上述代码中的3个。比如第三个方法参数表为(Action1&lt;? super T&gt;, Action1<Throwable>, Action0)，以此限定了三个参数的位置。</p><p>接下来用一个例子小结一下：</p><blockquote><p>由 id 取得图片并显示： 由指定的一个 drawable 文件 id drawableRes 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> drawableRes = ...;</span><br><span class="line">ImageView imageView = ...;</span><br><span class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Drawable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        Drawable drawable = getTheme().getDrawable(drawableRes));</span><br><span class="line">        subscriber.onNext(drawable);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Drawable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123;</span><br><span class="line">        imageView.setImageDrawable(drawable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(activity, <span class="string">&quot;Error!&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>以上代码，对上面RxJava的内容进行了小结。可以看到，在Observable的call()方法中进行所要进行的异步操作，然后在subcribe的Observer（Subscriber）中通过onNext，onError，onCompleted设置回调方法。这就是Rxjava的基础使用格式。</p></blockquote><h2 id="异步-线程控制Scheduler"><a href="#异步-线程控制Scheduler" class="headerlink" title="异步-线程控制Scheduler"></a>异步-线程控制Scheduler</h2><p>然而到这里，都和开头所说RxJava的主要作用异步还没有什么关系。因为Rxjava默认是在运行在同一线程。<br>想要实现异步机制，就需要用到RxJava的第四个概念Scheduler。</p><blockquote><p>观察者模式本身的目的就是『后台处理，前台回调』的异步机制<br>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。</p></blockquote><p>RxJava通过Scheduler指定一个代码段需要运行在哪一个进程。</p><ul><li><strong>subscribeOn()</strong> 指定subscribe()发生的进程。即 Observable.OnSubscribe 被激活时所处的线程，事件产生的线程。</li><li><strong>observeOn()</strong> 指定Subscriber所运行的线程。即事件消费进程。</li></ul><p>RxJava中内置了几个进程，以适用一些默认场景：</p><blockquote><ul><li>Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</li><li>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</li><li>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</li><li>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</li><li>Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。</li></ul></blockquote><p>还是使用Android中图片显示的例子</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> drawableRes = ...;</span><br><span class="line">ImageView imageView = ...;</span><br><span class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Drawable&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</span><br><span class="line">       Drawable drawable = getTheme().getDrawable(drawableRes));</span><br><span class="line">       subscriber.onNext(drawable);</span><br><span class="line">       subscriber.onCompleted();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.subscribeOn(Schedulers.io()) <span class="comment">// 指定 subscribe() 发生在 IO 线程</span></span><br><span class="line">.observeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定 Subscriber 的回调发生在主线程</span></span><br><span class="line">.subscribe(<span class="keyword">new</span> Observer&lt;Drawable&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123;</span><br><span class="line">       imageView.setImageDrawable(drawable);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">       Toast.makeText(activity, <span class="string">&quot;Error!&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>即 加载图片将会发生在 IO 线程，而设置图片则被设定在了主线程。这就意味着，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成丝毫界面的卡顿。</p></blockquote><h2 id="Schedule的原理：变换"><a href="#Schedule的原理：变换" class="headerlink" title="Schedule的原理：变换"></a>Schedule的原理：变换</h2><h2 id="先具体实现一下RxJava-Retrofit"><a href="#先具体实现一下RxJava-Retrofit" class="headerlink" title="先具体实现一下RxJava+Retrofit"></a>先具体实现一下RxJava+Retrofit</h2><p><a href="https://www.jianshu.com/p/73216939806a">Retrofit参考链接</a><br><a href="http://gank.io/post/560e15be2dca930e00da1083">RxJava参考链接</a></p><hr><div class="note default">            <p>未完待续…</p>          </div>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Retrofit2&quot;&gt;&lt;a href=&quot;#Retrofit2&quot; class=&quot;headerlink&quot; title=&quot;Retrofit2&quot;&gt;&lt;/a&gt;Retrofit2&lt;/h1&gt;&lt;p&gt;学习使用Retrofit和RxJava，简单记录一下重要的api和使用方法&lt;br&gt;</summary>
    
    
    
    <category term="Code" scheme="http://codeminions.github.io/categories/Code/"/>
    
    
    <category term="Android" scheme="http://codeminions.github.io/tags/Android/"/>
    
    <category term="秘籍帖" scheme="http://codeminions.github.io/tags/%E7%A7%98%E7%B1%8D%E5%B8%96/"/>
    
    <category term="Rxjava" scheme="http://codeminions.github.io/tags/Rxjava/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM</title>
    <link href="http://codeminions.github.io/2019/07/17/JVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://codeminions.github.io/2019/07/17/JVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2019-07-16T16:00:00.000Z</published>
    <updated>2019-07-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK JRE JVM"></a>JDK JRE JVM</h1><p><img src="/2019/07/17/JVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/JDKandJRE.png" alt="JDK JRE JVM关系图"></p><a id="more"></a><p>先简单过一遍历史，这算是常识。<br>1991.4 Oak语言：java前身，目标：电子产品上的程序架构<br>1996.1 JDK1.0发布。纯解释执行的Jvm实现<br>1997.2 发布JDK1.1。JDBC，内部类，反射等出现<br>1998.12 JDK1.2发布。拆分三个体系：J2SE（桌面开发），J2EE（企业级开发），J2ME（面向移动端）。集合类等出现。首次内置JIT编译器<br>1999.4 HotSpot虚拟机发布。JDK1.3以后成为Sun JDK的默认虚拟机<br>2002.2 JDK1.4发布。引入异常类，正则，NIO等<br>2004.9 JDK1.5发布，引入泛型，动态注解，枚举，可变长参数，foreach等。最后一个支持Win9x的Java版本<br>2006.12 JDK1.6发布。J2EE等更名。JVM内部机制较大修改。同年Java大会Sun宣布Java开源，OpenJDK建立<br>2009.4 Oracle收购Sun公司</p><p>Dalvik VM Google实现的android核心组成部分。<br><a href="https://juejin.im/post/59b7fa8cf265da066d3323bb">DalvikVM与JVM的区别</a></p><h2 id="对象头-18-11"><a href="#对象头-18-11" class="headerlink" title="对象头(18-11)"></a>对象头(18-11)</h2><p>对象在内存中的存储布局分为 对象头，实例数据，对齐填充。<br>对象头包括 对象自身运行时数据（Mark World 64Bits），类型指针。对象指向其类的元数据的指针（用于确定该对象是哪个类的实例）。<br>锁标志位，也保存在对象头中。锁标志位与是否偏向锁 对应到唯一的锁状态</p><div class="note default">            <p>未完待续…</p>          </div>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JDK-JRE-JVM&quot;&gt;&lt;a href=&quot;#JDK-JRE-JVM&quot; class=&quot;headerlink&quot; title=&quot;JDK JRE JVM&quot;&gt;&lt;/a&gt;JDK JRE JVM&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/07/17/JVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/JDKandJRE.png&quot; alt=&quot;JDK JRE JVM关系图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Code" scheme="http://codeminions.github.io/categories/Code/"/>
    
    
    <category term="Java" scheme="http://codeminions.github.io/tags/Java/"/>
    
    <category term="秘籍帖" scheme="http://codeminions.github.io/tags/%E7%A7%98%E7%B1%8D%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>Idea报错：限制口令文件读取访问权限</title>
    <link href="http://codeminions.github.io/2019/07/07/%E5%85%B3%E9%97%ADJVM%E5%AE%89%E5%85%A8%E8%BF%9E%E6%8E%A5/"/>
    <id>http://codeminions.github.io/2019/07/07/%E5%85%B3%E9%97%ADJVM%E5%AE%89%E5%85%A8%E8%BF%9E%E6%8E%A5/</id>
    <published>2019-07-06T16:00:00.000Z</published>
    <updated>2019-07-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>此先说明，我的操作系统环境是deepin-15.10.2。Tomcat版本是9.0.13<br>某天将JetBrains-Idea从182更新到191后（是了一百年没更新了），正常启动tomcat跑程序时候，突然刷的一下报错</p><blockquote><p><strong>错误: 必须限制口令文件读取访问权限: …/.IntelliJIdea/system/tomcat/Test/jmxremote.password </strong></p></blockquote><p>（心急的旁友直接看下边方案吧，不着急可以看看我的解决过程噢..）</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p><strong>在TomcatHome/bin/catalina.sh文件中添加以下参数，位置大概在原文注释以后，所有代码以前</strong></p><blockquote><p>JAVA_OPTS=”$JAVA_OPTS -Dcom.ibm.team.jfs.app.oauth.OAuthHelper.disableSecureCookies=true”<br>JAVA_OPTS=”$JAVA_OPTS -Dcom.sun.management.jmxremote.authenticate=false”<br>JAVA_OPTS=”$JAVA_OPTS -Dcom.sun.management.jmxremote.ssl=false”</p></blockquote><a id="more"></a><h1 id="填坑过程"><a href="#填坑过程" class="headerlink" title="填坑过程"></a>填坑过程</h1><p>（开始讲故事…）<br>一开始我是一脸懵逼啊，从来没见过这样的问题，遂Google。原来是因为 <strong>jmxremote.password 文件中存储了明文密码，所以此文件必须只能由所有者读取，否则程序将关闭并报错</strong> 。<br>虽然不知道细节但是既然如此chmod走一波…并未生效？？重复几次，仍如此。<br>在linux中摸爬滚打多（== 2）年的我预感到了，这大概又是一个大坑。果不其然，Google得知， <strong>linux无法修改其他磁盘分区的文件，chmod只能在linux分区下生效，否则权限改不了,因为FAT或NTFS文件系统中根本没有linux中的这些文件权限的概念</strong> 。 <a href="http://www.voidcn.com/article/p-aoxdvfon-tc.html">出处在此</a><br>但是搜索原来问题给出的解决方法都是修改文件权限，Windows下直接修改或者linux下chmod操作，并不能为我所用。于是灰溜溜的滚回去用182版本。<br>三个月后也就是今天，刚重装了Deepin又解决了一堆坑的我决定（顺便）直面这个问题。这次我决定从两个版本为什么会不一样看起。对比了下前面目录下各个工程的文件，发现只有新版本的文件下会有jmxremote.password和jmxremote.access。这其实是tomcat使用JMX安全连接所需的安全认证证书密码。JMX使用SSL认证启动后，即可以使用https访问tomcat服务器了。<a href="https://www.ibm.com/support/knowledgecenter/zh/SSYMRC_6.0.1/com.ibm.jazz.repository.web.admin.doc/topics/t_server_mon_tomcat_option3.html">配置方法</a></p><blockquote><p>自Java 6开始，Java程序启动时都会在JVM内部启动一个JMX agent，JMX agent会启动一个MBean server组件，把MBeans（Java平台标准的MBean + 你自己创建的MBean）注册到它里面，然后暴露给JMX client管理。简单来说就是每个Java程序都可以通过JMX来被JMX client管理，而且这一切都是自动发生的。而VisualVm就是一个JMX Client。<br>VisualVm能够自动发现本机的Java进程，如果要监控远程主机上的Java进程则需要显式地配置JMX连接。</p></blockquote><p>附： <a href="https://chanjarster.github.io/post/visualvm-remote-monitoring-jmx/">JMX监听Java程序</a>/<a href="https://www.ibm.com/support/knowledgecenter/zh/SSHS8R_8.0.0/com.ibm.worklight.installconfig.doc/install_config/t_optional_config_app_server_tomcat.html">tomcat配置JMX连接</a>的配置方法</p><p>我认为,也就是说程序默认开启安全性设置，所以需要用到证书和密码，那如果我不需要安全连接，是不是可以关闭安全性设置，能像以前一样不需要证书密码，那么密码文件的权限也就无所意义了呢。<br>那么问题来了，如何关闭安全连接呢。我猜测大概是修改Java的运行时参数。问题又来了，直接在Idea中添加运行时参数吗？感觉有点蠢。。<br>我又想起tomcat启动时一般是调用的启动文件启动，也许就是在那里新增了对安全性设置的修改。<br>打开TomcatHome/bin/，找到startup.sh（startup.bat是Windows用的启动文件，其实Windows下是执行bin/tomcat.exe，直接读取的注册表的值），打开一看好像比较简单，没有类似运行时参数的配置格式。后来发现tomcat启动时主要调用的文件是Catalina.sh文件，是它了。（一开始是听到直接在cetenv.sh文件上添加参数，没有该文件的自己新建即可，新建完运行发现自动读取该文件了，但是参数都是not found不知道怎么回事..）<br>又翻了好久关于在启动文件中添加参数的格式，因为源文件中都是以脚本语言的形式添加的。</p><p>细化问题后，终于找到了解决方案。<br><a href="https://www.ibm.com/support/knowledgecenter/zh/SSYMRC_6.0.1/com.ibm.jazz.repository.web.admin.doc/topics/t_server_mon_tomcat_option1.html">不使用安全认证在Tomcat上激活JMX</a><br><a href="https://www.ibm.com/support/knowledgecenter/zh/SSYMRC_6.0.0/com.ibm.jazz.install.doc/topics/t_disable_server_certificates.html">禁用安全证书设置</a></p><p>于是添加以下参数到catalina.sh中，位置大概在原文注释以后，代码开始的地方吧(我觉得大概是无所谓的)..</p><blockquote><p><strong>JAVA_OPTS=”$JAVA_OPTS -Dcom.ibm.team.jfs.app.oauth.OAuthHelper.disableSecureCookies=true”</strong><br><strong>JAVA_OPTS=”$JAVA_OPTS -Dcom.sun.management.jmxremote.authenticate=false”    // 关闭身份验证</strong><br><strong>JAVA_OPTS=”$JAVA_OPTS -Dcom.sun.management.jmxremote.ssl=false”     // 关闭ssl连接</strong></p></blockquote><p>加完运行，居然成功了</p><h1 id="开始叭叭"><a href="#开始叭叭" class="headerlink" title="开始叭叭"></a>开始叭叭</h1><p>感动之余，发现即使不修改catalina.sh，在182版本中这些参数也会在运行日志中打印出来，说明182中这是默认的设置，但是191中就炸了。<br>因此我猜测，大概是191新版本中将安全连接设为了必须。但询问发现周围小伙伴都没有见过相关的问题（有我也不用困扰这么久了），但也许是因为他们使用的Windows所以密码文件的读取权限没有问题所以没有发现这个更新呢？<br>算了，至少问题总算解决（至少目前看来是这样的），写了三个月的后端，我都差点忘了自己其实是个android程序员了。。（虽说程序员不该界定自己的技术栈吧，，）</p><h1 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h1><p>由于该问题研究过程中，关联到太多的细节和底层问题，所以文中有些部分是自己结合技术文章的见解，有可能不是正解（这些部分我都有写明）而且最后方案不一定是准确解决了症结，但它确确实实解决了我的问题来的。写这篇文章的目的主要为了记录这次填坑之旅所遇到及了解到的知识，因此有其他意见希望向我提出交流。</p><p>博客的留言功能还没有折腾，欢迎发我[邮箱 <a href="mailto:xiaohuangren028@gmail.com">xiaohuangren028@gmail.com</a>]啊。</p><hr><p>关于修改密码文件的权限，后来我又找到<a href="https://www.cnblogs.com/Dhouse/p/7827175.html">这篇博客</a>，其中提到权限修改失败还有可能是因为方式错误。</p><blockquote><p>在配置JMX远程访问的时候，设置jmxremote.password文件权限，修改该文件时添加写权限，chmod +w jmxremote.password ，放开角色信息那俩行的注释，保存，再使用chmod 0400 jmxremote.password<br>这样就是它正确的权限设置<br>jmxremote.password 在jdk/jre/lib/management/下，jmxremote.password.template复制，去掉.template后缀</p></blockquote><p>如果不是因为挂载原因无法修改权限的，可以尝试以上方法。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h1&gt;&lt;p&gt;此先说明，我的操作系统环境是deepin-15.10.2。Tomcat版本是9.0.13&lt;br&gt;某天将JetBrains-Idea从182更新到191后（是了一百年没更新了），正常启动tomcat跑程序时候，突然刷的一下报错&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;错误: 必须限制口令文件读取访问权限: …/.IntelliJIdea/system/tomcat/Test/jmxremote.password &lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（心急的旁友直接看下边方案吧，不着急可以看看我的解决过程噢..）&lt;/p&gt;
&lt;h1 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;在TomcatHome/bin/catalina.sh文件中添加以下参数，位置大概在原文注释以后，所有代码以前&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JAVA_OPTS=”$JAVA_OPTS -Dcom.ibm.team.jfs.app.oauth.OAuthHelper.disableSecureCookies=true”&lt;br&gt;JAVA_OPTS=”$JAVA_OPTS -Dcom.sun.management.jmxremote.authenticate=false”&lt;br&gt;JAVA_OPTS=”$JAVA_OPTS -Dcom.sun.management.jmxremote.ssl=false”&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Code" scheme="http://codeminions.github.io/categories/Code/"/>
    
    
    <category term="Java" scheme="http://codeminions.github.io/tags/Java/"/>
    
    <category term="技能帖" scheme="http://codeminions.github.io/tags/%E6%8A%80%E8%83%BD%E5%B8%96/"/>
    
    <category term="IDE" scheme="http://codeminions.github.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>Deepin又一次折腾记录</title>
    <link href="http://codeminions.github.io/2019/07/05/deepin%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    <id>http://codeminions.github.io/2019/07/05/deepin%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</id>
    <published>2019-07-04T16:00:00.000Z</published>
    <updated>2019-07-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Deepin-15-10-2-stable"><a href="#Deepin-15-10-2-stable" class="headerlink" title="Deepin 15.10.2 stable"></a>Deepin 15.10.2 stable</h2><p>最近又重装了一遍Deepin，全新安装最新版本Deepin15.10.1，然后更到15.10.2（赶上这几天Deepin更新了）。此次安装折腾了两天，解决了很多之前的问题，当然，也出现很多之前没有出现过的问题（流泪）。<br>得到了很多经验体会，特此记录<br>（这几天不断地强制关机，感觉我的机械硬盘命不久矣噢…TAT）<br><a id="more"></a></p><h2 id="安全模式安装系统"><a href="#安全模式安装系统" class="headerlink" title="安全模式安装系统"></a>安全模式安装系统</h2><p>首先是全新安装，日常出现卡在DeepinLogo处死机的现象。重新开机（没错就是先强制重启），选择install faillsafe，进入安全模式。（这里有时候也会进不去，多试两次就进去了）。<br>（这里出现过一个很有意思的问题：安全模式下长时间不操作，系统待机，唤醒后是用户登录页，需要输入密码，我都没有设置用户和密码怎么登录？？蒙了好几个所谓初始密码后，放弃，强制重启）<br>安全模式中，我是先安装了intel-microcode，因为在开机日志里会看到update microcode to version 0x52</p><blockquote><p>sudo apt-get install intel-microcode</p></blockquote><p>注：使用其他源（如上交大源）可能会无法定位该包，建议先切回官方源。<br>然后更新独显驱动，因为15.5版本的时候，一更新系统内核就会崩，即卡在logo无法进入系统，直到更新了显卡驱动，后才能正常时候新内核</p><blockquote><p>sudo apt-get install nvidia-driver    // 其实是安装了一个闭源的显卡驱动</p></blockquote><p>然后点击桌面的安装程序开始安装。<br>安装成功后即可进入系统。注意重新安装一下intel-microcode，和显卡驱动，因为安全模式的安装的软件，到正常系统就没有了（安全模式大概就类似windows下的PE系统吧）。</p><h2 id="更新软件列表及更换镜像源"><a href="#更新软件列表及更换镜像源" class="headerlink" title="更新软件列表及更换镜像源"></a>更新软件列表及更换镜像源</h2><p>接着更新软件列表</p><blockquote><p>sudo apt-get update</p></blockquote><p>注意，在此之前可以先更换一下软件源，因为官方源一般会比较慢。据说在广东及河南等地，上交大的镜像源会比较快。另外华为云在社区口碑也不错。更换方式如下，进入/etc/apt/source.list直接添加(1)或命令行添加(2)：</p><blockquote><ol><li>deb [by-hash=force] <a href="http://ftp.sjtu.edu.cn/deepin">http://ftp.sjtu.edu.cn/deepin</a> panda main contrib non-free</li><li>sudo sed -i “s@<a href="http://packages.deepin.com/deepin@https://mirrors.huaweicloud.com/deepin@g&quot;">http://packages.deepin.com/deepin@https://mirrors.huaweicloud.com/deepin@g&quot;</a> /etc/apt/sources.list</li></ol></blockquote><p>该命令会顺带更新系统。</p><h2 id="独显问题开始作妖"><a href="#独显问题开始作妖" class="headerlink" title="独显问题开始作妖"></a>独显问题开始作妖</h2><p>升级完系统后，又出现问题了。<br>我的dde桌面突然退到2D模式，即关闭了桌面动画，而且系统软件打开后都会出现厚厚的黑框框。经查确实是处于2D模式且无法切换为3D模式。我就感觉，必然又是显卡出了问题。折腾大半天，切换为大黄蜂显卡驱动方案可以解决问题。<br>切换方式可以通过</p><blockquote><p>sudo apt-get install bumblebee-nvidia nvidia-driver nvidia-settings</p></blockquote><p>安装大黄蜂驱动，也可以直接在系统软件“显卡驱动管理器”中自动安装切换。具体方式如下：<br><a href="https://wiki.deepin.org/index.php?title=Deepin%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0NVIDIA%E9%A9%B1%E5%8A%A8&amp;language=en">安装大黄蜂显卡驱动</a><br>其实一开始切换是有点慌的，因为在社区见过有旁友装了大黄蜂以后无法进入系统。</p><h2 id="待机后无法唤醒"><a href="#待机后无法唤醒" class="headerlink" title="待机后无法唤醒"></a>待机后无法唤醒</h2><p>然而后来确实出现问题了。我发现待机时间过长，显示屏关闭后，无法唤醒显示屏。虽然可以听到系统确实已经启动，可以听到wifi连接的提示音，但是显示屏就是不亮。<br>这个在社区已经臭名昭著的待机后无法唤醒的问题，今天终于被我遇上了。。TAT<br>在社区看了很多帖子，都说没有可以真正解决的方式，无非强制计算机不待机（？？）。期间我也试过切换回开源驱动，即默认的驱动，但是没有效果，于是最后只得切回大黄蜂（听说该驱动省电），然后…强制不待机…<br>感觉很多问题挖到后边都能和独显扯上关系啊…</p><h2 id="pcspkr问题？？"><a href="#pcspkr问题？？" class="headerlink" title="pcspkr问题？？"></a>pcspkr问题？？</h2><p>这一次更新系统后，还出现一个新的现象，出现系统Logo后，一般就进入用户登录界面了，但现在在Logo页还会打印log，其中是一条报错信息</p><blockquote><p>Error: Driver ‘pcspkr’ is already registered, aborting…</p></blockquote><p>甚至在前几次开机时，出现该log后，是有一定几率进不去系统的。。貌似upate以后就可以稳定进入了但是每次到那个地方还是会有停顿的样子。每次都会提一口气担心系统又这样挂掉了。<br>查了一下，这是一个跟蜂鸣器相关的内核模块，想想确实Deepin在那个时间会调蜂鸣器发出进入系统的提示音。找了一圈找到的解决方式是</p><ol><li><blockquote><p>aptitude install alsa-base<br>echo blacklist snd-pcsp &gt;&gt; /etc/modprobe.d/alsa-base-blacklist</p></blockquote></li><li><p>据说该方法原理是屏蔽该模块</p><blockquote><p>echo -e “# Used for shielding pcspkr module, this module seems to be related to buzzer.\nblacklist pcspkr” | sudo tee /etc/modprobe.d/blacklist-pcspkr.conf</p></blockquote></li></ol><p>由于我虽然出现这个问题，但是后来都不影响启动，所以我也没折腾这个问题。但据社区的帖子所说，这两个方法貌似都没能根治该问题…</p><hr><h2 id="臭名昭著的Logo死机问题"><a href="#臭名昭著的Logo死机问题" class="headerlink" title="臭名昭著的Logo死机问题"></a>臭名昭著的Logo死机问题</h2><p>关于开机时卡在logo处的问题，另找到一个解决方案：<br>开机后在grub引导时，选择deepin系统，先不要按Enter，按e键进入编辑模式</p><blockquote><p>在菜单中的代码中，找到倒数第二行，会出现如下所示的代码：<br>linux /vmlinuz-4.15.0-29deepin-generic root=UUID=b66d8ffa-aed9-466c-bc12-6bb801e45901 ro splash quiet<br>表示加载的linux内核文件，后面是内核的参数，各项含义为<br>root告诉内核根分区的设备<br>ro表示在设备启动时为read-only，如果是rw表示read-write<br>splash表示开机动画<br>quiet表示在启动过程中只有重要信息显示，类似硬件自检的消息不会显示quiet表示在启动过程中只有重要信息显示，类似硬件自检的消息不会显示<br>single以单用户模式登录，一般用于修改系统，比如deepin密码忘记了等等。single以单用户模式登录，一般用于修改系统，比如deepin密码忘记了等等。<br><strong>在quiet的后面空一格加上如下所示的代码：acpi_osi=! acpi=”windows 2009”，按F10保存即可。这时会重新开始登录deepin系统，耐心等待进入桌面。</strong></p></blockquote><p>但是以上操作只能成功进入系统一次，大概因为以上对grub的设置其实写到一个临时文件中，所以不能对以后的进入奏效。<br>所以需要对grub的设置文件进行修改，永久性解决该问题。进入系统以后，执行</p><blockquote><p>sudo gedit /boot/grub/grub.cfg</p></blockquote><p>打开配置文件。如果系统没有gedit可以使用vim或nano打开，仍在原来的位置加上，<strong>acpi_osi=! acpi=”windows 2009”</strong>。<br>据说这种操作的原理是：旧版的BIOS无法打识别一些新版的linux内核，所以添加该语句让系统“误以为”是Windows系统。<br><a href="https://blog.csdn.net/HuaCode/article/details/83216338">参考原文</a></p><hr><h2 id="备注：系统的显卡驱动管理器中原本有一个NV-PRIME方案，用于混合显卡的驱动。但15-10-2stable版本中官方禁用了prime方案（暂时）。"><a href="#备注：系统的显卡驱动管理器中原本有一个NV-PRIME方案，用于混合显卡的驱动。但15-10-2stable版本中官方禁用了prime方案（暂时）。" class="headerlink" title="备注：系统的显卡驱动管理器中原本有一个NV-PRIME方案，用于混合显卡的驱动。但15.10.2stable版本中官方禁用了prime方案（暂时）。"></a>备注：系统的显卡驱动管理器中原本有一个NV-PRIME方案，用于混合显卡的驱动。但15.10.2stable版本中官方禁用了prime方案（暂时）。</h2><p><strong>如果对上述问题有较好的解决方式或看法，欢迎交流[邮箱 <a href="mailto:xiaohuangren028@gmail.com">xiaohuangren028@gmail.com</a>]</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Deepin-15-10-2-stable&quot;&gt;&lt;a href=&quot;#Deepin-15-10-2-stable&quot; class=&quot;headerlink&quot; title=&quot;Deepin 15.10.2 stable&quot;&gt;&lt;/a&gt;Deepin 15.10.2 stable&lt;/h2&gt;&lt;p&gt;最近又重装了一遍Deepin，全新安装最新版本Deepin15.10.1，然后更到15.10.2（赶上这几天Deepin更新了）。此次安装折腾了两天，解决了很多之前的问题，当然，也出现很多之前没有出现过的问题（流泪）。&lt;br&gt;得到了很多经验体会，特此记录&lt;br&gt;（这几天不断地强制关机，感觉我的机械硬盘命不久矣噢…TAT）&lt;br&gt;</summary>
    
    
    
    <category term="OS" scheme="http://codeminions.github.io/categories/OS/"/>
    
    
    <category term="技能帖" scheme="http://codeminions.github.io/tags/%E6%8A%80%E8%83%BD%E5%B8%96/"/>
    
    <category term="Deepin" scheme="http://codeminions.github.io/tags/Deepin/"/>
    
  </entry>
  
  <entry>
    <title>View事件体系之滑动学习心得</title>
    <link href="http://codeminions.github.io/2019/04/30/View%E6%BB%91%E5%8A%A8%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    <id>http://codeminions.github.io/2019/04/30/View%E6%BB%91%E5%8A%A8%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</id>
    <published>2019-04-29T16:00:00.000Z</published>
    <updated>2019-10-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最近学习《Android开发艺术探索》的View事件体系，对View有了跟多的理解和心得体会，遂记录，加深理解也便同人交流。"><a href="#最近学习《Android开发艺术探索》的View事件体系，对View有了跟多的理解和心得体会，遂记录，加深理解也便同人交流。" class="headerlink" title="最近学习《Android开发艺术探索》的View事件体系，对View有了跟多的理解和心得体会，遂记录，加深理解也便同人交流。"></a>最近学习《Android开发艺术探索》的View事件体系，对View有了跟多的理解和心得体会，遂记录，加深理解也便同人交流。</h2><p>View一般有三种实现方式，<strong>ScrollTo/ScrollBy实现</strong>，<strong>动画实现</strong>，<strong>改变布局参数实现</strong>。注意其中除了动画以外，其余两种都是非弹性的滑动，即是“瞬移”。</p><h2 id="ScrollTo-ScrollBy实现"><a href="#ScrollTo-ScrollBy实现" class="headerlink" title="ScrollTo/ScrollBy实现"></a>ScrollTo/ScrollBy实现</h2><p>这是View内部的两个方法，主要区别就是绝对滑动和相对滑动。即</p><blockquote><p>ScrollTo()，基于所传递参数的绝对滑动<br>ScrollBy()，基于当前位置的相对滑动  </p></blockquote><a id="more"></a><p>这是书中的原话，但是我一开始却没有理解对“绝对滑动”。所谓相对滑动指的是相对于当前位置的滑动，所谓绝对滑动指的是content在View中的绝对位置，而非我一开始理解的相对于屏幕的绝对位置。关于这一点不理解的话，后边会有一个小例（keng）子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the scrolled position of your view. This will cause a call to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</span></span><br><span class="line"><span class="comment"> * invalidated.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the x position to scroll to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y the y position to scroll to</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldX = mScrollX;</span><br><span class="line">        <span class="keyword">int</span> oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        invalidateParentCaches();</span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">            postInvalidateOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Move the scrolled position of your view. This will cause a call to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</span></span><br><span class="line"><span class="comment"> * invalidated.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the amount of pixels to scroll by horizontally</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y the amount of pixels to scroll by vertically</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由源码很明显看出，ScrollBy()就是直接调用了ScrollTo()，ScrollTo()中就只是记录了一下当前滑动的坐标然后对View进行了<strong>重绘</strong>（postInvalidateOnAnimation中触发重绘）。且在重绘之前还会调用 <strong>onScrollChanged()</strong> 方法。<br>关于其中mScrollX，和mScrollY属性，直接画了一个示意图方便理解。<br><img src="/2019/04/30/View%E6%BB%91%E5%8A%A8%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/Scroller.jpg" alt="Content-View"></p><p>关于ScrollTo方法十分需要注意的一点：<br><strong>ScrollTo()方法只能对View中的Content进行操作移动而不能移动View的位置</strong><br>View中的Content，例如TextView的Content即为文本，ImageView的Content即为Drawable。</p><h2 id="动画实现"><a href="#动画实现" class="headerlink" title="动画实现"></a>动画实现</h2><p>这种实现在效果上较于其他两种有所不同，动画可以通过设置移动时间实现弹性滑动的效果。动画在实质上其实是对translationX/translationY进行操作。</p><h3 id="View动画"><a href="#View动画" class="headerlink" title="View动画"></a>View动画</h3><p>View动画需要在res下建立anim文件夹，通过xml文件定义动画形式。<br>由于View动画实际上是对View的影像进行操作，因此在使用上有许多需要注意的地方</p><ul><li>需要指定 <strong>android:fillAfter=”true”</strong>，否则动画完成以后其结果会消失，回到原状。</li><li>由于操作的是影像，所以不能真正改变View的宽高。因此动画结束后，<strong>新的位置存在只是一个影像</strong>，View真正的位置其实还在原始位置。这在用户交互上显然是是一个很要命的问题，例如对一个设置了点击事件的Button进行了view动画，将无法在影响上响应点击事件，而是还要 <strong>回到原始位置触发</strong>。</li></ul><h3 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h3><p>属性动画则是直接在代码中对View进行动画操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对translationX进行操作 0-&gt;100</span></span><br><span class="line">ObjectAnimator.ofFloat(tatrgetView,<span class="string">&quot;translationX&quot;</span>, <span class="number">0</span>, <span class="number">100</span>).setDuration(<span class="number">100</span>).start();</span><br></pre></td></tr></table></figure><br>android3.0以前，View动画需要使用nineoldandroids库实现，但其实现的属性动画，实质上还是View动画，因此也具有View动画的缺点。但Android3.0以上的属性动画则可以解决以上的所有问题。</p><h4 id="《艺术探索》提供的解决（准确来说是规避）View动画缺点的参考方案"><a href="#《艺术探索》提供的解决（准确来说是规避）View动画缺点的参考方案" class="headerlink" title="《艺术探索》提供的解决（准确来说是规避）View动画缺点的参考方案"></a>《艺术探索》提供的解决（准确来说是规避）View动画缺点的参考方案</h4><p>在终点位置设置一个与原始View外观与点击事件都相同的View，动画结束以后通过visibility显示。</p><h2 id="改变布局参数实现"><a href="#改变布局参数实现" class="headerlink" title="改变布局参数实现"></a>改变布局参数实现</h2><p>改变布局参数即设置LayoutParams。一般有两种情形，一是直接设置目标View的LayoutParams（margin）实现滑动，二是改变旁边布局的Layoutparams（width）实现滑动，而实际上View是被“挤开”的。书中也介绍了两种重新设置Layoutparams的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我一般使用</span></span><br><span class="line">view.setLayoutParams(lp);</span><br><span class="line"><span class="comment">// 涨见识</span></span><br><span class="line">view.requestLayout();</span><br></pre></td></tr></table></figure></p><h2 id="一个小坑"><a href="#一个小坑" class="headerlink" title="一个小坑"></a>一个小坑</h2><p>学习了相关知识以后，我决定写一个小demo检验+加深一下学习成果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">btn_by.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        ObjectAnimator.ofFloat(viewP, <span class="string">&quot;translationX&quot;</span>, <span class="number">0</span>, <span class="number">300</span>).setDuration(<span class="number">1000</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">btn_to.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        viewP.scrollTo(-<span class="number">100</span>, -<span class="number">600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>逻辑十分简单，就是两个View用来滑动，为了体现滑动前后与用户的交互情况，给他们设置了点击事件并通过点击事件让自己滑动。其中viewP指的是两个view（Button）的父布局（LinearLayout），即两个view时viewP的content。<br>一开始一切实现效果都在我的预计之中，但当我将点击代码改为以上代码时，出现了与我想象完全不同的效果<br><img src="/2019/04/30/View%E6%BB%91%E5%8A%A8%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/演示1.gif" alt="演示1"><br>首先btn_to使用ScrollTo()，不应该两次移动到两个不同的位置，其次btn_by并不是按动画中设置的从0位置出发。纠结半天后，设置了背景色，问题就无处遁形了。<br><img src="/2019/04/30/View%E6%BB%91%E5%8A%A8%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/演示2.gif" alt="演示2"><br>可以很明显的发现，btn_by点击以后，动画是作用在整个viewP上的，所以点击btn_to之后，没有移动或者移动到指定位置为右边并没有问题，因为btn_to相对于其父布局来说确实是在指定位置了。<br>虽然这只是一个小乌龙，但提示了我两个问题：</p><ul><li><strong>只有ScrollTo()方法是作用在content上的</strong>，动画和LayoutParams都能直接作用于View。这一点出问题其间是有意识到的，但我一直以为ScrollTo所谓的绝对滑动指的是绝对于屏幕。这也就是下一点要说的</li><li><strong>ScrollTo()所谓的绝对滑动是相对于父布局（也就是调用ScrollTo()的View）而言</strong>，而不是我一开始认为的相对于屏幕的坐标。出了这个问题，再回头去看那个Content-View的图，一切就都很明了了。</li></ul><p>总结：</p><ul><li>ScrollTo/ScrollBy方法操作的是View的Content上，而其他两种方式则是直接作用在View上边的。且这种方式不影响内部元素的交互（点击事件）</li><li>使用View动画时注意设置fillAfter以“保存”动画结果，注意View动画无法移动实体只能移动影像对交互的影响。因此View动画适用于不需要与用户交互的情况</li><li>Android3.0以前实现属性动画需要使用到的nineoldandroids库实质上也是实现了View动画</li><li>一些复杂的效果只有动画可以实现</li></ul><p>Ps：通过对View一些原理上的学习，很大程度上的提升了对View机制的理解，也对很多之前写代码时候使用到的东西理解更加清晰透彻。</p><p>知其然，也知其所以然！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;最近学习《Android开发艺术探索》的View事件体系，对View有了跟多的理解和心得体会，遂记录，加深理解也便同人交流。&quot;&gt;&lt;a href=&quot;#最近学习《Android开发艺术探索》的View事件体系，对View有了跟多的理解和心得体会，遂记录，加深理解也便同人交流。&quot; class=&quot;headerlink&quot; title=&quot;最近学习《Android开发艺术探索》的View事件体系，对View有了跟多的理解和心得体会，遂记录，加深理解也便同人交流。&quot;&gt;&lt;/a&gt;最近学习《Android开发艺术探索》的View事件体系，对View有了跟多的理解和心得体会，遂记录，加深理解也便同人交流。&lt;/h2&gt;&lt;p&gt;View一般有三种实现方式，&lt;strong&gt;ScrollTo/ScrollBy实现&lt;/strong&gt;，&lt;strong&gt;动画实现&lt;/strong&gt;，&lt;strong&gt;改变布局参数实现&lt;/strong&gt;。注意其中除了动画以外，其余两种都是非弹性的滑动，即是“瞬移”。&lt;/p&gt;
&lt;h2 id=&quot;ScrollTo-ScrollBy实现&quot;&gt;&lt;a href=&quot;#ScrollTo-ScrollBy实现&quot; class=&quot;headerlink&quot; title=&quot;ScrollTo/ScrollBy实现&quot;&gt;&lt;/a&gt;ScrollTo/ScrollBy实现&lt;/h2&gt;&lt;p&gt;这是View内部的两个方法，主要区别就是绝对滑动和相对滑动。即&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ScrollTo()，基于所传递参数的绝对滑动&lt;br&gt;ScrollBy()，基于当前位置的相对滑动  &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Code" scheme="http://codeminions.github.io/categories/Code/"/>
    
    
    <category term="Android" scheme="http://codeminions.github.io/tags/Android/"/>
    
    <category term="技能帖" scheme="http://codeminions.github.io/tags/%E6%8A%80%E8%83%BD%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>Android手势监听入门</title>
    <link href="http://codeminions.github.io/2019/03/06/Android%E6%89%8B%E5%8A%BF%E7%9B%91%E5%90%AC%E5%85%A5%E9%97%A8/"/>
    <id>http://codeminions.github.io/2019/03/06/Android%E6%89%8B%E5%8A%BF%E7%9B%91%E5%90%AC%E5%85%A5%E9%97%A8/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-08-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天写东西遇到了滑动触发动画的问题，于是开始了Android监听手势之旅。然而并不是特别顺利，特记下一些心得体会与相关的理解。"><a href="#今天写东西遇到了滑动触发动画的问题，于是开始了Android监听手势之旅。然而并不是特别顺利，特记下一些心得体会与相关的理解。" class="headerlink" title="今天写东西遇到了滑动触发动画的问题，于是开始了Android监听手势之旅。然而并不是特别顺利，特记下一些心得体会与相关的理解。"></a>今天写东西遇到了滑动触发动画的问题，于是开始了Android监听手势之旅。然而并不是特别顺利，特记下一些心得体会与相关的理解。</h2><p>Android中主要有两种手势行为，一是官方提供的特定手势，而是用户自定义的手势。本文主要讲关于android提供的手势交互。</p><h2 id="手势交互顺序"><a href="#手势交互顺序" class="headerlink" title="手势交互顺序"></a>手势交互顺序</h2><p>Android中的手势交互可分解为几个小过程：</p><ol><li>手指与屏幕接触，触发<strong>MotionEvent事件</strong>。<ul><li>MotionEvent事件中封装了一些手势动作的事件，以及x，y轴的坐标值。</li></ul></li><li>OnTouchListener监听MotionEvent事件，通过其onTouch()方法可获得该事件对象。</li><li>MotionEvent事件可由GestureDetector转发给OnGestureListener，在OnGestureListener中获取事件对象，进行下一步操作。<ul><li>GestureDetector可以识别各种手势</li><li>OnGestureListener用于监听各种的手势交互</li></ul></li></ol><a id="more"></a><h2 id="GestureListener的回调方法"><a href="#GestureListener的回调方法" class="headerlink" title="GestureListener的回调方法"></a>GestureListener的回调方法</h2><ul><li>onDown() : 按下触屏瞬间</li><li>onFling() : 抛掷动作，即手指迅速移动后松开</li><li>onLongPress() : 长按</li><li>onScroll() : 滑动拖动</li><li>onShowPress() : 按住，时间范围在长按之前</li><li>onSingleTapUp : 手指离屏瞬间</li></ul><h2 id="手势监听"><a href="#手势监听" class="headerlink" title="手势监听"></a>手势监听</h2><ul><li>创建DestureDetector对象，传入OnGestureListener</li><li><strong>将Activity或特定组件上的TouchEvent事件交给Gestureor处理</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">  GestureDetect detector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>, <span class="keyword">new</span> GestureDetector.OnGestureListener() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDown</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShowPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> detector.onTouchEvent(e)；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：不要忘了转交手势事件。Demo中最好不要放其他组件，先简单感受一下手势交互，原因后边会讲。<br>由于回调方法将事件分解的十分细致，所以你一个动作可能会连续触发好几个动作。如一次点击就会触发onDown()和onSingleTapUp()方法。  </p><h3 id="SimpleOnGestureListener"><a href="#SimpleOnGestureListener" class="headerlink" title="SimpleOnGestureListener"></a>SimpleOnGestureListener</h3><p>第一次写以上demo时候就感觉有些蠢，有时候只是想要监听点击手势或滑动手势，却就要实现5,6个回调方法。官方也是这么想的，所以给你封装一个SimpleGestureListener类，只需要重写你想要监听的手势的方法就好了。<br>使用与OnGestureListener相同。</p><h3 id="栗子："><a href="#栗子：" class="headerlink" title="栗子："></a>栗子：</h3><p>以下是<a href="http://www.runoob.com/w3cnote/android-tutorial-gestures.html">菜鸟</a>上的一个简单的栗子，借用一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GestureDetector mDetector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_MOVE = <span class="number">200</span>;   <span class="comment">//最小距离</span></span><br><span class="line">    <span class="keyword">private</span> MyGestureListener mgListener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//实例化SimpleOnGestureListener与GestureDetector对象</span></span><br><span class="line">        mgListener = <span class="keyword">new</span> MyGestureListener();</span><br><span class="line">        mDetector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>, mgListener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDetector.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGestureListener</span> <span class="keyword">extends</span> <span class="title">GestureDetector</span>.<span class="title">SimpleOnGestureListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> v, <span class="keyword">float</span> v1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(e1.getY() - e2.getY() &gt; MIN_MOVE)&#123;</span><br><span class="line">                startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, MainActivity.class));</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">&quot;通过手势启动Activity&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e1.getY() - e2.getY()  &lt; MIN_MOVE)&#123;</span><br><span class="line">                finish();</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">&quot;通过手势关闭Activity&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以下也是我初体验时比较坑的地方，我一上来就直接在ListView上识别滑动手势，却始终不能成功识别。原来我只传递了Activity上的TouchEvent，所以没能成功识别到。<br>所以这里以ListView为例了解一下其他控件的滑动事件监听。</p><h2 id="ListView的手势监听"><a href="#ListView的手势监听" class="headerlink" title="ListView的手势监听"></a>ListView的手势监听</h2><p>ListView主要有两种滑动事件监听方法，OnTouchListener与OnSrcollListener</p><h3 id="OnTouchListener"><a href="#OnTouchListener" class="headerlink" title="OnTouchListener"></a>OnTouchListener</h3><p>该方法来自View中的监听事件，通过监听<strong>Action.DOWN，Action.MOVE，Action.UP以及其发生的位置坐标即可判断用户的滑动方向</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mListView.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener())&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v,MotionEvent event)</span></span>&#123;</span><br><span class="line">              swicth(event.getAction())&#123;</span><br><span class="line">                    <span class="keyword">case</span>:MotionEvent.ACTION_DOWN:</span><br><span class="line">                           <span class="comment">//触摸</span></span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span>:MotionEvent.ACTION_MOVE:</span><br><span class="line">                           <span class="comment">//移动</span></span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span>:MotionEvent.ACTION_MOVE:</span><br><span class="line">                           <span class="comment">//离开</span></span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="OnScrollListener"><a href="#OnScrollListener" class="headerlink" title="OnScrollListener"></a>OnScrollListener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">listView.setOnScrollListener(<span class="keyword">new</span> AbsListView.OnScrollListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(AbsListView view, <span class="keyword">int</span> scrollState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (scrollState)&#123;</span><br><span class="line">            <span class="keyword">case</span> SCROLL_STATE_IDLE:</span><br><span class="line">                <span class="comment">// 滑动停止时调用</span></span><br><span class="line">                Toast.makeText(TestActivity.<span class="keyword">this</span>, <span class="string">&quot;停啦...&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SCROLL_STATE_TOUCH_SCROLL:</span><br><span class="line">                <span class="comment">// 滚动时调用</span></span><br><span class="line">                Toast.makeText(TestActivity.<span class="keyword">this</span>, <span class="string">&quot;正在滑动...&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SCROLL_STATE_FLING:</span><br><span class="line">                <span class="comment">// 离屏后ListView惯性滑动时</span></span><br><span class="line">                Toast.makeText(TestActivity.<span class="keyword">this</span>, <span class="string">&quot;停不下来...&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstVisibleItem 当前能看到的第一个Item的id，包括未显示完整的Item，即Item的序号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> visibleItemCount 当前能看到的Item数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> totalItemCount ListView的Item总数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScroll</span><span class="params">(AbsListView view, <span class="keyword">int</span> firstVisibleItem, <span class="keyword">int</span> visibleItemCount, <span class="keyword">int</span> totalItemCount)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(TestActivity.<span class="keyword">this</span>, <span class="string">&quot;第 &quot;</span> + firstVisibleItem, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>OnScrollListener()中有两个回调方法onScrollStateChanged()与onScroll()，都会进行多次回调</p><h4 id="onScrollStateChanged"><a href="#onScrollStateChanged" class="headerlink" title="onScrollStateChanged()"></a>onScrollStateChanged()</h4><p>srrollState参数有三种情况，当滑动为抛掷动作时,该方法只会回调3次,无抛掷动作（可理解为拖动）则回调2次。即滑动时回调，停止时回调，若有惯性滑动，则多回调一次。<br>可以在这个方法中通过不同的状态来设置一些Flag，区分不同的滑动状态,供其他方法处理。</p><h4 id="onScroll"><a href="#onScroll" class="headerlink" title="onScroll()"></a>onScroll()</h4><p>该方法在ListView滚动时会一直不断的回调,通过其参数可进行滑动的判断<br>如判断是否滚动到最后一行，即当前第一个ItemID + 当前Item和 == Item总数的时候，可以进行加载更多Item等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(firstVisibleItem+visibleItemCount==totalItemCount&amp;&amp;totalItemCount&gt;<span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><hr><p>然而到这里仍然没有解决我的需求。因为我是需要在一个SrcollView与WebView嵌套的结构中监听滑动，ScrollView和WebView都是可滑动控件，所以操作起来麻烦。还有就是滑动动作一直作用在SrcollView上，所以Activity一直无法获得手势事件，也就无法触发方法。<br>所以需要解决的就是ScrollView或WebView的滑动监听。<br>最后我是通过实现ScrollView的滑动监听解决了这个问题。</p><h2 id="实现ScrollView的滑动监听"><a href="#实现ScrollView的滑动监听" class="headerlink" title="实现ScrollView的滑动监听"></a>实现ScrollView的滑动监听</h2><h3 id="继承ScrollView"><a href="#继承ScrollView" class="headerlink" title="继承ScrollView"></a>继承ScrollView</h3><p>和WebView一样，ScrollView的滑动监听方法onScrollChanged()是一个受保护的方法，这意味着想要使用它必须实现一个自己的ScrollView重写原方法。关于这一点Google已经被黑惨了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义ScrollView</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RLScrollView</span> <span class="keyword">extends</span> <span class="title">ScrollView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OnScrollChangedListener onScrollChangedListener;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RLScrollView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RLScrollView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RLScrollView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnScrollChangedListener</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollChanged</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> oldxX, <span class="keyword">int</span> oldY)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnScrollListener</span><span class="params">(OnScrollChangedListener onScrollChangedListener)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.onScrollChangedListener=onScrollChangedListener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onScrollChanged</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> oldX, <span class="keyword">int</span> oldY)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onScrollChanged(x, y, oldX, oldY);</span><br><span class="line">        <span class="keyword">if</span>(onScrollChangedListener!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            onScrollChangedListener.onScrollChanged(x, y, oldX, oldY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">scrollView.setOnScrollListener(<span class="keyword">new</span> RLScrollView.OnScrollChangedListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollChanged</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> oldxX, <span class="keyword">int</span> oldY)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现通过判断先后Y值差获取有效滑动距离</span></span><br><span class="line">        <span class="keyword">if</span>(Math.abs(y-oldY) &lt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="使用NestedScrollView类"><a href="#使用NestedScrollView类" class="headerlink" title="使用NestedScrollView类"></a>使用NestedScrollView类</h3><p>后来发现v4包下有一个NestScrollView类，相当于一个封装好的ScrollView类，使用方式与自实现ScrollView相同。</p><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;今天写东西遇到了滑动触发动画的问题，于是开始了Android监听手势之旅。然而并不是特别顺利，特记下一些心得体会与相关的理解。&quot;&gt;&lt;a href=&quot;#今天写东西遇到了滑动触发动画的问题，于是开始了Android监听手势之旅。然而并不是特别顺利，特记下一些心得体会与相关的理解。&quot; class=&quot;headerlink&quot; title=&quot;今天写东西遇到了滑动触发动画的问题，于是开始了Android监听手势之旅。然而并不是特别顺利，特记下一些心得体会与相关的理解。&quot;&gt;&lt;/a&gt;今天写东西遇到了滑动触发动画的问题，于是开始了Android监听手势之旅。然而并不是特别顺利，特记下一些心得体会与相关的理解。&lt;/h2&gt;&lt;p&gt;Android中主要有两种手势行为，一是官方提供的特定手势，而是用户自定义的手势。本文主要讲关于android提供的手势交互。&lt;/p&gt;
&lt;h2 id=&quot;手势交互顺序&quot;&gt;&lt;a href=&quot;#手势交互顺序&quot; class=&quot;headerlink&quot; title=&quot;手势交互顺序&quot;&gt;&lt;/a&gt;手势交互顺序&lt;/h2&gt;&lt;p&gt;Android中的手势交互可分解为几个小过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手指与屏幕接触，触发&lt;strong&gt;MotionEvent事件&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;MotionEvent事件中封装了一些手势动作的事件，以及x，y轴的坐标值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OnTouchListener监听MotionEvent事件，通过其onTouch()方法可获得该事件对象。&lt;/li&gt;
&lt;li&gt;MotionEvent事件可由GestureDetector转发给OnGestureListener，在OnGestureListener中获取事件对象，进行下一步操作。&lt;ul&gt;
&lt;li&gt;GestureDetector可以识别各种手势&lt;/li&gt;
&lt;li&gt;OnGestureListener用于监听各种的手势交互&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Code" scheme="http://codeminions.github.io/categories/Code/"/>
    
    
    <category term="Android" scheme="http://codeminions.github.io/tags/Android/"/>
    
    <category term="技能帖" scheme="http://codeminions.github.io/tags/%E6%8A%80%E8%83%BD%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>Android/Java连接Mysql数据库</title>
    <link href="http://codeminions.github.io/2019/02/05/android%E8%BF%9E%E6%8E%A5Mysql/"/>
    <id>http://codeminions.github.io/2019/02/05/android%E8%BF%9E%E6%8E%A5Mysql/</id>
    <published>2019-02-04T16:00:00.000Z</published>
    <updated>2019-02-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>听说其实Android直接连接数据库的情况是比较少的，出于安全和内存都不建议，一般是连接服务器，通过服务器操作数据库。<br>但毕竟还是有必要掌握这项技能（其实是已经记不清前几天是为什么要写这么个东西了，纠缠几天下来已然混乱）<br>这几天这是焦头烂额，每一步都会卡一下，网上的博客也是看了不少，没能很直接解决问题（虽然最后的结果也是令我哭笑不得）  </p><blockquote><p>可能出现的问题：<br>JDBC URL中的IP地址或主机名错误<br>本地DNS服务器无法识别JDBC URL中的主机名<br>JDBC URL中的端口号丢失或错误<br>数据库服务器关闭<br>数据库服务器不接受TCP/IP连接<br>数据库服务器已用完连接<br>Java和DB之间的某些东西阻止了连接，例如防火墙或代理  </p><p>可以尝试以下操作：<br>测试ip地址能否ping通<br>刷新DNS或使用JDBC URL中的IP地址<br>根据MySQL DB的my.cnf进行验证<br>启动数据库服务<br>验证是否在没有–skip-networking选项的情况下启动mysqld<br>重新启动数据库并相应地修改代码，以便最终关闭连接<br>禁用防火墙和/或配置防火墙/代理以允许/转发端口<br>注意别忘了给app添加internet权限  <code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</code></p></blockquote><p>以上是在其他地方看到简单总结的一些要点。<br>然后要开始来讲故事了。。<br><a id="more"></a></p><h1 id="Mysql的远程登录授权"><a href="#Mysql的远程登录授权" class="headerlink" title="Mysql的远程登录授权"></a>Mysql的远程登录授权</h1><p>Mysql需要在允许远程登录的情况下才能被其他主机访问。像在android中就不可能可以本地登录吧，无论是在实体机中还是虚拟机中。</p><blockquote><p>这里顺便记录一下一些虚拟机中主机的IP地址：<br>Google模拟器<br>emulator-5554<br>开发机地址: [net.eth0.gw]: [10.0.2.2]<br>模拟器本机地址: [net.gprs.local-ip]: [10.0.2.15]<br>夜神模拟器<br>127.0.0.1:62001<br>开发机地址: [dhcp.eth1.gateway]: 172.17.100.2<br>模拟器本机地址: [dhcp.eth1.ipaddress]: [172.17.100.15]<br>逍遥模拟器<br>127.0.0.1:21503<br>开发机地址: [dhcp.eth1.gateway]: [10.0.3.2]<br>模拟器本机地址: [dhcp.eth1.ipaddress]: [10.0.3.15]  </p></blockquote><h2 id="开放3306端口"><a href="#开放3306端口" class="headerlink" title="开放3306端口"></a>开放3306端口</h2><p>查看3306端口情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -an | grep 3306</span><br><span class="line">tcp6       0      0 :::3306                 :::*                    LISTEN</span><br></pre></td></tr></table></figure><br>说明3306只是监听本地，拒绝了其他IP访问，mysql默认状态下是不开放对外访问功能。那么开放端口。<br>打开etc/mysql/my.cnf（也有人说是/etc/mysql/mysql.conf.d/mysqld.cnf），找到bind-address = 127.0.0.1（大概47行）加 # 注释即可。  </p><ul><li>其实可能是因为我是tar二进制直接安装的缘故，没有找到mysql.cnf，但后来也是可以连接上emmm  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">连接成功时3306的状态如下</span><br><span class="line">$ netstat -an | grep 3306</span><br><span class="line">tcp6       0      0 :::3306                 :::*                    ESTABLISHED</span><br></pre></td></tr></table></figure><h2 id="MySQL授权"><a href="#MySQL授权" class="headerlink" title="MySQL授权"></a>MySQL授权</h2><p>启动mysql.server，进入账户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo .&#x2F;mysql.server start</span><br><span class="line">Starting MySQL</span><br><span class="line">[ ok ..</span><br><span class="line">$ mysql -uroot -p</span><br></pre></td></tr></table></figure><br>然后问题来了。其他IP的访问授权方式有两种，<strong>授权法</strong> 和 <strong>改表法</strong>。注意Mysql5和Mysql8的授权方法有所不同，主要是语法上的改变。</p><h3 id="授权法"><a href="#授权法" class="headerlink" title="授权法"></a>授权法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grant all on 数据库名.表名 to &#39;root&#39;@&#39;%&#39; identified by &#39;password&#39;;</span><br><span class="line"></span><br><span class="line"># all 代表权限，可以是select,insert,update,delete等一个或多个，all和all privileges代表所有权限</span><br><span class="line"># 数据库.表名 指定具体开放的数据库表，不用加&#39;&#39;</span><br><span class="line"># root 是远程登录用的用户名，加不加&#39;&#39;都可以</span><br><span class="line"># % 是指定开放的具体IP，%指对所有主机开放，需加&#39;&#39;，@两边不要有空格</span><br><span class="line"># password是远程登录时用的密码</span><br></pre></td></tr></table></figure><p>以上在Mysql5下使用，也是网上查到的99%的方法。然而在Mysql8中会报语法错误<br>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to<br>your MySQL server version for the right syntax to use near ‘identified by ‘psw’’ at line 1<br>这个问题也折腾了我一下午，最后是求助了学长才意识到版本的问题。<br><strong>Mysql8</strong> 下的授权方法如下，没错就是没有identified部分。<br>而且需要 <strong>先创建一个用户，在对其进行授权</strong>，否则直接grant会报错 You are not allowed to create a user with GRANT。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 先创建用户</span><br><span class="line">create user &#39;root&#39;@&#39;%&#39; identified by &#39;pwd&#39;;</span><br><span class="line"></span><br><span class="line"># 再进行授权</span><br><span class="line">grant all on *.* to &#39;root&#39;@&#39;%&#39; with grant option;</span><br><span class="line"></span><br><span class="line"># 权限刷新</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><br>注意最后 <strong>刷新权限</strong>。</p><h3 id="改表法"><a href="#改表法" class="headerlink" title="改表法"></a>改表法</h3><p>其实最后我是通过这个方法完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; update user set host&#x3D;&#39;%&#39; where user&#x3D;&#39;root&#39;;</span><br><span class="line">Query OK, 1 row affected (0.63 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.21 sec)</span><br></pre></td></tr></table></figure><br>如上，进入mysql数据库，查看user，host可看到root用户的host是localhost。修改该项为%，刷新权限。<br>我是使用idea集成的数据库工具测试连接，连接成功。</p><h1 id="Android-Java数据库连接"><a href="#Android-Java数据库连接" class="headerlink" title="Android/Java数据库连接"></a>Android/Java数据库连接</h1><h2 id="导入数据库驱动JDBC"><a href="#导入数据库驱动JDBC" class="headerlink" title="导入数据库驱动JDBC"></a>导入数据库驱动JDBC</h2><p>到官网下载获取JDBC的jar包，常见的版本是mysql-connector-java-5.1.47.jar，较新的版本是mysql-connector-java-8.0.13。（有空了会试着把这两个上传）。<br>导包方式：复制jar到项目的libs目录下<br>右键jar选择Add as libs<br>或者直接在app的build.gradle中添加<br>implementation files(‘libs/mysql-connector-java-5.1.47.jar’)</p><h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态加载类</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">// 设置连接地址以及数据库名称</span></span><br><span class="line">String DB_URL = <span class="string">&quot;jdbc:mysql://mysql.数据库所在主机IP:3306/表名&quot;</span>;</span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line">Connection conn = DriverManager.getConnection(DB_URL, <span class="string">&quot;用户名&quot;</span>, <span class="string">&quot;密码&quot;</span>);</span><br><span class="line"><span class="comment">// 创建Statement对象(可执行SQL语句的对象)</span></span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line"><span class="comment">// 执行sql语句 返回一个ResultSet对象（返回数据集合）</span></span><br><span class="line">ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"><span class="comment">// rs调用数据</span></span><br><span class="line">rs.getString(<span class="number">1</span>);  <span class="comment">// 遍历索引</span></span><br><span class="line">rs.getString(<span class="string">&quot;name&quot;</span>); <span class="comment">// 字段名索引</span></span><br></pre></td></tr></table></figure><h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><h3 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h3><p>Android不支持在转线程执行网络请求（耗时操作）会有UnsupportedOperationException。<br>注意包括stmt.executeQuery(str) 方法也是联网操作，也要放在多线程中执行</p><h3 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h3><p>5.0和8.0驱动包有几个地方不同  </p><ul><li><p>加载8.0驱动的时候报错</p><blockquote><p>Loading class <code>&#39;com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class is &#39;com.mysql.cj.jdbc.Driver&#39;</code>. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.  </p></blockquote><p>提示，8.0包的驱动名应该改为 <strong>com.mysql.cj.jdbc.Driver</strong></p></li><li><p>建立连接时报错</p><blockquote><p>Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.</p></blockquote><p>mysql8.0是不需要建立ssl连接，需要使用useSSL=false手动关闭。即URL改为 <strong>jdbc:mysql://mysql.数据库所在主机IP:3306/表名?useSSL=false</strong></p></li><li>8.0驱动包只能兼容minSdkVersion = 26，我的测试机SdkVersion是24的，所以我只能用5.0的驱动包</li></ul><h3 id="一些报错"><a href="#一些报错" class="headerlink" title="一些报错"></a>一些报错</h3><ul><li>serverTimezone=UTC，可以指定时区（非必要）</li><li>数据库或表明出错会有报错：No address associated with hostname，Unknown database</li><li>用户名或密码错误：Access denied for user (using password: YES)</li><li>网络原因（无权限，无网络连接，在主线程执行）：com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server.  </li><li>注意在适当位置关闭相关资源流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String JDBC_DRIVER = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DB_URL = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/table&quot;</span>;</span><br><span class="line">    <span class="comment">// 注意修改DB_URL，和UER，PASS</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String USER = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PASS = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ResultSet re;</span><br><span class="line">        Connection con;</span><br><span class="line">        Statement stmt;</span><br><span class="line">        String str = <span class="string">&quot;select * from books&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Fail to load JDBC dirver.&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            con = DriverManager.getConnection(DB_URL, USER, PASS);</span><br><span class="line">            stmt = con.createStatement();</span><br><span class="line"></span><br><span class="line">            re = stmt.executeQuery(str);</span><br><span class="line">            <span class="keyword">while</span>(re.next())&#123;</span><br><span class="line">                System.out.println(re.getString(<span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            con.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String JDBC_DRIVER = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DB_URL = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/table?useSSL=false&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String USER = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PASS = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResultSet re;</span><br><span class="line">    <span class="keyword">private</span> Connection con;</span><br><span class="line">    <span class="keyword">private</span> Statement stmt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="keyword">final</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String str = <span class="string">&quot;select book_title from books&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Class.forName(JDBC_DRIVER);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;驱动加载失败&quot;</span>, e.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    con = DriverManager.getConnection(DB_URL, USER, PASS);</span><br><span class="line">                    stmt = con.createStatement();</span><br><span class="line"></span><br><span class="line">                    re = stmt.executeQuery(str);</span><br><span class="line">                    <span class="keyword">if</span> (re != <span class="keyword">null</span>)</span><br><span class="line">                        Log.i(<span class="string">&quot;标记&quot;</span>, <span class="string">&quot;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">while</span> (re.next())</span><br><span class="line">                        Log.i(<span class="string">&quot;Data&quot;</span>, re.getString(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;连接失败&quot;</span>, e.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="我碰到的问题："><a href="#我碰到的问题：" class="headerlink" title="我碰到的问题："></a>我碰到的问题：</h2><p><del>以下内容非重点</del>  </p><ul><li>Communications link failure  </li><li>The last packet sent successfully to the server was 0 milliseconds ago.The driver has not received any packets from the server.  </li></ul><p>这两个报错贯穿了我两天的debug过程，也大概是android连接Mysql最常见的报错<br>查到的都是超时相关问题，超时回收机制云云。<strong>该问题是程序运行过程中使用的连接池不知道连接被回收了所以报出的异常，解决方案大概是 修改连接池配置 或 修改mysql空闲超时时间配置</strong>，否则默认是8小时。  </p><p>但这是数据库连接中断的问题，我连都连不上。这大年初一的，就是熬夜掉头发，想起这一年的漫漫debug之路，忍不住捏了把汗。<br>我不抱希望修改了如下URL，然后气急败坏的跑去和我妹看电视。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;table?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;autoReconnect&#x3D;true&amp;failOverReadOnly&#x3D;false</span><br></pre></td></tr></table></figure><br>半晌，就在我回来继续时候，看到logout上终于打上了数据库的内容，欣喜若狂，扯着一脸问号的妹妹条了半天广场舞。<br>接下来的事令我不知该哭还是该笑，倒不是程序又不能跑了，是就在我将上面的指令一个一个删去，尝试找到罪归祸首时，发现已经是把代码恢复到原来状态了，app还是十分乖巧的连上了数据库，即jdbc:mysql://ip:3306/table。<br>我：？？？？？<br>刚刚到底发生什么了，难道还有打开某个开关以后他就默认开启之类的操作？</p><p>无论如何，总算是成功了。老泪纵横。<br>愿天下码农和八哥终成眷属。。TAT</p><hr><p><a href="https://blog.csdn.net/CristianTang/article/details/79553947">参考博客</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;听说其实Android直接连接数据库的情况是比较少的，出于安全和内存都不建议，一般是连接服务器，通过服务器操作数据库。&lt;br&gt;但毕竟还是有必要掌握这项技能（其实是已经记不清前几天是为什么要写这么个东西了，纠缠几天下来已然混乱）&lt;br&gt;这几天这是焦头烂额，每一步都会卡一下，网上的博客也是看了不少，没能很直接解决问题（虽然最后的结果也是令我哭笑不得）  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可能出现的问题：&lt;br&gt;JDBC URL中的IP地址或主机名错误&lt;br&gt;本地DNS服务器无法识别JDBC URL中的主机名&lt;br&gt;JDBC URL中的端口号丢失或错误&lt;br&gt;数据库服务器关闭&lt;br&gt;数据库服务器不接受TCP/IP连接&lt;br&gt;数据库服务器已用完连接&lt;br&gt;Java和DB之间的某些东西阻止了连接，例如防火墙或代理  &lt;/p&gt;
&lt;p&gt;可以尝试以下操作：&lt;br&gt;测试ip地址能否ping通&lt;br&gt;刷新DNS或使用JDBC URL中的IP地址&lt;br&gt;根据MySQL DB的my.cnf进行验证&lt;br&gt;启动数据库服务&lt;br&gt;验证是否在没有–skip-networking选项的情况下启动mysqld&lt;br&gt;重新启动数据库并相应地修改代码，以便最终关闭连接&lt;br&gt;禁用防火墙和/或配置防火墙/代理以允许/转发端口&lt;br&gt;注意别忘了给app添加internet权限  &lt;code&gt;&amp;lt;uses-permission android:name=&amp;quot;android.permission.INTERNET&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上是在其他地方看到简单总结的一些要点。&lt;br&gt;然后要开始来讲故事了。。&lt;br&gt;</summary>
    
    
    
    <category term="Code" scheme="http://codeminions.github.io/categories/Code/"/>
    
    
    <category term="Android" scheme="http://codeminions.github.io/tags/Android/"/>
    
    <category term="Java" scheme="http://codeminions.github.io/tags/Java/"/>
    
    <category term="技能帖" scheme="http://codeminions.github.io/tags/%E6%8A%80%E8%83%BD%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://codeminions.github.io/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://codeminions.github.io/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2019-01-12T16:00:00.000Z</published>
    <updated>2019-03-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>计算机网络协议：语法，语义，时序<ul><li>语法：描述实体间信息交换格式</li><li>语义：控制信息的具体含义</li><li>时序：交换信息的顺序以及速度配合</li></ul></li><li>功能：硬件，软件，信息</li><li>分类：覆盖范围，拓扑结构，交换方式，用户属性<ul><li>树形，星形拓扑：易于管理，中心节点是网络的关键，线路较多成本较高</li><li>环形，总线拓扑：成本效率不高，排错，增删，不便于管理</li><li>网状拓扑：节点间通信多路径选择，结构复杂成本高<a id="more"></a><h2 id="计算机网络结构"><a href="#计算机网络结构" class="headerlink" title="计算机网络结构"></a>计算机网络结构</h2><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><h3 id="接入网络方式"><a href="#接入网络方式" class="headerlink" title="接入网络方式"></a>接入网络方式</h3></li></ul></li><li>电话拨号</li><li>数字线ADSL，使用电话的物理线路，但不同信道传输</li><li>混合光纤同轴电缆HFC</li><li>局域网</li><li>移动接入网络（移动设备）</li></ul><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><ul><li>网络核心是交换节点和传输介质的集合，实现网络边缘中主机数据的中继与转发。</li><li>网络核心（通信子网）不对数据进行处理，不提供网络服务。这些功能由网络边缘（资源子网）提供</li></ul><h2 id="数据交换技术"><a href="#数据交换技术" class="headerlink" title="数据交换技术"></a>数据交换技术</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul><li>主机间建立专用的通信线路，通信结束后通道拆除</li><li>实时性高，时延与时延抖动小</li><li>突发性数据传输（网页浏览）中，信道利用率低，传输速率单一</li></ul><h3 id="电报交换"><a href="#电报交换" class="headerlink" title="电报交换"></a>电报交换</h3><ul><li>无需建立连接</li><li>只有报文被转发（传输数据）时才会占用信道，不会独占信道</li><li>以存储-转发形式传送。交换节点需要缓冲储存，报文需要排队，增加时延</li></ul><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a><strong>分组交换</strong></h3><ul><li>拆分报文为若干分组，在进存储转发</li><li>存储设备容量要求低，速率效率高</li><li>更加公平，第一个报文为全部传完，可以先开始下一个报文</li><li>延迟时间，误码率</li></ul><h2 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h2><h3 id="带宽（频带宽度）"><a href="#带宽（频带宽度）" class="headerlink" title="带宽（频带宽度）"></a>带宽（频带宽度）</h3><ul><li>单位赫兹，频率极差</li><li>带宽越大，速率越大，故带宽有时候用来代替速率描述网络性能</li></ul><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><ul><li>数据从一节点到另一节点所需时间</li><li>延迟分类：<ul><li><strong>处理时延</strong></li><li><strong>排队时延</strong></li><li><strong>传输时延，数据传输到线路上所需时间</strong></li><li><strong>传播时延，数据在线路上的传播时间</strong></li></ul></li></ul><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>链路上可以容纳的数据位数</p><h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><ul><li>网络可靠性，反映拥塞程度</li><li>丢包率 = 丢失分组数/发送分组数</li></ul><h3 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h3><p>度量数据传送能力</p><h2 id="计算机网络分层体系结构"><a href="#计算机网络分层体系结构" class="headerlink" title="计算机网络分层体系结构"></a>计算机网络分层体系结构</h2><p>各层次封装各自的头部信息后传递下一层次处理</p><ul><li>OSI参考模型（七层）</li><li>TCP/IP参考模型</li><li>五层模型：<strong>应用层（报文），传输层（段），网络层（数据报），链路层（帧，若干比特组织的数据处理单元），物理层（比特流）</strong></li></ul><h1 id="网络应用"><a href="#网络应用" class="headerlink" title="网络应用"></a>网络应用</h1><h2 id="网络应用体系结构"><a href="#网络应用体系结构" class="headerlink" title="网络应用体系结构"></a>网络应用体系结构</h2><ul><li>三种类型<ul><li><strong>客户端/用户（C/S）结构</strong>，两端角色固定，且用户之间不通信</li><li><strong>P2P（Peer To Peer）结构</strong> 客户端与服务端的结合体，客户端与服务端的地位只是在一次通信过程中不变</li><li><strong>混合结构</strong> 中心服务器+对等客户端直接通信</li></ul></li><li><strong>网络应用基本原理</strong><ul><li>本质都是CS结构</li><li>服务器端被动等待请求，客户端主动发起通信请求服务</li><li>应用进程遵循应用层协议</li></ul></li></ul><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><p>用IP地址唯一的标识通信双方，但IP不方便记忆使用。使用域名，再由系统解析为IP地址</p><ul><li>顶级域名命名方法：<br>1 国家域名nTLD； [cn中国 …]<br>2 通用顶级域名gTLD（组织）； [com企业 net网络组织 org非营利性组织 edu教育机构 gov政府 …]<br>3 基础结构域名<br>三级域名一般代表企业内部的主机名，使用时由叶节点级级往上<br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/域名树状结构.png" alt="层次树状结构"></li><li>目前存在13个DNS根域名服务器，a.root-server.net为一台根域名服务器域名</li><li>大部分根域服务器由多台独立物理服务器构成的服务器集群，而有的是由分布在不同位置的多台镜像服务器</li><li>域名服务器<ul><li>建立分布式数据库储存域名，根据用户请求将域名映射为IP地址</li><li>服务器分类：根域名，顶级域名，权威域名，本地域名服务器</li></ul></li><li>域名解析<ul><li>递归查询，服务器代替主机进行查询</li><li>迭代查询。服务器返回下一服务器，由主机自行查询<h2 id="万维网应用"><a href="#万维网应用" class="headerlink" title="万维网应用"></a>万维网应用</h2></li></ul></li><li>web服务器，发送超文本，再由浏览器解析</li><li>浏览器，网页超链接，包含URL（统一资源定位符），URL包含服务器域名。</li><li>TCP连接（保证传输可靠性）</li><li>超文本传输协议HTTP（由HTML编写）<ul><li>非持久连接 首次建立TCP连接，请求HTML页面，连接断开。解析页面后，需要再向服务器获取若干资源对象。<ul><li>串行连接：每次只向服务器请求一个对象，且每次都要重新建立TCP连接。</li><li>并行连接：一次向服务器同时发送若干请求，建立若干连接<br>要求对方服务器允许建立三条连接</li></ul></li><li>持久连接<ul><li>非流水方式持久连接 建立TCP，请求html，再依次请求资源，直到所有资源请求完毕再释放连接</li><li>流水方式持久连接 获取html后，同时发出三个TCP连接。对服务器压力较大</li></ul></li><li>HTTP报文 请求报文 &amp; 响应报文<ul><li>典型的请求方法：GET, HEAD, POST, OPTION, PUT等。<br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP报文.png" alt="HTTP报文"><br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/请求报文和响应报文.png" alt="请求报文和响应报文"><br>（状态码的短语是对状态码的简单描述）</li></ul></li></ul></li></ul><table><thead><tr><th>状态码</th></tr></thead><tbody><tr><td>1××</td><td>信息提示，需进一步交互</td></tr><tr><td>2××</td><td>成功</td></tr><tr><td>3××</td><td>重定向，资源已转移</td></tr><tr><td>4××</td><td>客户端错误</td></tr><tr><td>5××</td><td>服务端器错误</td></tr></tbody></table><ul><li>Cookie 小型文本文件，弥补了http无状态性的不足，有利于对用户进行跟踪或进行针对性服务</li></ul><ul><li>首次访问，服务器给用户编号并设置ID，将带编号的Cookie发送回给用户</li><li>用户浏览器保存该Cookie文件，并在下一次访问时一并发送给服务端<br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Cookie.png" alt="Cookie工作原理"></li></ul><h2 id="Internet电子邮件"><a href="#Internet电子邮件" class="headerlink" title="Internet电子邮件"></a>Internet电子邮件</h2><ul><li>电子邮件系统包括邮件服务器，简单邮件传输协议（SMTP），用户代理，邮件读取协议等。</li><li>SMTP是Internet电子邮件中核心应用层协议，实现邮件服务器之间或用户代理到邮件服务器的传输，默认端口为25。使用传输层TCP协议进行可靠信息传输</li><li><p>应用层交互阶段：握手阶段，邮件传输阶段，关闭阶段</p><blockquote><p><strong>SMTP协议示例</strong><br>C: telent SMTP.163.com 25  //以telenet方式连接163邮件服务器<br>S: 220 163.com Anti-spam GT for Coremail System  //220为响应数字，其后为欢迎信息<br>C: HELO SMTP.163.com //HELO发出握手请求。除此之外，HELO主要用来查询服务器支持的扩充功能<br>S: 250-mail<br>S: 250-AUTH LOGIN PLAIN<br>S: 250 8BITMIME //最后一个响应数字应答码之后跟的是一个空格，而不是’-‘<br>C: AUTH LOGIN   //请求认证<br>S: 334 dxNlcm5hbWU6  //服务器的响应——经过base64编码了的“Username”=<br>C: Y29zdGFAYW1heGl0Lm5ldA==  //发送经过BASE64编码了的用户名<br>S: 334 UGFzc3dvcmQ6  //经过BASE64编码了的”Password:”=<br>C: MTk4MjIxNA==  //客户端发送的经过BASE64编码了的密码<br>S: 235 auth successfully  //认证成功<br>// 进入邮件传输阶段<br>C: MAIL FROM: <a href="mailto:bripengandre@163.com">bripengandre@163.com</a>  //发送者邮箱<br>S: 250 <a href="mailto:bripengandre@163.com">bripengandre@163.com</a> … Sender ok //“…”代表省略了一些可读信息<br>C: RCPT TO: <a href="mailto:bripengandre@smail.hust.edu.cn">bripengandre@smail.hust.edu.cn</a>　//接收者邮箱<br>S: 250 <a href="mailto:bripengandre@163.com">bripengandre@163.com</a> … Recipient ok<br>C: DATA //请求发送数据<br>S: 354 Enter mail, end with “.” on a line by itself<br>C: Enjoy Protocol Studing   // 邮件内容<br>C: .<br>S: 250 Message sent<br>C: QUIT //退出连接<br>S: 221 Bye    // closing connection</p></blockquote></li><li><p>电子邮件格式：首部，空白行，主体。To, Subject, Cc, From, Date, Reply-To等关键字。</p></li><li>MIME 多用途互联网邮件扩展。将非AScII转换为ASCII，再利用SMTP进行传输。邮件首部增加MIME，说明主体原本数据类型及编码标准</li><li>邮件读取协议<ul><li>邮局协议 POP3(将邮件下载到本地操作，不会同步，下载后无需联网后)。<strong>默认端口号110</strong></li><li>互联网邮件访问协议 IMAP（直接操作邮件服务器）</li><li>HTTP（通过服务器网址访问）</li></ul></li></ul><h2 id="FTP文件传输协议"><a href="#FTP文件传输协议" class="headerlink" title="FTP文件传输协议"></a>FTP文件传输协议</h2><p>互联网中实现两主机间文件传输的 <strong>应用层</strong> 协议。利用传输层TCP协议。<br>CS模式。但不同于其他服务，需要采用两种连接。控制连接（<strong>21端口</strong>）传输控制命令，数据连接（<strong>20端口</strong>）传输文件内容<br>适用于传输较大文件。使控制命令更好更快传输</p><h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><ul><li>充分聚集端系统的计算能力及网络传输带宽，对服务器依赖很小</li><li>可以请求对等的端系统进行数据获取。同时也可以请求服务器，各获取一部分数据在组合</li></ul><h2 id="Socket接口模型"><a href="#Socket接口模型" class="headerlink" title="Socket接口模型"></a>Socket接口模型</h2><p>网络应用进程通信通过API接口请求的底层协议的服务。根据实际使用传输层的TCP或UDP传输。<br>创建相应提供的接口调用不同的传输协议</p><ul><li>数据报类型Sock_dgram对应UDP服务<ul><li>客户端通过临时端口直接向服务器发送数据。服务器通过绑定固定端口号，无需建立连接，直接监听等待客户端数据</li></ul></li><li>流式套接字Sock_stream对应TCP服务<ul><li>服务端通过绑定固定的端口号，监听请求。客户端无需绑定端口，通过socket()临时获取端口号</li><li>建立TCP连接，开始数据交互</li><li>交互结束，客户端关闭接口；服务端关闭连接，最后在关闭端口</li></ul></li><li>原始套接字Sock_raw直接调用网络层的服务，直接构建IP包访问。不再依赖传输层的服务</li></ul><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h3 id="传输层基本服务"><a href="#传输层基本服务" class="headerlink" title="传输层基本服务"></a>传输层基本服务</h3><p>核心任务是为应用进程之间提供端到端的逻辑通信服务。<br>网络层实现的是主机到主机的传输服务。传输层端点指的是主机中运行的应用进程。<br>传输层功能：<strong>传输层协议提供逻辑通信服务，只需在端系统中实现</strong>。中间的节点如路由器交换机无需实现传输层功能，提高效率<br>主要功能：</p><ul><li>传输层寻址<ul><li>通过 <strong>端口号</strong> 找到对应应用程序。在全网范围内利用 <strong>IP+端口号</strong> 唯一的标示一个通信端点（应用程序）</li><li>传输层端口号为16位二进制。分为三类：</li></ul><ol><li>熟知端口号：1～1023。如http:80</li><li>登记端口：1024~49151。为无熟知端口号的程序使用，需要在IANA登记以防重复</li><li>客户端口号/短暂端口号：49152～65535。用于临时申请分配按使用。不固定。</li></ol></li><li>应用层报文的分段和寻址</li><li>报文的差错检测</li><li>进程间端到端的可靠数据传输控制（是否收到）</li><li>面向应用层的复用和分解</li><li>端到端的流量控制</li><li>拥塞控制</li></ul><ul><li>无连接服务UDP：数据交互之前无需对端进行任何信息交换（握手），直接构造传输层报文段并向接收端发送</li><li>面向连接的服务TCP：传输前双方交换控制信息，建立逻辑连接，在传输数据，最后拆除连接</li></ul><h3 id="传输层的复用与分解"><a href="#传输层的复用与分解" class="headerlink" title="传输层的复用与分解"></a>传输层的复用与分解</h3><p>支持众多进程使用通过同一协议进行传输</p><ul><li>多路复用：从每个应用中获取是数据进行封装发送</li><li>多路分解：从数据中通过端口号分各个应用</li></ul><h4 id="无连接的多路复用与多路分解"><a href="#无连接的多路复用与多路分解" class="headerlink" title="无连接的多路复用与多路分解"></a>无连接的多路复用与多路分解</h4><ul><li>UDP套接字：&lt;目的IP, 目的端口号&gt;</li><li>端口号是UDP实现多路复用的重要依据</li></ul><h4 id="面向连接的多路复用与多路分解"><a href="#面向连接的多路复用与多路分解" class="headerlink" title="面向连接的多路复用与多路分解"></a>面向连接的多路复用与多路分解</h4><ul><li>TCP套接字标示一条TCP连接：&lt;源IP, 源端口，目的IP, 目的端口号&gt;</li><li>一段TCP报文到达主机时，根据此将报文分解到相应套接字（同一连接）</li></ul><h3 id="停-等协议与滑动窗口协议"><a href="#停-等协议与滑动窗口协议" class="headerlink" title="停-等协议与滑动窗口协议"></a>停-等协议与滑动窗口协议</h3><h4 id="实现可靠传输的措施："><a href="#实现可靠传输的措施：" class="headerlink" title="实现可靠传输的措施："></a>实现可靠传输的措施：</h4><ol><li>差错检测：利用差错编码实现数据包检测</li><li>确认：向发送方反馈接受状态</li><li>重传</li><li>序号：确保数据按序提交</li><li>计时器：解决数据丢失问题</li></ol><h4 id="停等协议"><a href="#停等协议" class="headerlink" title="停等协议"></a>停等协议</h4><p>每发送一个报文后就停下等待接收方确认</p><ul><li>发送经过差错编码与编号的报文段</li><li>确认接收则发送ACK，否则丢弃报文发送NCK</li><li>根据反馈状态选择重发或者继续</li></ul><h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><p>性能问题：停等机制降低信道利用率。<br>解决方案：流水线协议/管道协议：允许发送方在未收到确认前不断发送多个(后续)分组。<br>继续改进：增加分组序号范围；发，收方必须可以缓存多个分组（对未收到确认的数据进行缓存）<br>两种有代表性的滑动窗口协议：</p><ul><li>回退N步协议（Go-Back-N, GBN）：接收窗口大小为1，只接收1个按按序到达的分组。出错分组以后的全部丢弃重传</li><li>选择重传协议（Selective RePeat, SR）：接收窗口&gt;1，缓存正确但失序的分组</li></ul><h3 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 UDP"></a>用户数据报协议 UDP</h3><p>UDP数据报结构</p><ul><li>源和目的端口号：用于UDP复用分解</li><li>长度字段：UDP报文段中的字节数</li><li>校验和：接收方检测报文段是否出错<br>校验和计算<ol><li>对所有参加运算的内容按16位对齐求和</li><li>求和过程中遇到溢出（进位）都会被回卷（进位与和的最低位再加）</li><li>得到的和取反码</li></ol></li></ul><h3 id="传输控制协议-TCP"><a href="#传输控制协议-TCP" class="headerlink" title="传输控制协议 TCP"></a>传输控制协议 TCP</h3><p>TCP报文首部结构</p><ul><li>源与目的端口号</li><li>序号 标示该报文在整个分组中的序号</li><li>确认号 反馈某分组发送状态</li><li>数据偏移 同序号的报文再拆分后的数据位置</li><li>URG，标示紧急指针位是否有效</li><li><strong>ACK</strong> 确认位，标示确认号是否有效</li><li>PSH 通知可以很快对数据进行提交</li><li>RST 复位，出现错误，需要重置连接</li><li><strong>SYN</strong> 同步请求，协商序号等信息</li><li>FIN 通知拆除连接</li><li>窗口 流量控制，窗口大小可有双方控制</li><li>校验和<br>// 以上为 <strong>TCP的固定首部，20字节</strong></li><li>选项</li><li>填充 首部大小需为4字节的倍数<br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP报文结构.jpg" alt="TCP报文结构"></li></ul><h4 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h4><p>TCP传输机制包括差错编码，确认，序号，重传，计时器（实现重传）等<br>TCP的可靠数据传输基于滑动窗口协议，发送窗口动态变化（流量控制）</p><h5 id="连接建立-三次握手"><a href="#连接建立-三次握手" class="headerlink" title="连接建立-三次握手"></a>连接建立-三次握手</h5><ol><li><strong>SYN连接请求</strong> syn = 1, seq = x(同步请求，且初始序号为x)【客户端状态为SYN-SENT】</li><li><strong>SYNACK确认</strong> syn = 1, ACK = 1, seq = y, ack = x+1（x已收到请求x+1，告知服务端初始序号）【服务端状态SYN-RVD】</li><li><strong>ACK确认</strong> ACK = 1, seq = x+1, ack = y+1<br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP三次握手.png" alt="TCP三次握手"><h5 id="TCP断开-四次挥手"><a href="#TCP断开-四次挥手" class="headerlink" title="TCP断开-四次挥手"></a>TCP断开-四次挥手</h5></li><li><strong>任意一方发起断开请求</strong> FIN = 1, seq = u</li><li><strong>返回确认</strong> ACK = 1, seq = v, ack = u+1。请求方停止发送数据。另一方继续发送数据。</li><li><strong>发送请求释放连接</strong> FIN = 1, ACK = 1, seq = w, ack = u+1</li><li><strong>接收方返回确认</strong> ACK = 1, seq = u+1, ack = w+1。接收端接收到以后关闭连接，发送端进入TIME-WAIT阶段，一段时间后关闭连接</li></ol><ul><li><strong>封装TCP报文段</strong></li><li><strong>发出一个报文段后启动一个计时器</strong></li><li><strong>校验和发现数据差错</strong></li><li><strong>重排序，丢弃重复</strong></li><li><strong>流量控制</strong></li></ul><h5 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h5><ul><li>TCP利用窗口机制实现流量控制，但不是简单的滑动窗口协议（窗口动态变换）</li><li>TCP连接建立时双方分配固定大小的缓冲空间，发送数据必须在缓冲区接纳的大小<ul><li>接收端给发送方发送确认时通知接收窗口大小</li><li>发送端发送数据时，保证未确认段应用层数据不超过接收端窗口大小，使对方窗口不会产生溢出</li></ul></li></ul><h5 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h5><ul><li>窗口机制 通过调节窗口大小实现发送速率调节</li><li>窗口调节基本策略 AIMD<ul><li>加性增加 网络未拥堵，逐渐增加</li><li>乘性减小 网络拥堵，逐渐减小</li></ul></li><li>TCP拥塞控制算法<ul><li>慢启动</li><li>拥塞避免</li><li>快速重传</li><li>快速恢复</li></ul></li></ul><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>传输层主要保证数据传输的可靠性，网络层负责数据的转发和发送<br>网络层的主要作用是将网络数据报从源主机发送到目标主机<br>主要功能：</p><ul><li><strong>分组转发</strong>：分组从传输接口转移到输出接口  </li><li><strong>路由选择</strong>：决定分组经过的路由或路径<h2 id="路由器内部结构"><a href="#路由器内部结构" class="headerlink" title="路由器内部结构"></a>路由器内部结构</h2></li><li>路由选择处理机：路由选择协议 -&gt;路由表（记录下一跳的路由器）</li><li>输入端口进来的数据通过 <strong>转发表</strong> 记录的输出端口</li><li>通过路由表记录成转发表</li></ul><h2 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h2><p>按照目的主机的地址进行路由选择的网络（本质上不可靠，但效率与成本好。互联网依赖此技术建立）</p><ul><li>无连接</li><li>每个分组作为独立的数据报进行选路传输，路径可能不同</li><li>分组可能出现乱序与丢失</li></ul><h2 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h2><p>在网络层提供的面向连接的分组交换服务<br>互联网的数据报方式不可靠，所以需要在此之上建立面向连接的传输层来确保传输可靠性。</p><ul><li>建立一条网络层的逻辑连接</li><li>不需要为每条虚电路分配独享资源（区别与电路交换，信道利用率较高）</li><li>沿虚电路路径按序发送分组<br>异步传输模式的网络即采用此网络，成本较高但是传输较可靠</li></ul><h2 id="网络互连"><a href="#网络互连" class="headerlink" title="网络互连"></a>网络互连</h2><h3 id="异构网络互连"><a href="#异构网络互连" class="headerlink" title="异构网络互连"></a>异构网络互连</h3><p>两个网络使用的技术与协议不同</p><ul><li>协议转换</li><li>构建虚拟互联网络 使用IP协议作为这些网络技术和协议的下层协议，使用IP协议进行传输。在IP层次构建了虚拟网络<h3 id="网络设备–路由器"><a href="#网络设备–路由器" class="headerlink" title="网络设备–路由器"></a>网络设备–路由器</h3></li><li>输入输出端口 不同的网络技术有不同的端口<br>// 输入端口<ol><li>线路接收分组</li><li>物理层处理（处理不同网络技术）</li><li>数据链路层处理（提取其中网络层的IP数据）</li><li>网络层处理分组排队（查表转发输出，通过交换结构进入输出端口）<br>// 输出端口</li><li>网络层排队，缓存管理，每次取出一个数据</li><li>数据链路层处理（处理为不同技术）</li><li>物理层处理，发送到线路</li></ol></li><li>交换结构设计<ul><li>基于内存交换</li><li>基于总线交换</li><li>基于网络交换（节点开关）<br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/路由器交换结构.png" alt="路由器交换结构"></li></ul></li><li>路由处理器<br>执行路由器各种指令，包括路由协议运行，路由计算，路由表的更新维护等</li></ul><h2 id="网络层拥塞控制"><a href="#网络层拥塞控制" class="headerlink" title="网络层拥塞控制"></a>网络层拥塞控制</h2><h3 id="拥塞：持续过载的网络状态，用户对网络资源的需求（链路带宽，存储空间，处理能力）总需求超过固有容量"><a href="#拥塞：持续过载的网络状态，用户对网络资源的需求（链路带宽，存储空间，处理能力）总需求超过固有容量" class="headerlink" title="拥塞：持续过载的网络状态，用户对网络资源的需求（链路带宽，存储空间，处理能力）总需求超过固有容量"></a>拥塞：持续过载的网络状态，用户对网络资源的需求（链路带宽，存储空间，处理能力）总需求超过固有容量</h3><ul><li>缓冲区容量有限</li><li>带宽有限</li><li>结点处理能力有限</li><li>发生故障  <h3 id="流量感知路由"><a href="#流量感知路由" class="headerlink" title="流量感知路由"></a>流量感知路由</h3>根据负载状态动态调整，将网络流量引导到不同链路上，均衡负载，从而延缓或避免拥塞发生<br>解决网络负载的震荡现象</li><li>多路径路由</li><li>缓慢转移流量至另一链路<h3 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h3>主要应用于虚电路网络。对新建虚电路进行审核，若该电路会导致拥塞则拒绝建立。<br>拥塞状态的量化：基于平均流量与瞬时流量<h3 id="流量调节"><a href="#流量调节" class="headerlink" title="流量调节"></a>流量调节</h3></li></ul><ol><li>感知拥塞</li><li>处理拥塞：将拥塞信息通知到其上游结点<br>处理方法：<ul><li>抑制分组：给拥塞数据报源主机返回一个抑制分组（减少发送）</li><li>背压：让抑制分组从拥塞结点到源结点的路径上的每一跳都发挥抑制作用<h3 id="负载脱落"><a href="#负载脱落" class="headerlink" title="负载脱落"></a>负载脱落</h3>主动丢弃某些数据报</li></ul></li></ol><ul><li>丢弃新分组：如GBN</li><li>丢弃老分组：如实时视频流</li></ul><h2 id="Internet网络层"><a href="#Internet网络层" class="headerlink" title="Internet网络层"></a>Internet网络层</h2><h3 id="IPv4协议"><a href="#IPv4协议" class="headerlink" title="IPv4协议"></a>IPv4协议</h3><h4 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h4><ul><li>IP首部分装了来自传输层的数据</li><li>IP首部固定部分20字节</li><li>版本：IPv4/IPv6</li><li>首部长度 固定+可变</li><li>区分服务 区分不同服务质量</li><li>总长度 IP包总长度</li><li>标示 识别IP包。判断分片是否属于同一字段</li><li>标志 识别IP包是否被分割。判断是否为最后分片</li><li>片偏移 判断分片先后顺序</li><li>生存时间 多次转发仍未抵达目的地，生存时间过长丢弃</li><li>协议 标示数据部分使用的协议</li><li>检验和 差错</li><li>源，目的地址 发送与接收 数据的主机的IP地址。<strong>分别占4字节</strong>  </li></ul><p><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP数据报格式.png" alt="IP数据报格式"></p><h4 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h4><h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p>32位的二进制 点分十进制标记法 8位一组点分标<br><strong>网络号</strong>（同一网络下的主机具有相同的网络号） + <strong>主机号</strong><br>分类地址：A, B, C, D, E<br>特殊地址，私有地址<br>ABC：实际分配给联网的主机，没有重复的唯一地址<br>D：组播/多播地址。高四位为1110<br>E：保留使用。高四位为1111<br>A：前8位为网络号。最高位为0   0~127 主机数量：2^24-2<br>B：前16位为网络号。高二位为10   主机数量：2^16-2<br>C：前24位为网络号。高三位为110    主机数量：2^8-2<br><strong>ABC网络规模不同</strong></p><h5 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h5><p>将一个子网划分为多个子网<br>大子网具有较短网络前缀。小子具有稍长前缀  </p><ul><li>超网：子网合并为大网  </li><li>子网掩码：定义调节一个子网的网络前缀长度，用于划分子网。前部全为1，即为网络前缀，后部全为0</li></ul><ul><li><strong>IP ^ Mask = Subnet    IP地址与子网掩码进行与运算得到子网地址</strong>  </li><li><strong>同一子网中，网络前缀部分相同，后面为主机号不同，最小主机号代表子网地址，最大主机号代表直接广播地址</strong>  </li><li>后8为的前缀部分即为子网号，可作为连续标示</li><li>除去子网地址与广播地址，剩余即为可分配的主机数</li><li>子网掩码延长r位该子网划分为2^r 个子网<br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/子网划分.png" alt="子网划分"></li></ul><h5 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h5><p>将相同路由的连续子网合并<br>路由表中的分组转发：查找转发表（与运算匹配），最长前缀优先匹配<br>IP地址与分组表子网掩码坐与运算，所得是否匹配，再根据最长前缀进行选择</p><h4 id="动态主机配置协议"><a href="#动态主机配置协议" class="headerlink" title="动态主机配置协议"></a>动态主机配置协议</h4><p><strong>略</strong></p><h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><p>网络地址转换 NAT协议 –使用私有地址访问互联网<br>大量地址在互联网上不分配不使用只在内部使用，但保留地址在互联网上无法使用  </p><ul><li>源IP地址由Nat路由器替换为Nat拥有的合法使用的公共IP地址，同时替换端口号，并将替换关系记录到Nat转换表中</li><li>从互联网返回的IP数据报，依据其目的地址与目的端口号检索Nat转换表，获取内部ip与端口<br>同时起到隐藏实际IP地址，只公开公共地址的效果</li></ul><h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><hr><h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><p>传输层负责应用层的复用分用保证可靠传输，网络层负责将数据从主机传到主机<br>链路层负责把一个节点可靠的传输到另一个节点，为网络层提供服务  </p><h2 id="数据链路服务"><a href="#数据链路服务" class="headerlink" title="数据链路服务"></a>数据链路服务</h2><p>负责直接相邻节点的传输<br>链路层数据单元：帧<br>网络层将数据报封装交给链路层，链路层将数据添加帧头帧尾，构造数据帧  </p><ul><li>组帧</li><li>链路接入：点对点链路，广播链路（一条链路上有多个节点）</li><li>可靠交付（用于高出错链路）</li><li>差错控制</li></ul><h2 id="多路访问控制协议"><a href="#多路访问控制协议" class="headerlink" title="多路访问控制协议"></a>多路访问控制协议</h2><h3 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h3><p>纯ALOHA协议（Pure ALOHA）：直接发送 -&gt;信道侦听（反馈确认） -&gt;冲突重发<br>时隙ALOHA协议（Sloated ALOHA）：发送时间分为时隙，时隙开始时发送 -&gt;信道侦听 -&gt;冲突则下一时隙以概率P重发</p><h3 id="载波监听多路访问协议CSMA"><a href="#载波监听多路访问协议CSMA" class="headerlink" title="载波监听多路访问协议CSMA"></a>载波监听多路访问协议CSMA</h3><p>发送前监听信道是否空闲</p><ol><li>非坚持CSMA：忙则等待随机时间发送后在侦听</li><li>1-坚持CSMA：忙则持续侦听直到信道空闲</li><li>P-坚持CSMA：闲则概率P在最近时隙发送（避免同时侦听冲突）<h3 id="带冲突检测的载波监听多路访问CSMA-CD"><a href="#带冲突检测的载波监听多路访问CSMA-CD" class="headerlink" title="带冲突检测的载波监听多路访问CSMA/CD"></a>带冲突检测的载波监听多路访问CSMA/CD</h3>监听空闲后发送，发送时检测碰撞，碰撞后等待重发</li></ol><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="链路层寻址与ARP"><a href="#链路层寻址与ARP" class="headerlink" title="链路层寻址与ARP"></a>链路层寻址与ARP</h3><p>局域网广播通信，使用Mac地址进行标示通信。</p><h4 id="MAC地址-硬件地址"><a href="#MAC地址-硬件地址" class="headerlink" title="MAC地址/硬件地址"></a>MAC地址/硬件地址</h4><p>每个接口对应一个MAC地址，全球唯一。<br>路由器接口，网卡接口，交换机接口<br>长度48位，十六进制， 前24为厂商标示， 厂商分配代码</p><h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><p>根据本网内目的主机或默认网关的IP地址获取其MAC地址<br>查询/响应方式<br>所以ARP只为在同一只子网下的主机和路由器解析IP</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;计算机网络协议：语法，语义，时序&lt;ul&gt;
&lt;li&gt;语法：描述实体间信息交换格式&lt;/li&gt;
&lt;li&gt;语义：控制信息的具体含义&lt;/li&gt;
&lt;li&gt;时序：交换信息的顺序以及速度配合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;功能：硬件，软件，信息&lt;/li&gt;
&lt;li&gt;分类：覆盖范围，拓扑结构，交换方式，用户属性&lt;ul&gt;
&lt;li&gt;树形，星形拓扑：易于管理，中心节点是网络的关键，线路较多成本较高&lt;/li&gt;
&lt;li&gt;环形，总线拓扑：成本效率不高，排错，增删，不便于管理&lt;/li&gt;
&lt;li&gt;网状拓扑：节点间通信多路径选择，结构复杂成本高</summary>
    
    
    
    <category term="Network" scheme="http://codeminions.github.io/categories/Network/"/>
    
    
    <category term="Network" scheme="http://codeminions.github.io/tags/Network/"/>
    
    <category term="秘籍帖" scheme="http://codeminions.github.io/tags/%E7%A7%98%E7%B1%8D%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>修改deepin启动内核参数</title>
    <link href="http://codeminions.github.io/2018/12/20/Deepin(Ubuntu)%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8%E4%BF%AE%E6%94%B9/"/>
    <id>http://codeminions.github.io/2018/12/20/Deepin(Ubuntu)%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8%E4%BF%AE%E6%94%B9/</id>
    <published>2018-12-19T16:00:00.000Z</published>
    <updated>2019-03-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>晚上修改了deepin的启动项。<br>虽然还不知道为什么amd64版本就可以使用，但是先照一个帖子修改了启动项。我觉得没问题。但是还是记录一下修改过程以及一些细节<br><a id="more"></a></p><p>首先防止崩溃我把配置文件原件复制下来了<br>然后打开/boot/grub/grub.cfg，赫然大字：not edit this file<br>没事大神帖子撑腰，大不了重装嘛..</p><p>然后发现了，，这里面几乎是完全定义了grup的所有内容，包括文字图片主题等待时间（注释说这个文件是由其他两个配置文件自动生成的）<br>根据仅有的英文水平（介绍+翻译）看懂一些</p><p>首先有个GRUB_DEFAULT=0，默认启动项，这个值为0就是默认启动第一个，为1默认启动第二个</p><p>然后是启动菜单，好几个系统内核赫然在列，也包括advanced option的选项称之为submenu，其下面就是两个deepin内核了。我的是  </p><ul><li>Deepin 15.8 GNU/Linux, with Linux 4.15.0-29deepin-generic</li><li>Deepin 15.8 GNU/Linux, with Linux 4.9.0-deepin13-amd64</li></ul><p>对的下面那个能用..<br>然后我就粗暴的（小心翼翼）的把这个启动项【描述（如下）】整个复制到了第一项上面（前面设定了默认启动首项）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">menuentry <span class="string">&#x27;Deepin 15.8 GNU/Linux, with Linux 4.9.0-deepin13-amd64（这里改名字）&#x27;</span> --class deepin --class gnu-linux --class gnu --class os <span class="variable">$menuentry_id_option</span> <span class="string">&#x27;gnulinux-4.9.0-deepin13-amd64-advanced-f35aea66-7d3d-46a8-8ad9-ac8abf142a40&#x27;</span> &#123;</span><br><span class="line">load_video</span><br><span class="line">insmod gzio</span><br><span class="line"><span class="keyword">if</span> [ x<span class="variable">$grub_platform</span> = xxen ]; <span class="keyword">then</span> insmod xzio; insmod lzopio; <span class="keyword">fi</span></span><br><span class="line">insmod part_gpt</span><br><span class="line">insmod ext2</span><br><span class="line"><span class="built_in">set</span> root=<span class="string">&#x27;hd0,gpt9&#x27;</span></span><br><span class="line"><span class="keyword">if</span> [ x<span class="variable">$feature_platform_search_hint</span> = xy ]; <span class="keyword">then</span></span><br><span class="line">  search --no-floppy --fs-uuid --<span class="built_in">set</span>=root --hint-bios=hd0,gpt9 --hint-efi=hd0,gpt9 --hint-baremetal=ahci0,gpt9  f35aea66-7d3d-46a8-8ad9-ac8abf142a40</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  search --no-floppy --fs-uuid --<span class="built_in">set</span>=root f35aea66-7d3d-46a8-8ad9-ac8abf142a40</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">linux/boot/vmlinuz-4.9.0-deepin13-amd64 root=UUID=f35aea66-7d3d-46a8-8ad9-ac8abf142a40 ro  splash quiet DEEPIN_GFXMODE=<span class="variable">$DEEPIN_GFXMODE</span></span><br><span class="line">initrd/boot/initrd.img-4.9.0-deepin13-amd64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>听说描述最后两行是启动内核，看了一下，确实：第一项Deepin 15.8 GNU/Linux的内核为Linux 4.15.0-29deepin-generic。<br>所以我想以后看不顺眼了可以把原第一项给删了。<br>最后改了一下名（位置如上），改为Deepin 15.8 GNU/Linux -amd64</p><p>关闭以后更新配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo update-grub</span><br><span class="line">  Generating grub configuration file ...</span><br><span class="line">  Found theme: &#x2F;boot&#x2F;grub&#x2F;themes&#x2F;deepin&#x2F;theme.txt</span><br><span class="line">  Found background image: &#x2F;boot&#x2F;grub&#x2F;themes&#x2F;deepin&#x2F;background.png</span><br><span class="line">  Found linux image: &#x2F;boot&#x2F;vmlinuz-4.15.0-29deepin-generic</span><br><span class="line">  Found initrd image: &#x2F;boot&#x2F;initrd.img-4.15.0-29deepin-generic</span><br><span class="line">  Found linux image: &#x2F;boot&#x2F;vmlinuz-4.9.0-deepin13-amd64</span><br><span class="line">  Found initrd image: &#x2F;boot&#x2F;initrd.img-4.9.0-deepin13-amd64</span><br><span class="line">  Found deepin image: &#x2F;boot&#x2F;deepin&#x2F;vmlinuz-4.14.13</span><br><span class="line">  Found initrd image: &#x2F;boot&#x2F;deepin&#x2F;initrd.img-4.14.13</span><br><span class="line">  Found Windows Boot Manager on &#x2F;dev&#x2F;sda1@&#x2F;EFI&#x2F;Microsoft&#x2F;Boot&#x2F;bootmgfw.efi</span><br><span class="line">  Found Ubuntu 18.04.1 LTS (18.04) on &#x2F;dev&#x2F;sda8</span><br><span class="line">  Adding boot menu entry for EFI firmware configuration</span><br><span class="line">  done</span><br></pre></td></tr></table></figure><br>完成，现在我要重启了，希望一切正常。。</p><hr><p>好的一切正常？？完全没有变化。打开grub.cfg文件一看，咦难道我刚刚忘了保存，恢复原样。<br>看了原帖，大神已经说的很清楚了呀，这个文件是根据另外两文件生成，改这个没有用的，update-grub反而是更新了该文件，所以复原了。<br>好吧只能改原文件了。是/etc/default/grub，和/etc/grub.d下的一系列文件</p><table><thead><tr><th>/etc/grub.d</th></tr></thead><tbody><tr><td>00_header</td><td>配置初始的显示项目，如默认选项，时间限制等，一般由/etc/default/grub导入，一般不需要配置</td></tr><tr><td>05_debian_theme</td><td>配置引导画面，文字颜色等主题</td></tr><tr><td>10_linux</td><td>定位当前操作系统使用中的root设备内核的位置,包含deepin 启动项和advanced里面的启动项</td></tr><tr><td>15_linux_bar</td><td>救援模式的启动项</td></tr><tr><td>20_linux_xen</td><td>虚拟机监视器的东西，（暂时不知有什么用</td></tr><tr><td>30_uefi-firmware</td><td>“system setup” 的启动项</td></tr><tr><td>35_os-prober</td><td>windows的启动项一般在这个里面</td></tr><tr><td>40_custom</td><td>用来加入用户自定义的启动项，将会在执行update-grub时更新至grub.cfg中</td></tr><tr><td>41_custom</td><td>判断custom.cfg此配置文件是否存在，如果存在就加载它</td></tr></tbody></table><p>前面的数字是对文件排列执行的顺序进行排序，可进行更改，比如你想把windows启动项调到第一个，就把35_os-prober前面那个数字改成5到10的数字，比如06~09.<br>（快没电了直接摘）</p><p>好的成功了。（虽然由于计算失误）<br>接下来就是想办法吧它挪到第一个（好看…）</p><p>我猜测，这个新添加的启动项应该就是<strong>40_custom</strong>，所以把它改为9_custom。看起来没有成功。原来那次改完没有update就没电了。于是改为7_custom，update。成了。别忘了把启动项改为0。</p><hr><h2 id="结束总结："><a href="#结束总结：" class="headerlink" title="结束总结："></a>结束总结：</h2><p>完美满足了我的需求！</p><hr><h2 id="以下为补充："><a href="#以下为补充：" class="headerlink" title="以下为补充："></a>以下为补充：</h2><ol><li>root 告诉内核根分区设备</li><li>ro 表示在设备启动时为read-only，如果是rw表示read-write</li><li>splash 表示开机画面</li><li>quiet 示在启动过程中只有重要信息显示，类似硬件自检的消息不回显示</li><li>single 以单用户模式登录，一般用于修复系统，比如忘记密码</li><li>一些内核相关的命令<ul><li>查看本机的内核<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ uname -r</span><br></pre></td></tr></table></figure></li><li>显示可以安装的内核<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache search linux</span><br></pre></td></tr></table></figure></li><li>安装内核  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install -y linux-headers-version-generic linux-image-version-generic linux-image-extra-version-generic</span><br></pre></td></tr></table></figure></li><li>查看系统中已经安装的内核  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dpkg -l|grep linux-image</span><br></pre></td></tr></table></figure></li><li>卸载无用的内核  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get purge xxxxx</span><br></pre></td></tr></table></figure>以及一位同道中人对重装失败换内核的心得总结，果然外国友人看得明白，我也弄懂了大概怎么回事：<blockquote><p>当15.5出现并且在升级之后，我注意到系统可以在启动时登录到登录屏幕并且无法加载桌面或登录后出现的任何GUI。由于升级后（非全新安装），以前版本附带的内核仍然驻留在系统上，我尝试使用GRUB上的高级选项启动笔记本电脑（现在使用Deepin 15.5）和旧内核（附带15.4）菜单。选择以前的内核Linux 4.9.0-deepin13-amd64有用。所以<strong>新的15.5现在可以运行，但只有15.4附带的内核</strong>。</p><p>当15.6和15.7出局时也是如此。唯一有效的内核是与Deppin 15.4 一样的旧Linux 4.9.0-deepin13-amd64。这意味着Deepin打包的新内核目前无法在这些笔记本电脑上运行。</p><p>这意味着如果我碰巧重新安装Deepin OS 15.5,15.6或当前的15.7，这些内核包装的是15.4中加载的内核以外的新内核，笔记本电脑甚至都无法启动。</p><p>如果我要安装Deepin 15.7，那么首先我<strong>必须安装15.4并升级到15.7，这样我才能保留并使用15.4附带的内核。换句话说，只有Deepin 15.4可以在这些机器上进行全新安装</strong>。</p><p>在其他机器上复制这些安装最终使所有安装工作正常，15.5,15.6和15.7与更新的内核一起提供。</p><p>奖励：我还观察到，在15.4（工作正常）时，<strong>Deepin桌面环境（dde）的任何升级</strong> 都会使机器处于与安装15.5,15.6和15.7时相同的状态。</p></blockquote></li></ul></li></ol><p>至于为什么新内核不能用，原因大概是：更新完内核之后，我的 <strong>Nvidia独显驱动和内核无法一起工作</strong>，导致无法进入桌面</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;晚上修改了deepin的启动项。&lt;br&gt;虽然还不知道为什么amd64版本就可以使用，但是先照一个帖子修改了启动项。我觉得没问题。但是还是记录一下修改过程以及一些细节&lt;br&gt;</summary>
    
    
    
    <category term="OS" scheme="http://codeminions.github.io/categories/OS/"/>
    
    
    <category term="技能帖" scheme="http://codeminions.github.io/tags/%E6%8A%80%E8%83%BD%E5%B8%96/"/>
    
    <category term="Deepin" scheme="http://codeminions.github.io/tags/Deepin/"/>
    
  </entry>
  
  <entry>
    <title>Fragment的封装与调度优化 及BottomNavigationView的使用</title>
    <link href="http://codeminions.github.io/2018/12/06/fragment%E5%B0%81%E8%A3%85/"/>
    <id>http://codeminions.github.io/2018/12/06/fragment%E5%B0%81%E8%A3%85/</id>
    <published>2018-12-06T04:28:29.000Z</published>
    <updated>2019-03-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近通过网课，了解到一种十分巧妙的fragment的封装以及调度方式。遂记录下理解</p></blockquote><h2 id="Fragment的封装"><a href="#Fragment的封装" class="headerlink" title="Fragment的封装"></a>Fragment的封装</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.<span class="title">app</span>.<span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="comment">//便于复用</span></span><br><span class="line">    <span class="keyword">protected</span> View mRoot;</span><br><span class="line">    <span class="keyword">protected</span> Unbinder mRootUnBinder;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当一个fragment被添加到一个acitvity中，最首先被调用的方法</span></span><br><span class="line"><span class="comment">     * context即为activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttach(context);</span><br><span class="line">        <span class="comment">//初始化参数</span></span><br><span class="line">        initArgs(getArguments());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> layId = getContentLayoutId();</span><br><span class="line">            <span class="comment">// 初始化当前根布局，但不在创建时就添加到container中去（return root后方法内部调度自动添加到container中去）</span></span><br><span class="line">            View root = inflater.inflate(layId, container, <span class="keyword">false</span>);</span><br><span class="line">            initWidget(root);</span><br><span class="line">            mRoot = root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 父布局不等于空，则把当前root从其父控件中移除</span></span><br><span class="line">            <span class="keyword">if</span>(mRoot.getParent() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ((ViewGroup)mRoot.getParent()).removeView(mRoot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mRoot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否获取到数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initArgs</span><span class="params">(Bundle bundle)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当view界面初始化创建完成以后</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        initData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前界面的资源文件id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 资源文件id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getContentLayoutId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initWidget</span><span class="params">(View root)</span></span>&#123;</span><br><span class="line">        mRootUnBinder = ButterKnife.bind(<span class="keyword">this</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回按键触发时调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回true代表我已处理返回逻辑，activity不用自己finish</span></span><br><span class="line"><span class="comment">     * 返回flase代表未处理逻辑(不拦截)，activity自己处理逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onBackPressed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Fragment的使用"><a href="#Fragment的使用" class="headerlink" title="Fragment的使用"></a>Fragment的使用</h2><p>fragment经常与BottomNavigationView一起使用，作为底部导航栏切换界面。所以接着学习一下BottomNavigationView的使用以及封装一个Helper让BottomNavigationView使用更加便捷和更好的提升fragment性能</p><h3 id="BottomNavigationView使用"><a href="#BottomNavigationView使用" class="headerlink" title="BottomNavigationView使用"></a>BottomNavigationView使用</h3><h4 id="menu布局"><a href="#menu布局" class="headerlink" title="menu布局"></a>menu布局</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--navigation_items.xml--&gt;</span></span><br><span class="line">&lt;item</span><br><span class="line">    android:icon=&quot;@drawable/ic_home&quot;</span><br><span class="line">    android:title=&quot;@string/action_home&quot;</span><br><span class="line">    app:showAsAction=&quot;always&quot; /&gt;</span><br><span class="line">&lt;item</span><br><span class="line">    android:icon=&quot;@drawable/ic_group&quot;</span><br><span class="line">    android:title=&quot;@string/action_group&quot;</span><br><span class="line">    app:showAsAction=&quot;ifRoom&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li>always表示一定会显示，ifRoom表示如果存在空间就放上去。</li><li>默认在顶部菜单栏显示第一个控件，其余放在下拉选项中。也可用于底部导航栏<h4 id="底部导航栏示例"><a href="#底部导航栏示例" class="headerlink" title="底部导航栏示例"></a>底部导航栏示例</h4>菜单栏+颜色选择器<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.BottomNavigationView</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;@dimen/len_52&quot;</span><br><span class="line">    android:layout_gravity=&quot;bottom&quot;</span><br><span class="line">    app:menu=&quot;@menu/navigation_items&quot;</span><br><span class="line">    app:itemIconTint=&quot;@color/text_nav&quot;</span><br><span class="line">    app:itemTextColor=&quot;@color/text_nav&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="设置监听"><a href="#设置监听" class="headerlink" title="设置监听"></a>设置监听</h4></li><li>设置监听 setOnNavigationItemSelectedListener(Activity)</li><li>实现接口 BottomNavigationView.OnNavigationItemSelectedListener<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底部导航栏被点击时触发</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNavigationItemSelected</span><span class="params">(<span class="meta">@NonNull</span> MenuItem menuItem)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现UI操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 记得返回true代表可以处理本次点击</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fragment的替换及调度"><a href="#fragment的替换及调度" class="headerlink" title="fragment的替换及调度"></a>fragment的替换及调度</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般替换fragment的方法</span></span><br><span class="line">getSupportFragmentManager()</span><br><span class="line">  .beginTransaction()</span><br><span class="line">  .add(R.layout, <span class="keyword">new</span> Fragment)</span><br><span class="line">  .commit();</span><br></pre></td></tr></table></figure><ul><li>getSupporrtFragment()会返回一个FragmentManager，里面带有一个当前Acivity下加载的Fragment列表，所以可以通过它查看当前Fragmant的状态</li><li>本以为用replace()代替add()，已经可以避免覆盖的问题，并且节约资源了。其实，每次都要new一遍fragment，就不是很节约资源，重要的是，很多fragment数据不能保留复用。于是定义一个NavHelper类，优化fragmnent的调度。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决Fragment的调度与重用问题</span></span><br><span class="line"><span class="comment"> * 达到最优的Fragment切换</span></span><br><span class="line"><span class="comment"> * 用于管理当前已加载的fragment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NavHelper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//所有的Tab集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SparseArray&lt;Tab&gt; tabs = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FragmentManager manager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> containerId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OnTabChangeListener&lt;T&gt; listener;</span><br><span class="line">    <span class="comment">//当前选中的Tab</span></span><br><span class="line">    <span class="keyword">private</span> Tab&lt;T&gt; currentTab;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NavHelper</span><span class="params">(Context context, <span class="keyword">int</span> containerId, FragmentManager manager, OnTabChangeListener&lt;T&gt; listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.manager = manager;</span><br><span class="line">        <span class="keyword">this</span>.containerId = containerId;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.listener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回NavHelper实例，便于链式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NavHelper&lt;T&gt; <span class="title">add</span><span class="params">(<span class="keyword">int</span> menuId, Tab&lt;T&gt; tab)</span></span>&#123;</span><br><span class="line">        tabs.put(menuId, tab);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tab&lt;T&gt; <span class="title">getCurrentTab</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行点击菜单的操作，接管对Meun的调度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> menuId 菜单项id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否可以处理该点击</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClickMenu</span><span class="params">(<span class="keyword">int</span> menuId)</span></span>&#123;</span><br><span class="line">        Tab&lt;T&gt; tab = tabs.get(menuId);</span><br><span class="line">        <span class="keyword">if</span>(tab != <span class="keyword">null</span>)&#123;</span><br><span class="line">            doSelect(tab);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行tab的选择操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSelect</span><span class="params">(Tab&lt;T&gt; tab)</span></span>&#123;</span><br><span class="line">        Tab&lt;T&gt; oldTab = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(currentTab != <span class="keyword">null</span>)&#123;</span><br><span class="line">            oldTab = currentTab;</span><br><span class="line">            <span class="keyword">if</span>(oldTab == tab)&#123;</span><br><span class="line">                <span class="comment">// 即二次点击</span></span><br><span class="line">                notifyReselect(tab);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        currentTab = tab;</span><br><span class="line">        doTabChanged(currentTab, oldTab);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行Fragment的真实调度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doTabChanged</span><span class="params">(Tab&lt;T&gt; newTab, Tab&lt;T&gt; oldTab)</span></span>&#123;</span><br><span class="line">        FragmentTransaction ft = manager.beginTransaction();</span><br><span class="line">        <span class="keyword">if</span>(oldTab != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(oldTab.fragment != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 从界面中移除，但是还在fragment的缓存空间中</span></span><br><span class="line">                ft.detach(oldTab.fragment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(newTab != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newTab.fragment == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 首次新建</span></span><br><span class="line">                Fragment fragment = Fragment.instantiate(context, newTab.clx.getName(), <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 保存到缓存中</span></span><br><span class="line">                newTab.fragment = fragment;</span><br><span class="line">                <span class="comment">// 提交到FragmentManger</span></span><br><span class="line">                ft.add(containerId, fragment, newTab.clx.getName());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 从FragmentManger的缓存空间中重新加载到界面中</span></span><br><span class="line">                ft.attach(newTab.fragment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        ft.commit();</span><br><span class="line">        notifyTabSelect(newTab, oldTab);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回调监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyTabSelect</span><span class="params">(Tab&lt;T&gt; newTab, Tab&lt;T&gt; oldTab)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listener != <span class="keyword">null</span>)&#123;</span><br><span class="line">            listener.onTabChanged(newTab, oldTab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyReselect</span><span class="params">(Tab&lt;T&gt; tab)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 刷新Tab</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义菜单的类型</span></span><br><span class="line"><span class="comment">     * static不能让外部类引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tab</span> </span>&#123;</span><br><span class="line">         <span class="comment">// Fragment对应的Class信息</span></span><br><span class="line">         Class&lt;?&gt; clx;</span><br><span class="line">         <span class="comment">// 额外字段，用户自己设定需要使用</span></span><br><span class="line">         <span class="keyword">public</span> T extra;</span><br><span class="line">         <span class="comment">// 内部缓存的对应的fragment，不能被外部获取</span></span><br><span class="line">         Fragment fragment;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="title">Tab</span><span class="params">(Class&lt;?&gt; clx, T extra)</span></span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.clx = clx;</span><br><span class="line">             <span class="keyword">this</span>.extra = extra;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnTabChangeListener</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onTabChanged</span><span class="params">(Tab&lt;T&gt; newTab, Tab&lt;T&gt; oldTab)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>NavHelper定义逻辑：</li><li>定义performClickMenu()，从导航栏被点击时自动触发的onNavigationItemSelected()方法那接管对menu的调度。返回boolean标示是否处理该点击</li><li><p>performClickMenu()方法判断点击的tab是否已添加</p><ul><li>Helper类中定义一个集合保存menu中所有的tab。（集合实现使用比Set，List更加轻量级的SparseArray）所以必须添加一个add()方法用于初始化helper后把menu中的tab添加进去。添加tab时需要传入menu的ItemId和Tab的实例。add()中调用SparseArray.put()添加并return this。所以调用时才能helper.add().add()…</li><li><p>定义一个内部类Tab，作用类似于一个中间变量，一个menu项，fragment置于其内。并定义为static类使得能够在其他类中引用。</p><ul><li>需要传递具体Fragment的Class信息，有内部成员Class&lt;? extends Fragment&gt;</li><li>定义字段fragment，缓存fragment信息。</li><li>切换fragment的同时切换一些其他的UI或数据，所以再定义一个额外字段，由用户自己设定需要的改动类型，所以定义为泛型。因此class Tab<T>。由于在Helper中定义了存放Tab的集合，所以Helper<T></li><li><p>若添加了该字段，那么Tab的构造方法中需要传入Fragment的具体Class，以及该字段信息。</p><p><strong>此处并不一定添加该字段</strong> 对于切换时更改UI，也可以放在Helper接管前执行。这样的话，Hepler中的所有泛型及后面的回调方法也可以不需实现。只是这样Helper就没有原来那么全权接管Nav的调度。感觉都可以。</p></li></ul><p>若已添加进集合，则调用doSelect()开始处理操作。</p></li></ul></li><li><p>doSelect()中调用doTabChanged()开始真正真正的替换操作。因为doTabChanged()方法中fragment替换分步进行而非一般直接用replace()，即先舍去旧的，再放上新的，需要一个oldTab和newTab。</p><ul><li>所以添加一个成员字段currentTab，方便操作。所以需要对该字段进行更新，该工作由doSelect()承担。</li></ul><p>定义一个oldTab，不做初始化。用更新前的currentTab给oldTab赋值。<br>若点击的tab是当前tab，则执行刷新notifyReselect()<br>若不是，更新currentTab，调用替换方法</p><p>为了严谨，在此之前判断currentTab是否为空，若为空，调用替换方法时传入的oldTab即为null。</p></li><li><p>doTabChanged()方法大抵与一般替换fragment方式相同：<br>用FragmentManager.beginTransaction()初始化一个fragmentTransaction</p><ul><li>FragmentManager需要在接管时由activity传入，因此需定义内部字段manager</li></ul><p>使用transaction调用detach()，attach()在内存中替换fragment。提交，然后调用notifyTabSelect()通知并刷新。</p><ul><li>notifyTabSelect()方法中回调接口方法onTabChanged()，所以需要添加成员字段OnTabChangeListener listener;</li></ul><p>在替换前需要判断是否为空。若oldTab不为空，且oldTab.fragment也不为空，则在界面中移除其中的fragment。</p><p>若newTab不为空，但newTab.fragment为空，则新建一个Fragment，<u>缓存到fragment中</u>，并transaction.add(containerId, fragment实例, newTab.clx.getName())提交到manager。这里需要一个containerId容器ID，也需要从外部传入。</p><ul><li>通过Fragment.instantiate(Context, newTab.clx.getName(), null)初始化。这里 <strong>使用到了Tab的Class信息</strong>，也需要一个Context。所以需要在成员字段中添加一个Context，并在初始化时传入。此处相当于一般操作时 new MyFragment()。</li></ul><p>若fragment不为空，从manage缓存空间中重新接载到界面attach()。</p></li><li>所以最后编写构造方法，传入所以需要从外部传入的实例ContainerId, Context, OnTabChangeListener, FragmentManager。这些内部字段包括Sparse集合在类中都为final字段。<strong>不是很明白为什么</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NavHelper的使实际调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">NavHelper</span>.<span class="title">OnTabChangeListener</span>,</span></span><br><span class="line"><span class="class">    <span class="title">BottomNavigationView</span>.<span class="title">OnNavigationItemSelectedListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BindView(R.id.navigation)</span></span><br><span class="line">    BottomNavigationView mNavigation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NavHelper mNavHelper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        initWidget();</span><br><span class="line">        <span class="comment">//从底部导航中接管menu，手动进行触发</span></span><br><span class="line">        Menu menu = mNavigation.getMenu();</span><br><span class="line">        menu.performIdentifierAction(R.id.action_home, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化底部栏辅助工具类</span></span><br><span class="line">        mNavHelper = <span class="keyword">new</span> NavHelper(<span class="keyword">this</span>, R.id.lay_container, getSupportFragmentManager(), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        mNavHelper.add(R.id.action_home, <span class="keyword">new</span> NavHelper.Tab(ActiveFragment.class))</span><br><span class="line">                .add(R.id.action_contact, <span class="keyword">new</span> NavHelper.Tab(ContactFragment.class))</span><br><span class="line">                .add(R.id.action_group, <span class="keyword">new</span> NavHelper.Tab(GroupFragment.class));</span><br><span class="line"></span><br><span class="line">        mNavigation.setOnNavigationItemSelectedListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 底部导航被点击时触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNavigationItemSelected</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将事件流转接到工具类中</span></span><br><span class="line">        <span class="keyword">return</span> mNavHelper.performClickMenu(menuItem.getItemId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NavHelper处理完成后回调的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTabChanged</span><span class="params">(NavHelper.Tab newTab, NavHelper.Tab oldTab)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际调用：</p><ul><li>先初始化NavHelper类，传入Context(this), FragmentManager(getSupportFragmentManager()), ContainerId(IdRes), OnTabChangeListener(this, activity已继承该接口)</li><li>调用NavHelper.add()将所有的fragment以Tab的形式添加到集合中，在此处传入其具体类型为Class clx赋值</li><li><p>别忘了为BottomNavigationView添加监听。</p><ul><li><p>添加监听时继承OnNavigationItemSelectedListener接口，需要实现接口方法onNavigationItemSelected，标示能否处理此次点击，同时调用NavHelper.performClickMenu()方法实现fragment调度的交接。</p><p>在NavHelper中完成切换后，会回调接口方法OnTabChangeListener.onTabChanged()。实现该方法，完成切换fragment时UI修改。</p></li></ul></li></ul><p>FragmentTransaction操作区别</p><ul><li>add() :将fragment添加到container中</li><li>replace() :替换container中的fragment，移除其中所有的fragment。</li><li>hide/show() :隐藏与显示，不移除container中的fragment</li><li>attach/detach() :从布局上移除，但存储在缓存队列中。不会被测量到，但可以被重用，减少frag的重复创建，减少内存抖动。</li><li>remove() :直接移除</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近通过网课，了解到一种十分巧妙的fragment的封装以及调度方式。遂记录下理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Fragment的封装&quot;&gt;&lt;a href=&quot;#Fragment的封装&quot; class=&quot;headerlink&quot; title=&quot;Fragment的封装&quot;&gt;&lt;/a&gt;Fragment的封装&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Fragment&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;android&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;support&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;v4&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Fragment&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//便于复用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; View mRoot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; Unbinder mRootUnBinder;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 当一个fragment被添加到一个acitvity中，最首先被调用的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * context即为activity&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onAttach&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context context)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onAttach(context);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//初始化参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        initArgs(getArguments());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Nullable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; View &lt;span class=&quot;title&quot;&gt;onCreateView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;meta&quot;&gt;@NonNull&lt;/span&gt; LayoutInflater inflater, &lt;span class=&quot;meta&quot;&gt;@Nullable&lt;/span&gt; ViewGroup container, &lt;span class=&quot;meta&quot;&gt;@Nullable&lt;/span&gt; Bundle savedInstanceState)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(mRoot == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; layId = getContentLayoutId();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 初始化当前根布局，但不在创建时就添加到container中去（return root后方法内部调度自动添加到container中去）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            View root = inflater.inflate(layId, container, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            initWidget(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mRoot = root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 父布局不等于空，则把当前root从其父控件中移除&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(mRoot.getParent() != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ((ViewGroup)mRoot.getParent()).removeView(mRoot);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mRoot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 判断是否获取到数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;initArgs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bundle bundle)&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 当view界面初始化创建完成以后&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onViewCreated&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;meta&quot;&gt;@NonNull&lt;/span&gt; View view, &lt;span class=&quot;meta&quot;&gt;@Nullable&lt;/span&gt; Bundle savedInstanceState)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onViewCreated(view, savedInstanceState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        initData();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 获取当前界面的资源文件id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; 资源文件id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getContentLayoutId&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;initWidget&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(View root)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mRootUnBinder = ButterKnife.bind(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;initData&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 返回按键触发时调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; 返回true代表我已处理返回逻辑，activity不用自己finish&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 返回flase代表未处理逻辑(不拦截)，activity自己处理逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onBackPressed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Code" scheme="http://codeminions.github.io/categories/Code/"/>
    
    
    <category term="Android" scheme="http://codeminions.github.io/tags/Android/"/>
    
    <category term="技能帖" scheme="http://codeminions.github.io/tags/%E6%8A%80%E8%83%BD%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>Deepin文件系统变成只读</title>
    <link href="http://codeminions.github.io/2018/12/01/Deepin%EF%BC%88Ubuntu%EF%BC%89%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%98%E6%88%90%E5%8F%AA%E8%AF%BB/"/>
    <id>http://codeminions.github.io/2018/12/01/Deepin%EF%BC%88Ubuntu%EF%BC%89%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%98%E6%88%90%E5%8F%AA%E8%AF%BB/</id>
    <published>2018-12-01T00:00:00.000Z</published>
    <updated>2019-03-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决linux文件系统变成只读"><a href="#解决linux文件系统变成只读" class="headerlink" title="解决linux文件系统变成只读"></a>解决linux文件系统变成只读</h2><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>今天进入Deepin，如往常一般打开Android Studio。突然弹出提示框，说是log而文件夹有问题。还以为是as的问题，后来才发现，是文件夹变成只读的了无法操作。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>Google后发现原来是挂载分区出了问题。这种问题有时候可以用重启解决。但我重启无果，另寻他法。<br>运行mount，查看分区结构<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># mount</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;dev&#x2F;sda1 on &#x2F;boot&#x2F;efi type vfat (rw)</span><br><span class="line">  &#x2F;dev&#x2F;sda8 on &#x2F;media&#x2F;UserName&#x2F;407fe087 type ext4 (rw)</span><br><span class="line">  &#x2F;dev&#x2F;sda7 on &#x2F;media&#x2F;UserName&#x2F;Others type fuseblk (ro)</span><br><span class="line">  &#x2F;dev&#x2F;sda6 on &#x2F;media&#x2F;UserName&#x2F;File type fuseblk (ro)</span><br><span class="line">  &#x2F;dev&#x2F;sda5 on &#x2F;media&#x2F;UserName&#x2F;Software type fuseblk (ro)</span><br><span class="line">  &#x2F;dev&#x2F;sda3 on &#x2F;media&#x2F;UserName&#x2F;Windows type fuseblk (ro)</span><br><span class="line">  &#x2F;dev&#x2F;fuse on &#x2F;run&#x2F;user&#x2F;1000&#x2F;doc type fuse (rw)</span><br></pre></td></tr></table></figure><br>发现除系统盘以外其他几个盘都是只读模式(ro)，重新挂载一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># umount &#x2F;dev&#x2F;sda3</span><br><span class="line"># mount &#x2F;dev&#x2F;sda3 &#x2F;media&#x2F;UserName&#x2F;Windows</span><br></pre></td></tr></table></figure><br>这里我是失败了但是灵光一闪突然想起好像Windows的非正常关机或是电源选项开启了快速启动，会导致文件系统的读写异常。<br>记得好像早晨用PS做完图后，笔记本电源耗尽关机了，充上电以后有直接开的Deepin。于是我重启，进入windows，果然还保留着早晨的工作界面。<br>再进入Deepin，一切恢复正常！</p><p>看到这里可能感觉到被骗了。其实想说是也许文件系统的错误是windows非正常关闭导致的，不用急着修改挂载分区啥的。<br>如果是其它问题可以看看下边的两篇博客，也许能找到答案。</p><hr><p>参考博客：<br><a href="https://www.linuxidc.com/Linux/2010-04/25749.htm">修复了Ubuntu 9.10诡异的变成了只读文件系统的错误</a><br><a href="http://www.wuwenhui.cn/2513.html">解决Linux文件系统变成只读的方法</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;解决linux文件系统变成只读&quot;&gt;&lt;a href=&quot;#解决linux文件系统变成只读&quot; class=&quot;headerlink&quot; title=&quot;解决linux文件系统变成只读&quot;&gt;&lt;/a&gt;解决linux文件系统变成只读&lt;/h2&gt;&lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;今天进入Deepin，如往常一般打开Android Studio。突然弹出提示框，说是log而文件夹有问题。还以为是as的问题，后来才发现，是文件夹变成只读的了无法操作。&lt;/p&gt;
&lt;h4 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h4&gt;&lt;p&gt;Google后发现原来是挂载分区出了问题。这种问题有时候可以用重启解决。但我重启无果，另寻他法。&lt;br&gt;运行mount，查看分区结构&lt;br&gt;</summary>
    
    
    
    <category term="OS" scheme="http://codeminions.github.io/categories/OS/"/>
    
    
  </entry>
  
</feed>
