<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android手势监听入门</title>
    <url>/2019/03/06/Android%E6%89%8B%E5%8A%BF%E7%9B%91%E5%90%AC%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="今天写东西遇到了滑动触发动画的问题，于是开始了Android监听手势之旅。然而并不是特别顺利，特记下一些心得体会与相关的理解。"><a href="#今天写东西遇到了滑动触发动画的问题，于是开始了Android监听手势之旅。然而并不是特别顺利，特记下一些心得体会与相关的理解。" class="headerlink" title="今天写东西遇到了滑动触发动画的问题，于是开始了Android监听手势之旅。然而并不是特别顺利，特记下一些心得体会与相关的理解。"></a>今天写东西遇到了滑动触发动画的问题，于是开始了Android监听手势之旅。然而并不是特别顺利，特记下一些心得体会与相关的理解。</h2><p>Android中主要有两种手势行为，一是官方提供的特定手势，而是用户自定义的手势。本文主要讲关于android提供的手势交互。</p>
<h2 id="手势交互顺序"><a href="#手势交互顺序" class="headerlink" title="手势交互顺序"></a>手势交互顺序</h2><p>Android中的手势交互可分解为几个小过程：</p>
<ol>
<li>手指与屏幕接触，触发<strong>MotionEvent事件</strong>。<ul>
<li>MotionEvent事件中封装了一些手势动作的事件，以及x，y轴的坐标值。</li>
</ul>
</li>
<li>OnTouchListener监听MotionEvent事件，通过其onTouch()方法可获得该事件对象。</li>
<li>MotionEvent事件可由GestureDetector转发给OnGestureListener，在OnGestureListener中获取事件对象，进行下一步操作。<ul>
<li>GestureDetector可以识别各种手势</li>
<li>OnGestureListener用于监听各种的手势交互</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h2 id="GestureListener的回调方法"><a href="#GestureListener的回调方法" class="headerlink" title="GestureListener的回调方法"></a>GestureListener的回调方法</h2><ul>
<li>onDown() : 按下触屏瞬间</li>
<li>onFling() : 抛掷动作，即手指迅速移动后松开</li>
<li>onLongPress() : 长按</li>
<li>onScroll() : 滑动拖动</li>
<li>onShowPress() : 按住，时间范围在长按之前</li>
<li>onSingleTapUp : 手指离屏瞬间</li>
</ul>
<h2 id="手势监听"><a href="#手势监听" class="headerlink" title="手势监听"></a>手势监听</h2><ul>
<li>创建DestureDetector对象，传入OnGestureListener</li>
<li><strong>将Activity或特定组件上的TouchEvent事件交给Gestureor处理</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">  GestureDetect detector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>, <span class="keyword">new</span> GestureDetector.OnGestureListener() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDown</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShowPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> detector.onTouchEvent(e)；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：不要忘了转交手势事件。Demo中最好不要放其他组件，先简单感受一下手势交互，原因后边会讲。<br>由于回调方法将事件分解的十分细致，所以你一个动作可能会连续触发好几个动作。如一次点击就会触发onDown()和onSingleTapUp()方法。  </p>
<h3 id="SimpleOnGestureListener"><a href="#SimpleOnGestureListener" class="headerlink" title="SimpleOnGestureListener"></a>SimpleOnGestureListener</h3><p>第一次写以上demo时候就感觉有些蠢，有时候只是想要监听点击手势或滑动手势，却就要实现5,6个回调方法。官方也是这么想的，所以给你封装一个SimpleGestureListener类，只需要重写你想要监听的手势的方法就好了。<br>使用与OnGestureListener相同。</p>
<h3 id="栗子："><a href="#栗子：" class="headerlink" title="栗子："></a>栗子：</h3><p>以下是<a href="http://www.runoob.com/w3cnote/android-tutorial-gestures.html">菜鸟</a>上的一个简单的栗子，借用一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GestureDetector mDetector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_MOVE = <span class="number">200</span>;   <span class="comment">//最小距离</span></span><br><span class="line">    <span class="keyword">private</span> MyGestureListener mgListener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//实例化SimpleOnGestureListener与GestureDetector对象</span></span><br><span class="line">        mgListener = <span class="keyword">new</span> MyGestureListener();</span><br><span class="line">        mDetector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>, mgListener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDetector.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGestureListener</span> <span class="keyword">extends</span> <span class="title">GestureDetector</span>.<span class="title">SimpleOnGestureListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> v, <span class="keyword">float</span> v1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(e1.getY() - e2.getY() &gt; MIN_MOVE)&#123;</span><br><span class="line">                startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, MainActivity.class));</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">&quot;通过手势启动Activity&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e1.getY() - e2.getY()  &lt; MIN_MOVE)&#123;</span><br><span class="line">                finish();</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">&quot;通过手势关闭Activity&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>以下也是我初体验时比较坑的地方，我一上来就直接在ListView上识别滑动手势，却始终不能成功识别。原来我只传递了Activity上的TouchEvent，所以没能成功识别到。<br>所以这里以ListView为例了解一下其他控件的滑动事件监听。</p>
<h2 id="ListView的手势监听"><a href="#ListView的手势监听" class="headerlink" title="ListView的手势监听"></a>ListView的手势监听</h2><p>ListView主要有两种滑动事件监听方法，OnTouchListener与OnSrcollListener</p>
<h3 id="OnTouchListener"><a href="#OnTouchListener" class="headerlink" title="OnTouchListener"></a>OnTouchListener</h3><p>该方法来自View中的监听事件，通过监听<strong>Action.DOWN，Action.MOVE，Action.UP以及其发生的位置坐标即可判断用户的滑动方向</strong>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mListView.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener())&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v,MotionEvent event)</span></span>&#123;</span><br><span class="line">              swicth(event.getAction())&#123;</span><br><span class="line">                    <span class="keyword">case</span>:MotionEvent.ACTION_DOWN:</span><br><span class="line">                           <span class="comment">//触摸</span></span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span>:MotionEvent.ACTION_MOVE:</span><br><span class="line">                           <span class="comment">//移动</span></span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span>:MotionEvent.ACTION_MOVE:</span><br><span class="line">                           <span class="comment">//离开</span></span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="OnScrollListener"><a href="#OnScrollListener" class="headerlink" title="OnScrollListener"></a>OnScrollListener</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">listView.setOnScrollListener(<span class="keyword">new</span> AbsListView.OnScrollListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(AbsListView view, <span class="keyword">int</span> scrollState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (scrollState)&#123;</span><br><span class="line">            <span class="keyword">case</span> SCROLL_STATE_IDLE:</span><br><span class="line">                <span class="comment">// 滑动停止时调用</span></span><br><span class="line">                Toast.makeText(TestActivity.<span class="keyword">this</span>, <span class="string">&quot;停啦...&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SCROLL_STATE_TOUCH_SCROLL:</span><br><span class="line">                <span class="comment">// 滚动时调用</span></span><br><span class="line">                Toast.makeText(TestActivity.<span class="keyword">this</span>, <span class="string">&quot;正在滑动...&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SCROLL_STATE_FLING:</span><br><span class="line">                <span class="comment">// 离屏后ListView惯性滑动时</span></span><br><span class="line">                Toast.makeText(TestActivity.<span class="keyword">this</span>, <span class="string">&quot;停不下来...&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstVisibleItem 当前能看到的第一个Item的id，包括未显示完整的Item，即Item的序号，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> visibleItemCount 当前能看到的Item数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> totalItemCount ListView的Item总数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScroll</span><span class="params">(AbsListView view, <span class="keyword">int</span> firstVisibleItem, <span class="keyword">int</span> visibleItemCount, <span class="keyword">int</span> totalItemCount)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(TestActivity.<span class="keyword">this</span>, <span class="string">&quot;第 &quot;</span> + firstVisibleItem, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>OnScrollListener()中有两个回调方法onScrollStateChanged()与onScroll()，都会进行多次回调</p>
<h4 id="onScrollStateChanged"><a href="#onScrollStateChanged" class="headerlink" title="onScrollStateChanged()"></a>onScrollStateChanged()</h4><p>srrollState参数有三种情况，当滑动为抛掷动作时,该方法只会回调3次,无抛掷动作（可理解为拖动）则回调2次。即滑动时回调，停止时回调，若有惯性滑动，则多回调一次。<br>可以在这个方法中通过不同的状态来设置一些Flag，区分不同的滑动状态,供其他方法处理。</p>
<h4 id="onScroll"><a href="#onScroll" class="headerlink" title="onScroll()"></a>onScroll()</h4><p>该方法在ListView滚动时会一直不断的回调,通过其参数可进行滑动的判断<br>如判断是否滚动到最后一行，即当前第一个ItemID + 当前Item和 == Item总数的时候，可以进行加载更多Item等操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(firstVisibleItem+visibleItemCount==totalItemCount&amp;&amp;totalItemCount&gt;<span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>然而到这里仍然没有解决我的需求。因为我是需要在一个SrcollView与WebView嵌套的结构中监听滑动，ScrollView和WebView都是可滑动控件，所以操作起来麻烦。还有就是滑动动作一直作用在SrcollView上，所以Activity一直无法获得手势事件，也就无法触发方法。<br>所以需要解决的就是ScrollView或WebView的滑动监听。<br>最后我是通过实现ScrollView的滑动监听解决了这个问题。</p>
<h2 id="实现ScrollView的滑动监听"><a href="#实现ScrollView的滑动监听" class="headerlink" title="实现ScrollView的滑动监听"></a>实现ScrollView的滑动监听</h2><h3 id="继承ScrollView"><a href="#继承ScrollView" class="headerlink" title="继承ScrollView"></a>继承ScrollView</h3><p>和WebView一样，ScrollView的滑动监听方法onScrollChanged()是一个受保护的方法，这意味着想要使用它必须实现一个自己的ScrollView重写原方法。关于这一点Google已经被黑惨了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义ScrollView</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RLScrollView</span> <span class="keyword">extends</span> <span class="title">ScrollView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OnScrollChangedListener onScrollChangedListener;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RLScrollView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RLScrollView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RLScrollView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnScrollChangedListener</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollChanged</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> oldxX, <span class="keyword">int</span> oldY)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnScrollListener</span><span class="params">(OnScrollChangedListener onScrollChangedListener)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.onScrollChangedListener=onScrollChangedListener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onScrollChanged</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> oldX, <span class="keyword">int</span> oldY)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onScrollChanged(x, y, oldX, oldY);</span><br><span class="line">        <span class="keyword">if</span>(onScrollChangedListener!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            onScrollChangedListener.onScrollChanged(x, y, oldX, oldY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">scrollView.setOnScrollListener(<span class="keyword">new</span> RLScrollView.OnScrollChangedListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollChanged</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> oldxX, <span class="keyword">int</span> oldY)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现通过判断先后Y值差获取有效滑动距离</span></span><br><span class="line">        <span class="keyword">if</span>(Math.abs(y-oldY) &lt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="使用NestedScrollView类"><a href="#使用NestedScrollView类" class="headerlink" title="使用NestedScrollView类"></a>使用NestedScrollView类</h3><p>后来发现v4包下有一个NestScrollView类，相当于一个封装好的ScrollView类，使用方式与自实现ScrollView相同。</p>
<hr>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技能帖</tag>
      </tags>
  </entry>
  <entry>
    <title>APT（注解处理器）学习与理解</title>
    <url>/2019/11/20/APT%EF%BC%88%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%89%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>这段时间通过对注解管理器的学习，跟着网课简单实现了玉观音注解处理，对注解有更多理解。<br>同时由于该网课是基于kotlin讲解，于是也get了很多kotlin的基本操作之外的炫酷操作<br>因此这篇文章，重在自身的记录理解</p>
</blockquote>
<a id="more"></a>
<h1 id="Java注解基础"><a href="#Java注解基础" class="headerlink" title="Java注解基础"></a>Java注解基础</h1><p>注解可以理解为标签，用于对代码的标记识别。使用<strong>@interface</strong>定义一个注解。</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>5种元注解，作为基本注解可以用于修饰其他的注解。</p>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>标示一个注解的存活时间，即生命周期。</p>
<ul>
<li>RetentionPolicy.SOURCE 只在源码阶段保留，编译时被编译器丢弃</li>
<li>RetentionPolicy.CLASS    只被保留到编译时，不会被加载到JVM中</li>
<li>RetentionPolicy.RUNTIME 可以被保留到运行时，故可以在运行时获取</li>
</ul>
<h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>可以将注解中的内容添加到JavaDoc中去。</p>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>限定一个注解的使用场景。一般的注解使用场景不被限定，使用该注解以后使用场景被限定。</p>
<ul>
<li>ElementType.ANNOTATION_TYPE 对一个注解进行注解</li>
<li>ElementType.CONSTRUCTOR 对构造方法进行注解</li>
<li>ElementType.FIELD 对属性字段进行注解</li>
<li>ElementType.LOCAL_VARIABLE 对局部变量进行注解</li>
<li>ElementType.METHOD 对方法进行注解</li>
<li>ElementType.PACKAGE 对一个包进行注解</li>
<li>ElementType.PARAMETER 对一个方法参数进行注解</li>
<li>ElementType.TYPE 对一个类型进行注解，如类，接口，枚举</li>
</ul>
<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>标示该注解标示的类的子类如果没有注解的话，可以继承父类的注解。</p>
<h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p>标示该注解可以被使用于同一位置，一般是注解的值可以有多个。实例如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Persons.class)</span></span><br><span class="line"><span class="meta">@interface</span> Person &#123;</span><br><span class="line">	<span class="function">String <span class="title">role</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">	Person[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中@Repeatable后的Person相当于一个容器注解，<em>即用于存放其他注解的地方</em>，其本身也是一个注解。<br>容器注解需要设置一个value字段作为注解容器，因此value需要是一个数组，并且其中的注解类型需要是被@Repeatable标示的注解。</p>
<h2 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h2><p>注解不存在成员方法，只有成员属性，并可以指定默认值，定义方式如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> Person &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="meta">@Person(value=1, msg=&quot;hi&quot;)</span></span><br></pre></td></tr></table></figure><br>当只有一个成员属性时，可以直接在括号中填写其值无需在写参数名；若没有成员属性</p>
<h1 id="Android中的注解"><a href="#Android中的注解" class="headerlink" title="Android中的注解"></a>Android中的注解</h1><p>apt即AnnotationProcessingTool，注释处理工具</p>
<ul>
<li>android-apt和AnnotationProcessor<br>android-apt是一位开发者开发的apt框架。AndroidGradle2.2以后提供了annotationProcessor替代android-apt，不支持使用android-apt。但是目前很多项目还是使用的android-apt。</li>
</ul>
<ul>
<li>注解处理器是Java层面的东西多所以无法知道kotlin层的东西，因此需要使用Builder::class.java</li>
<li>工具类中的Logger类中的note只能在debugger时才能生效（看看实现）</li>
<li>没有添加kotlin插件支持的模块，将不会处理.kt文件 apply ‘kotlin’</li>
<li>build/tmp/kapt3/stubs/debug/*.java 使用kapt后将kotlin代码解释为java文件后存放位置</li>
<li>启用kotlin插件 ‘kotlin-kapt’ 后 通过kapt project() 指定apt模块来指向我们编写的Annotation Process Tool</li>
<li><em>Element 元素 到底是个什么东西？</em>    <strong>其实就是注解修饰的对象，可以是成员字段，成员方法，类等</strong></li>
<li>对注解信息进行解析。通过对Element进行解析。TypeElement是Element的一个实现</li>
<li>Element.getName获取到的Name对象，其实就是一个CharSequence字符序列</li>
<li>Element.getPackage()获取到包名。如果是一个包，就抛出错误</li>
<li><p>对对成员字段进行保存排序，<strong>使用TreeSet</strong>，使得成员字段发生增删变化后，其相对顺序仍保持不变，便于开发</p>
</li>
<li><p>自定义Field字段类</p>
<ul>
<li>设置value并private set，因为其值由注解传入</li>
<li><em>prefix字首 字段的含义</em>    </li>
<li><em>TypeMirror?        TypeMirror是Java编译时对java类型的一个表示，是所有Type类的基类</em></li>
<li>kotlin “”” “””    将会把其中的字符串原样输出，也就是说不需要经过转义</li>
<li>defaultValue = “”””${optional.stringValue}”””” 是我眼拙了，一共要四个也就是最后把一个叫 “string”</li>
<li><p>对获取的方法进行解析，    </p>
</li>
<li><p>ActivityClass 是解析出来的类的模板，持有解析出来的类的信息（代码）</p>
</li>
</ul>
</li>
<li><p>得到是否抽象的标示，没有相关内部字段支持所以可以使用提供的api获取所有修饰符列表，判断其中是否包含abstract</p>
</li>
<li><p>得到是否kotlin代码的标示。由于kapt会对kotlin代码进行解释，出来一份带kotlin注解的代码，所以可以依次进行判断，但是该注解是个接口，只能通过反射获取</p>
</li>
<li><p>BuildProcessor</p>
<ul>
<li>对Builder修饰的元素进行遍历，首先过滤筛查出class的元素</li>
<li>判断该元素是否一个activity，是的话将该element放到一个map中，将element与其activityClass关联起来</li>
<li>对Optional修饰的对象进行遍历，还先筛出Field</li>
<li>通过enclosingElement得到该feild的外部类，通过它在map中找到activityClass，向其中的field（TreeSet）进行赋值</li>
<li>同上操作对Required注解的元素进行activityClass的填充</li>
<li>最后将文件输出</li>
</ul>
</li>
</ul>
<p><em>type和kind好像都有类型的意思，具体分别代表着什么</em></p>
<ul>
<li>写入到文件（将从注解中获得的信息生成真正的.java文件）<ul>
<li>使用ActivityClasss为信息来源，生成的java文件为ActivityBuilder.java，</li>
<li>先生成类信息，不对抽象类进行处理，类名，添加修饰符，基本是public，final。最后得到一个TypeSpec，携带着类的信息</li>
<li>编写一个ConstantBuilder专门生成常量</li>
<li>对生成的常量进行初始化，javapoet中使用”\$S”，S表示字符串</li>
<li>使用JavaFile生成文件</li>
</ul>
</li>
<li>在Process中对文件进行生成，使用一个全局的filer</li>
<li><p>至此可以生成代码Builder类，其中带有常量字段。因此终于得以一窥该注解处理器的主要目的：首先通过对一个activity中的字段注解进行解析，得到字段名对应的静态常量字段，通过这些字段作为tag，进行activity间的intent通信的媒介。为什么专门生成常量来作为tag，因为后边要通过注解处理器，接管这一通信过程，即舍去大量繁琐的putExtra()过程。因此tag的部分当然需要完全的包装起来。</p>
</li>
<li><p>通过一个start()方法启动intent的包装和activity的启动。创建一个StartMethod类存放持有所有的具体start方法，ContantBuilder来控制生成start函数</p>
</li>
<li>StartMethod 设置一个list存放所有的field。由于Optional的字段多于3个时将使用实例方法创建start()，所以需要有一个static的标志位。</li>
<li>Field列表的填充，从外部传入。此处使用了运算符的重载。定义对Field的操作方法，对该对象进行复制的方法：使用同样的Field，不同的name</li>
<li>编写build()方法。使用name创建方法，添加修饰，返回值，参数。参数需要一个TypeName，向ClassType传入包名路径获取，该类是作者编写的工具类。</li>
<li>方法内语句的编写，需要addStatement()添加声明。使用$T，与$S不同的是，$T可以为我们导包</li>
<li>通过遍历field列表，进一步增加方法参数，将需要的字段作为参数添加到方法中，并逐条进行putExtra()。前边未对field类型名称进行获取，这里补充一下：asJavaTypeName()    <strong>这里对name和asJavaType有点不明白</strong></li>
<li>$L 直接把值替换，$S是把值加上引号作为字符串的自变量替换</li>
<li>对静态方法进行区分。是静态方法，加上static；不是静态，则加上fillIntent(intent)  <strong>????</strong></li>
<li>最后编写启动activity的代码，需要使用Activity的实例去调用startActivity()。于是在runtime模块定义ActivityBuilder类。此处不定义kotlin类，目的在于使用时可以在app中直接依赖而不需要kotlin库。</li>
<li>ActivityBuilder使用单例模式，包装startActivity()方法，其实就是当不是Activity的context启动的时候，使用单例启动。所以这里应该可以直接使用startActivity()。这一部分和APT大概关系不大，从其直接被app依赖也可以看出</li>
<li>开始编写StartMethodBuilder，这个类主要用于控制start方法的生成，因为需要根据Optional注解的个数进行调度。</li>
<li>编写build()，首先实例化一个StartMethod，使用ActivityClassBuilder中定义的常量作为方法名。</li>
<li>使用groupBy()根据是否OptionalField进行分类。使用groupBy()后在分为两个list</li>
<li>先将Required注解的字段添加到startMethod()中，<strong>表示Required标示的的代码都需要进行处理</strong>，即NoOptional不可选的</li>
<li>这里发现了之前写的一个bug，没注意的地方。就是根据OptionalFeild分类时，始终无法识别出OptionalFeild。经过思考，感觉是对field进行写入时的问题，果然，在BuilderProcessor中对Field写入时，判断为Optional时，就直接写入OptaionalField，而我写的Field。</li>
<li>这里又明白一点作者的意图，就是生成多个start()方法，让使用者通过@Optional进行标示以后，可以通过选择不同的start去决定是否给Optional声明赋值。当Optional可选的个数不大于3时，可以通过传入目标字段的方式初始化指定字段；大于3时，通过传入Intent的方式，自构造Intent传入，也就是一般的做法。</li>
<li>这个地方理解有点问题，最终效果应该是，大于3时，生成fillIntent()方法，通过对字段的赋值，使用fillIntent()对字段进行填充。其实大体意义相似，就是实现有点区别。这里需要对是否基本类型进行判断，因为不是基本类型才能使用==Null，基本类型的话就不要判空了<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityBuilder <span class="title">title</span><span class="params">(String title)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.title = title;</span><br><span class="line">	rerurn <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillIntent</span><span class="params">(Intent intent)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(title == <span class="keyword">null</span>)</span><br><span class="line">		intent.putExtra(<span class="string">&quot;title&quot;</span>, title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<em>关于TypeName不大理解</em><br>一个包装了类型名String的类。ClassName，TypeName的子类。写入方法时，需要用.returns()指明返回值，需要传入TypeName对象。传入包名+类名构造ClassName传入。</li>
</ul>
<h2 id="MY"><a href="#MY" class="headerlink" title="MY"></a>MY</h2><ul>
<li>因为String不是基本类型，所以需要单独领出来识别。</li>
<li>大写转下划线函数编写。使用了fold()方法辅助，自动为我们遍历集合，我们需要传入一个方法定义对每一个元素的操作</li>
</ul>
<h2 id="传说中的kotlin特性？"><a href="#传说中的kotlin特性？" class="headerlink" title="传说中的kotlin特性？"></a>传说中的kotlin特性？</h2><ul>
<li>AptUtils中的TypeUtils里通过 fun Element.simpleName():String = simpleName.toString()，使得可以在开发中直接用Element调用simpleName()方法</li>
<li>继承Comparabled接口，实现compareTo()方法，使对象可排序（比较）</li>
<li>private set 不自动生成setter方法 </li>
<li>?: 左值为空则调用右侧代码</li>
<li>kotlin “”” “””    将会把其中的字符串原样输出，也就是说不需要经过转义</li>
<li>运算符重载，使用特定方法名编写扩展方法，并使用operator修饰</li>
<li>groupBy() 方法，传入一个函数，根据函数返回的值作为键值分类，返回一个map，键是函数返回的值，对应的值是一个存放相同结果的list，即Map&lt;T, List<R>&gt;</li>
</ul>
<h2 id="Kotlin学习"><a href="#Kotlin学习" class="headerlink" title="Kotlin学习"></a>Kotlin学习</h2><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>kotlin的方法参数，可以有默认值，当传参时省略参数时会使用该默认值。<br>调用参数时，可以使用命名参数的方式传入，增强可读性：fun(arg1 = 2, arg2 = 3)<br>当返回类型可以由编译器推断，则可以不需要显式声明返回值。有代码块的方法必须显式声明，除非返回Unit</p>
<h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>使用vararg修饰，使用数组形式调用。一般置于参数列表最后一个，或者其后的参数使用命名参数传递，或者其后是一个函数类型（lambda）<br>直接使用数据传递，使用伸展操作符，即*数组名</p>
<h3 id="中缀表示法"><a href="#中缀表示法" class="headerlink" title="中缀表示法"></a>中缀表示法</h3><p>调用方法时，使用object fun arg的形式。该方法必须只有一个参数，不能有默认值，不是可变长数组。且必须指明调用者，即this不再可以省略。</p>
<h3 id="顶层函数"><a href="#顶层函数" class="headerlink" title="顶层函数"></a>顶层函数</h3><p>在文件顶层声明，即不需要再使用一个类实例调用</p>
<h3 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h3><p>在函数的内部定义的函数。内部函数可以访问外部函数的变量（闭包）。</p>
<h3 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h3><p>为一个第三方库编写一个函数，可以使用该库的对象调用。静态解析。</p>
<h3 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h3><p>对于使用尾递归的函数，kotlin中使用tailrec修饰，编译器会将其优化为循环形式实现的方式。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>将函数当做参数或返回值的函数，即高阶函数的参数或返回值是一个函数。</p>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>(A, B) -&gt; C，表示了函数签名即参数与返回值。Unit返回类型不可省略。</p>
<ul>
<li>(Int)-&gt;((Int)-&gt; Unit) == (Int) -&gt; (Int)-&gt; Unit，因为函数类型支持右结合</li>
</ul>
<h3 id="Lambda表达式与匿名函数"><a href="#Lambda表达式与匿名函数" class="headerlink" title="Lambda表达式与匿名函数"></a>Lambda表达式与匿名函数</h3><p>函数字面值。如果函数最后一个参数为函数，则可以将lambda放在参数列表以外。lambda中单个参数可以使用it表示</p>
<h3 id="泛型-声明处型变-类型投影"><a href="#泛型-声明处型变-类型投影" class="headerlink" title="泛型 声明处型变 类型投影"></a>泛型 声明处型变 类型投影</h3><p>这一部分官方文档讲的极其复杂。当然没能看懂。看到最后其实就是out和in。<strong>跳过了</strong></p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>其实java中也有同样的使用方法只是一直没有注意。一般都是使用类的泛型在方法中调用，但其实可以直接定义泛型方法，<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">singleFun</span><span class="params">(arg: <span class="type">T</span>)</span></span>: T &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">sampleFun</span><span class="params">(arg: <span class="type">T</span>)</span></span>: T &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="操作符also使用实例"><a href="#操作符also使用实例" class="headerlink" title="操作符also使用实例"></a>操作符also使用实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val method = startMethod.copy(field.name)</span><br><span class="line">method.addField(field)</span><br><span class="line">method.build(typeBuilder)</span><br><span class="line"></span><br><span class="line">startMethod.copy(field.name).also &#123;  it.addFeild(feild) &#125;.build(typeBuilder)</span><br></pre></td></tr></table></figure>
<p>以上代码实现同样的效果，第二种只有一行且不需要创建引用<br>由于medthod需要addFeild()处理，但是该方法返回值为空（或返回对象）使得必须使用这种三段式方式实现。also操作符的意义在于此，it为对象本身且返回最后返回值为该对象。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">startMethod.copy(field.name).staticMethod(<span class="keyword">false</span>).build(typeBuilder)</span><br></pre></td></tr></table></figure><br>而在以上代码中则不需要使用also，因为staticMethod()方法返回对象本身，一直可以直接使用返回值.build()</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>秘籍帖</tag>
      </tags>
  </entry>
  <entry>
    <title>ButterKnife配置及使用</title>
    <url>/2018/09/13/ButterKnife%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="黄油刀-ButterKnife"><a href="#黄油刀-ButterKnife" class="headerlink" title="黄油刀(ButterKnife)"></a>黄油刀(ButterKnife)</h2><p><img src="/2018/09/13/ButterKnife%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/ButterKnife.png" alt="ButterKnife"></p>
<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><a href="http://jakewharton.github.io/butterknife/">官方文档</a></h3><a id="more"></a>
<h3 id="简介-为什么需要使用它？-："><a href="#简介-为什么需要使用它？-：" class="headerlink" title="简介(为什么需要使用它？)："></a>简介(为什么需要使用它？)：</h3><p>ButterKnife取代了findViewById完成View的注入，提高效率</p>
<ul>
<li>使用注解生成模块代码，用于把一些字段和方法绑定到 Android 的 View;</li>
<li>强大的View绑定和Click事件等处理功能，简化代码，提升开发效率</li>
<li>运行时不会影响APP效率，使用配置方便</li>
<li>代码清晰，可读性强</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>ButterKnife没有正确配置时，会有NullPointException。</p>
<ol>
<li>首先在project的build.gradle中添加classpath<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    classpath <span class="string">&#x27;com.neenbedankt.gradle.plugins:android-apt:1.8&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>然后是model的build.gradle中添加依赖<br>这里看的所有教程都是用compile，apt。但其实compile已经被淘汰很久了。(误事啊误事…)<br>ButterKnife已经讲的的很明白了。<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">	implementation <span class="string">&#x27;com.jakewharton:butterknife:(insert latest version)&#x27;</span></span><br><span class="line">	annotationProcessor <span class="string">&#x27;com.jakewharton:butterknife-compiler:(insert latest version)&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>insert laster verrsion 目前是8.8.1（2018.09）</li>
</ul>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><ul>
<li>绑定资源<br><strong>@BindView(R.id) Type tempName;</strong></li>
</ul>
<ol>
<li>Activity中<br>需在onCreate 的setContentView()后添加ButterKnife.bind(this)绑定布局;</li>
<li>Fragment &amp; Adapter ViewHolder中<br>F : ButterKnife.bind(this, rootView);<br>A :<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span></span>&#123;</span><br><span class="line">		<span class="meta">@BindView(R.id.text_view)</span> TextView mTextView;</span><br><span class="line">	    <span class="meta">@BindView(R.id.button)</span> Button mButton;;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">	       ButterKnife.bind(<span class="keyword">this</span>, itemView);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>setOnClickListener()    –绑定点击事件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OnClick(R.id)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setClick</span><span class="params">(View v)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>参数接受一个id集合用于多个View处理同一事件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OnClick(&#123;R.id, R.id, ...&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setClick</span><span class="params">(View v)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>BaseActivity中是使用<br>由于butterknife绑定需要在每个Activity中都实现一遍，所以可以将这个操作写进一个Base，然后让所有的Activity都去继承它。BaseActivity中的实现细节如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> UnBinder mBinder;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> LayoutResId)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.setContentView(LayoutResId);</span><br><span class="line">		mBinder = ButterKnife.bind(<span class="keyword">this</span>);	  <span class="comment">//ButterKnife初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBinder.unbind();</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3></li>
</ol>
<ul>
<li>这些view不能是priavate 或static 。</li>
<li>在使用BindView方法的时候，如果目标View没有找的的话，会抛出异常。如果不想受到这个异常，可以使用@Nullable（该注释标注了该参数可否为null）。</li>
<li>由于在Activity中都要进行ButterKnife.bind操作，所以可以将bind操作写入baseActivity。8.4以后ButterKnife移除了ButterKnife.unBind()方法，取而代之的是ButterKnife.bind(this)会返回一个Unbinder的引用，通过Unbinder的unbind()方法进行解除绑定。</li>
</ul>
<ol start="5">
<li>Zelezny插件的使用</li>
</ol>
<ul>
<li>File-&gt;Setting-&gt;Plugins，打开搜索Zelezny，选择<strong>Android ButterKnife Plugins</strong>下载，重启AS可用。</li>
<li><p>也可以选择本地安装。先到该项目的地址，下载jar包。<br><a href="https://github.com/avast/android-butterknife-zelezny">传送门</a><br><img src="/2018/09/13/ButterKnife%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/zelezny.png" alt="jar包下载"><br>然后还在上边那个Plugins页，点击Install plugins from disk…<br><img src="/2018/09/13/ButterKnife%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/插件安装.png" alt="本地导入"><br>然后重启。。。</p>
</li>
<li><p>使用<br><img src="https://raw.githubusercontent.com/avast/android-butterknife-zelezny/master/img/zelezny_animated.gif" alt="官方的使用演示"><br><strong>注意：将光标移动到R.layout上操作</strong></p>
</li>
<li>有人说该插件只支持butterknife:7.0.1，可以试试将8.8.1切换到7.0.1的重新集成，应该可以使用Generate butterknife菜单功能，再切换回8.8.1版本，zelezny就可以正常使用了。</li>
</ul>
<p>PPs：其实讲道理，我也不能正常使用，AS重启以后插件没安装上，两种安装方式都不能成功，大概可能还是版本的原因…但因为该插件口碑很好，所以还是介绍一下…</p>
<p>参考文章：<br><a href="https://www.zhihu.com/question/31951875">https://www.zhihu.com/question/31951875</a></p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>秘籍帖</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>修改deepin启动内核参数</title>
    <url>/2018/12/20/Deepin(Ubuntu)%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>晚上修改了deepin的启动项。<br>虽然还不知道为什么amd64版本就可以使用，但是先照一个帖子修改了启动项。我觉得没问题。但是还是记录一下修改过程以及一些细节<br><a id="more"></a></p>
<p>首先防止崩溃我把配置文件原件复制下来了<br>然后打开/boot/grub/grub.cfg，赫然大字：not edit this file<br>没事大神帖子撑腰，大不了重装嘛..</p>
<p>然后发现了，，这里面几乎是完全定义了grup的所有内容，包括文字图片主题等待时间（注释说这个文件是由其他两个配置文件自动生成的）<br>根据仅有的英文水平（介绍+翻译）看懂一些</p>
<p>首先有个GRUB_DEFAULT=0，默认启动项，这个值为0就是默认启动第一个，为1默认启动第二个</p>
<p>然后是启动菜单，好几个系统内核赫然在列，也包括advanced option的选项称之为submenu，其下面就是两个deepin内核了。我的是  </p>
<ul>
<li>Deepin 15.8 GNU/Linux, with Linux 4.15.0-29deepin-generic</li>
<li>Deepin 15.8 GNU/Linux, with Linux 4.9.0-deepin13-amd64</li>
</ul>
<p>对的下面那个能用..<br>然后我就粗暴的（小心翼翼）的把这个启动项【描述（如下）】整个复制到了第一项上面（前面设定了默认启动首项）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menuentry <span class="string">&#x27;Deepin 15.8 GNU/Linux, with Linux 4.9.0-deepin13-amd64（这里改名字）&#x27;</span> --class deepin --class gnu-linux --class gnu --class os <span class="variable">$menuentry_id_option</span> <span class="string">&#x27;gnulinux-4.9.0-deepin13-amd64-advanced-f35aea66-7d3d-46a8-8ad9-ac8abf142a40&#x27;</span> &#123;</span><br><span class="line">		load_video</span><br><span class="line">		insmod gzio</span><br><span class="line">		<span class="keyword">if</span> [ x<span class="variable">$grub_platform</span> = xxen ]; <span class="keyword">then</span> insmod xzio; insmod lzopio; <span class="keyword">fi</span></span><br><span class="line">		insmod part_gpt</span><br><span class="line">		insmod ext2</span><br><span class="line">		<span class="built_in">set</span> root=<span class="string">&#x27;hd0,gpt9&#x27;</span></span><br><span class="line">		<span class="keyword">if</span> [ x<span class="variable">$feature_platform_search_hint</span> = xy ]; <span class="keyword">then</span></span><br><span class="line">		  search --no-floppy --fs-uuid --<span class="built_in">set</span>=root --hint-bios=hd0,gpt9 --hint-efi=hd0,gpt9 --hint-baremetal=ahci0,gpt9  f35aea66-7d3d-46a8-8ad9-ac8abf142a40</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		  search --no-floppy --fs-uuid --<span class="built_in">set</span>=root f35aea66-7d3d-46a8-8ad9-ac8abf142a40</span><br><span class="line">		<span class="keyword">fi</span></span><br><span class="line">		linux	/boot/vmlinuz-4.9.0-deepin13-amd64 root=UUID=f35aea66-7d3d-46a8-8ad9-ac8abf142a40 ro  splash quiet DEEPIN_GFXMODE=<span class="variable">$DEEPIN_GFXMODE</span></span><br><span class="line">		initrd	/boot/initrd.img-4.9.0-deepin13-amd64</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>听说描述最后两行是启动内核，看了一下，确实：第一项Deepin 15.8 GNU/Linux的内核为Linux 4.15.0-29deepin-generic。<br>所以我想以后看不顺眼了可以把原第一项给删了。<br>最后改了一下名（位置如上），改为Deepin 15.8 GNU/Linux -amd64</p>
<p>关闭以后更新配置文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo update-grub</span><br><span class="line">  Generating grub configuration file ...</span><br><span class="line">  Found theme: &#x2F;boot&#x2F;grub&#x2F;themes&#x2F;deepin&#x2F;theme.txt</span><br><span class="line">  Found background image: &#x2F;boot&#x2F;grub&#x2F;themes&#x2F;deepin&#x2F;background.png</span><br><span class="line">  Found linux image: &#x2F;boot&#x2F;vmlinuz-4.15.0-29deepin-generic</span><br><span class="line">  Found initrd image: &#x2F;boot&#x2F;initrd.img-4.15.0-29deepin-generic</span><br><span class="line">  Found linux image: &#x2F;boot&#x2F;vmlinuz-4.9.0-deepin13-amd64</span><br><span class="line">  Found initrd image: &#x2F;boot&#x2F;initrd.img-4.9.0-deepin13-amd64</span><br><span class="line">  Found deepin image: &#x2F;boot&#x2F;deepin&#x2F;vmlinuz-4.14.13</span><br><span class="line">  Found initrd image: &#x2F;boot&#x2F;deepin&#x2F;initrd.img-4.14.13</span><br><span class="line">  Found Windows Boot Manager on &#x2F;dev&#x2F;sda1@&#x2F;EFI&#x2F;Microsoft&#x2F;Boot&#x2F;bootmgfw.efi</span><br><span class="line">  Found Ubuntu 18.04.1 LTS (18.04) on &#x2F;dev&#x2F;sda8</span><br><span class="line">  Adding boot menu entry for EFI firmware configuration</span><br><span class="line">  done</span><br></pre></td></tr></table></figure><br>完成，现在我要重启了，希望一切正常。。</p>
<hr>
<p>好的一切正常？？完全没有变化。打开grub.cfg文件一看，咦难道我刚刚忘了保存，恢复原样。<br>看了原帖，大神已经说的很清楚了呀，这个文件是根据另外两文件生成，改这个没有用的，update-grub反而是更新了该文件，所以复原了。<br>好吧只能改原文件了。是/etc/default/grub，和/etc/grub.d下的一系列文件</p>
<table>
<thead>
<tr>
<th>/etc/grub.d</th>
</tr>
</thead>
<tbody>
<tr>
<td>00_header</td>
<td>配置初始的显示项目，如默认选项，时间限制等，一般由/etc/default/grub导入，一般不需要配置</td>
</tr>
<tr>
<td>05_debian_theme</td>
<td>配置引导画面，文字颜色等主题</td>
</tr>
<tr>
<td>10_linux</td>
<td>定位当前操作系统使用中的root设备内核的位置,包含deepin 启动项和advanced里面的启动项</td>
</tr>
<tr>
<td>15_linux_bar</td>
<td>救援模式的启动项</td>
</tr>
<tr>
<td>20_linux_xen</td>
<td>虚拟机监视器的东西，（暂时不知有什么用</td>
</tr>
<tr>
<td>30_uefi-firmware</td>
<td>“system setup” 的启动项</td>
</tr>
<tr>
<td>35_os-prober</td>
<td>windows的启动项一般在这个里面</td>
</tr>
<tr>
<td>40_custom</td>
<td>用来加入用户自定义的启动项，将会在执行update-grub时更新至grub.cfg中</td>
</tr>
<tr>
<td>41_custom</td>
<td>判断custom.cfg此配置文件是否存在，如果存在就加载它</td>
</tr>
</tbody>
</table>
<p>前面的数字是对文件排列执行的顺序进行排序，可进行更改，比如你想把windows启动项调到第一个，就把35_os-prober前面那个数字改成5到10的数字，比如06~09.<br>（快没电了直接摘）</p>
<p>好的成功了。（虽然由于计算失误）<br>接下来就是想办法吧它挪到第一个（好看…）</p>
<p>我猜测，这个新添加的启动项应该就是<strong>40_custom</strong>，所以把它改为9_custom。看起来没有成功。原来那次改完没有update就没电了。于是改为7_custom，update。成了。别忘了把启动项改为0。</p>
<hr>
<h2 id="结束总结："><a href="#结束总结：" class="headerlink" title="结束总结："></a>结束总结：</h2><p>完美满足了我的需求！</p>
<hr>
<h2 id="以下为补充："><a href="#以下为补充：" class="headerlink" title="以下为补充："></a>以下为补充：</h2><ol>
<li>root 告诉内核根分区设备</li>
<li>ro 表示在设备启动时为read-only，如果是rw表示read-write</li>
<li>splash 表示开机画面</li>
<li>quiet 示在启动过程中只有重要信息显示，类似硬件自检的消息不回显示</li>
<li>single 以单用户模式登录，一般用于修复系统，比如忘记密码</li>
<li>一些内核相关的命令<ul>
<li>查看本机的内核<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ uname -r</span><br></pre></td></tr></table></figure></li>
<li>显示可以安装的内核<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ apt-cache search linux</span><br></pre></td></tr></table></figure></li>
<li>安装内核  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install -y linux-headers-version-generic linux-image-version-generic linux-image-extra-version-generic</span><br></pre></td></tr></table></figure></li>
<li>查看系统中已经安装的内核  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ dpkg -l|grep linux-image</span><br></pre></td></tr></table></figure></li>
<li>卸载无用的内核  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get purge xxxxx</span><br></pre></td></tr></table></figure>
以及一位同道中人对重装失败换内核的心得总结，果然外国友人看得明白，我也弄懂了大概怎么回事：<blockquote>
<p>当15.5出现并且在升级之后，我注意到系统可以在启动时登录到登录屏幕并且无法加载桌面或登录后出现的任何GUI。由于升级后（非全新安装），以前版本附带的内核仍然驻留在系统上，我尝试使用GRUB上的高级选项启动笔记本电脑（现在使用Deepin 15.5）和旧内核（附带15.4）菜单。选择以前的内核Linux 4.9.0-deepin13-amd64有用。所以<strong>新的15.5现在可以运行，但只有15.4附带的内核</strong>。</p>
<p>当15.6和15.7出局时也是如此。唯一有效的内核是与Deppin 15.4 一样的旧Linux 4.9.0-deepin13-amd64。这意味着Deepin打包的新内核目前无法在这些笔记本电脑上运行。</p>
<p>这意味着如果我碰巧重新安装Deepin OS 15.5,15.6或当前的15.7，这些内核包装的是15.4中加载的内核以外的新内核，笔记本电脑甚至都无法启动。</p>
<p>如果我要安装Deepin 15.7，那么首先我<strong>必须安装15.4并升级到15.7，这样我才能保留并使用15.4附带的内核。换句话说，只有Deepin 15.4可以在这些机器上进行全新安装</strong>。</p>
<p>在其他机器上复制这些安装最终使所有安装工作正常，15.5,15.6和15.7与更新的内核一起提供。</p>
<p>奖励：我还观察到，在15.4（工作正常）时，<strong>Deepin桌面环境（dde）的任何升级</strong> 都会使机器处于与安装15.5,15.6和15.7时相同的状态。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>至于为什么新内核不能用，原因大概是：更新完内核之后，我的 <strong>Nvidia独显驱动和内核无法一起工作</strong>，导致无法进入桌面</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>技能帖</tag>
        <tag>Deepin</tag>
      </tags>
  </entry>
  <entry>
    <title>Deepin文件系统变成只读</title>
    <url>/2018/12/01/Deepin%EF%BC%88Ubuntu%EF%BC%89%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%98%E6%88%90%E5%8F%AA%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="解决linux文件系统变成只读"><a href="#解决linux文件系统变成只读" class="headerlink" title="解决linux文件系统变成只读"></a>解决linux文件系统变成只读</h2><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>今天进入Deepin，如往常一般打开Android Studio。突然弹出提示框，说是log而文件夹有问题。还以为是as的问题，后来才发现，是文件夹变成只读的了无法操作。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>Google后发现原来是挂载分区出了问题。这种问题有时候可以用重启解决。但我重启无果，另寻他法。<br>运行mount，查看分区结构<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mount</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;dev&#x2F;sda1 on &#x2F;boot&#x2F;efi type vfat (rw)</span><br><span class="line">  &#x2F;dev&#x2F;sda8 on &#x2F;media&#x2F;UserName&#x2F;407fe087 type ext4 (rw)</span><br><span class="line">  &#x2F;dev&#x2F;sda7 on &#x2F;media&#x2F;UserName&#x2F;Others type fuseblk (ro)</span><br><span class="line">  &#x2F;dev&#x2F;sda6 on &#x2F;media&#x2F;UserName&#x2F;File type fuseblk (ro)</span><br><span class="line">  &#x2F;dev&#x2F;sda5 on &#x2F;media&#x2F;UserName&#x2F;Software type fuseblk (ro)</span><br><span class="line">  &#x2F;dev&#x2F;sda3 on &#x2F;media&#x2F;UserName&#x2F;Windows type fuseblk (ro)</span><br><span class="line">  &#x2F;dev&#x2F;fuse on &#x2F;run&#x2F;user&#x2F;1000&#x2F;doc type fuse (rw)</span><br></pre></td></tr></table></figure><br>发现除系统盘以外其他几个盘都是只读模式(ro)，重新挂载一下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># umount &#x2F;dev&#x2F;sda3</span><br><span class="line"># mount &#x2F;dev&#x2F;sda3 &#x2F;media&#x2F;UserName&#x2F;Windows</span><br></pre></td></tr></table></figure><br>这里我是失败了但是灵光一闪突然想起好像Windows的非正常关机或是电源选项开启了快速启动，会导致文件系统的读写异常。<br>记得好像早晨用PS做完图后，笔记本电源耗尽关机了，充上电以后有直接开的Deepin。于是我重启，进入windows，果然还保留着早晨的工作界面。<br>再进入Deepin，一切恢复正常！</p>
<p>看到这里可能感觉到被骗了。其实想说是也许文件系统的错误是windows非正常关闭导致的，不用急着修改挂载分区啥的。<br>如果是其它问题可以看看下边的两篇博客，也许能找到答案。</p>
<hr>
<p>参考博客：<br><a href="https://www.linuxidc.com/Linux/2010-04/25749.htm">修复了Ubuntu 9.10诡异的变成了只读文件系统的错误</a><br><a href="http://www.wuwenhui.cn/2513.html">解决Linux文件系统变成只读的方法</a></p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title>Fragment入门实战收获</title>
    <url>/2018/06/10/Fragment%E5%AE%9E%E6%88%98%E6%94%B6%E8%8E%B7/</url>
    <content><![CDATA[<p>今天又是写了一个下午的bug。<br>这一次是要用Fragment实现如下界面，并且还要同时兼容手机和平板。抽象逻辑实在复杂（其实还好，只是我发现自己写的和书里的不同然后被吓回去了），我这样的菜狗挣扎了一会，还是得照着书敲了，确实有很多需要我学习的东西，所以这回就直接放代码，学习一下大佬的代码和逻辑。  </p>
<a id="more"></a>
<p>MainActivity.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>News.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">News</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>NewsContentActivity.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsContentActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">actionStart</span><span class="params">(Context context, String newsTitle, String newsContent)</span></span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(context, NewsContentActivity.class);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;news_title&quot;</span>, newsTitle);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;news_content&quot;</span>, newsContent);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.news_content);</span><br><span class="line">        String newsTitle = getIntent().getStringExtra(<span class="string">&quot;news_title&quot;</span>);</span><br><span class="line">        String newsContent = getIntent().getStringExtra(<span class="string">&quot;news_content&quot;</span>);</span><br><span class="line">        NewsContentFragment newsContentFragment = (NewsContentFragment) getSupportFragmentManager().findFragmentById(R.id.news_content_fragment);</span><br><span class="line">        newsContentFragment.refresh(newsTitle, newsContent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>NewsContentFragment.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.app.Fragment;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsContentFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> View view;</span><br><span class="line">    TextView newsTitleText;</span><br><span class="line">    TextView newsContentText;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        view = inflater.inflate(R.layout.news_content_frag, container, <span class="keyword">false</span>);</span><br><span class="line">        newsTitleText = (TextView) view.findViewById(R.id.news_title);</span><br><span class="line">        newsContentText = (TextView) view.findViewById(R.id.news_content);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(String newsTitle, String newsContent)</span> </span>&#123;</span><br><span class="line">        View visibilityLayout = view.findViewById(R.id.visibility_layout);</span><br><span class="line">        visibilityLayout.setVisibility(View.VISIBLE);</span><br><span class="line"></span><br><span class="line">        newsTitleText.setText(newsTitle);</span><br><span class="line">        newsContentText.setText(newsContent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>NewsTitleFragment.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.app.Fragment;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.widget.LinearLayoutManager;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.widget.RecyclerView;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsTitleFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isTwoPane;</span><br><span class="line">    <span class="keyword">private</span> List&lt;News&gt; list = <span class="keyword">new</span> ArrayList&lt;News&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle saveIntanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        View view = inflater.inflate(R.layout.news_title_frag, container, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.news_title_recycler_view);</span><br><span class="line">        LinearLayoutManager manager = <span class="keyword">new</span> LinearLayoutManager(getActivity());</span><br><span class="line">        recyclerView.setLayoutManager(manager);</span><br><span class="line">        initList();</span><br><span class="line">        NewsAdapter newsAdapter = <span class="keyword">new</span> NewsAdapter(list);</span><br><span class="line">        recyclerView.setAdapter(newsAdapter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        News news;</span><br><span class="line">        String title;</span><br><span class="line">        String content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span> ;i++)&#123;</span><br><span class="line">            title = <span class="string">&quot;title&quot;</span>+i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>;j++)&#123;</span><br><span class="line">                content = content + <span class="string">&quot;title&quot;</span> + i + <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            news = <span class="keyword">new</span> News();</span><br><span class="line">            news.setTitle(title);</span><br><span class="line">            news.setContent(content);</span><br><span class="line">            list.add(news);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle saveInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(saveInstanceState);</span><br><span class="line">        <span class="keyword">if</span>(getActivity().findViewById(R.id.news_content_layout) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            isTwoPane = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            isTwoPane = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NewsAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">NewsAdapter</span>.<span class="title">ViewHolder</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;News&gt; list;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NewsAdapter</span><span class="params">(List&lt;News&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.list = list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">            TextView newsTitleText;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                <span class="keyword">super</span>(v);</span><br><span class="line">                newsTitleText = (TextView) v.findViewById(R.id.news_title);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span></span>&#123;</span><br><span class="line">            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.news_item, parent, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">final</span> ViewHolder holder = <span class="keyword">new</span> ViewHolder(view);</span><br><span class="line">            view.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                    News news = list.get(holder.getAdapterPosition());</span><br><span class="line">                    <span class="keyword">if</span>(isTwoPane)&#123;</span><br><span class="line">                        NewsContentFragment newsContentFragment = (NewsContentFragment) getFragmentManager().findFragmentById(R.id.news_content_fragment);</span><br><span class="line">                        newsContentFragment.refresh(news.getTitle(), news.getContent());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        NewsContentActivity.actionStart(getActivity(), news.getTitle(), news.getContent());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">            News news = list.get(position);</span><br><span class="line">            holder.newsTitleText.setText(news.getTitle());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>layout/activity_main.xml<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/news_title_layout&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">   &lt;fragment</span><br><span class="line">       android:id=&quot;@+id/news_title_fragment&quot;</span><br><span class="line">       android:name=&quot;com.example.fragmentbestpractice.NewsTitleFragment&quot;</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;match_parent&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><br>layout-large/activity_main.xml<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;fragment</span><br><span class="line">        android:id=&quot;@+id/news_title_fragment&quot;</span><br><span class="line">        android:name=&quot;com.example.fragmentbestpractice.NewsTitleFragment&quot;</span><br><span class="line">        android:layout_weight=&quot;1&quot;</span><br><span class="line">        android:layout_width=&quot;0dp&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">        android:id=&quot;@+id/news_content_layout&quot;</span><br><span class="line">        android:layout_weight=&quot;3&quot;</span><br><span class="line">        android:layout_width=&quot;0dp&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">        &lt;fragment</span><br><span class="line">            android:id=&quot;@+id/news_content_fragment&quot;</span><br><span class="line">            android:name=&quot;com.example.fragmentbestpractice.NewsContentFragment&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><br>news_content_frag.xml<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">&lt;RelativeLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:orientation=&quot;vertical&quot;</span><br><span class="line">        android:id=&quot;@+id/visibility_layout&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line"></span><br><span class="line">        android:visibility=&quot;invisible&quot;&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:text=&quot;Title&quot;</span><br><span class="line">            android:padding=&quot;10dp&quot;</span><br><span class="line">            android:textSize=&quot;20sp&quot;</span><br><span class="line">            android:gravity=&quot;center&quot;</span><br><span class="line">            android:id=&quot;@+id/news_title&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line">        &lt;View</span><br><span class="line">            android:background=&quot;#000&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;1dp&quot; /&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:text=&quot;Content&quot;</span><br><span class="line">            android:textSize=&quot;18sp&quot;</span><br><span class="line">            android:id=&quot;@+id/news_content&quot;</span><br><span class="line">            android:layout_weight=&quot;1&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    &lt;View</span><br><span class="line">        android:layout_width=&quot;1dp&quot;</span><br><span class="line">        android:layout_alignParentLeft=&quot;true&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><br>news_content.xml<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;fragment</span><br><span class="line">        android:id=&quot;@+id/news_content_fragment&quot;</span><br><span class="line">        android:name=&quot;com.example.fragmentbestpractice.NewsContentFragment&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><br>news_item.xml<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/news_title&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    <span class="attr">android:maxLines</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:ellipsize</span>=<span class="string">&quot;end&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">&quot;18sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingLeft</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingRight</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingTop</span>=<span class="string">&quot;15dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingBottom</span>=<span class="string">&quot;15dp&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><br>news_title_frag.xml<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.RecyclerView</span><br><span class="line">        android:id=&quot;@+id/news_title_recycler_view&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>首先这一次的MainActivity中没有任何东西，就只有onCreate和setContentView方法，那代码到底怎么运行。  </p>
<ul>
<li>我发现，在activity_main中，用fragment的name属性指定了一个fragment包类NewsTitleFragment，而且基本所有的行为都是在这个类中执行调用的。  </li>
<li>在这个NewTitleFragment中，首先是调用onCreateView加载了我们打开应用时看到的第一个界面，即一个title列表。  </li>
<li>接着随即在onCreateView方法中数据进行初始化，这里就和我一般的操作不同，一般我在Fragment类中，只加载碎片布局，而初始化列表数据，更是放在MainActivity中。而且还在这里定义并调用了列表的Adapter配适器。  </li>
<li>这说明其实安卓代码的定义和调用其实都十分灵活，应该根据每次开发时的情况去定义，使代码更加简洁易懂就行。<br>onActivityCreated中通过是否能找到new_content_layout标签来判断当前是单页界面还是双页界面。  </li>
</ul>
<hr>
<ul>
<li>在Fragment类中加载fragment布局的时候，曾遇到个bug，是我在抄书的时候出了差错。就是加载布局后，我想顺便通过findViewById获取界面里的控件实例，但是一直报NullPoint空指针错误，想了半天一直觉得是id没对上。。<br>想了一个下午无果，给大佬学长一看，一眼就断定是findViewById获取不到，看了一下，原来我的View是个类，而我应该用的是view的实例，才能获取到view里的控件，而刚好在同类的另一个方法中我加载了一个view，于是将view定义为类变量，用获取到的布局给view初始化。果然问题就解决了！  </li>
</ul>
<p>woc果然是大佬，我还是太太菜了。  </p>
<ul>
<li>然后还有一个问题，就是Activity如果是自己定义的话，将不会自动在ActivityManifest注册（废话）。而一个活动如果没有被注册，则它在调用时将会报错，报错信息也很明显了，就是Do you 确定 Activity has been define? 然而四级都还没过的我并没有注意到这个问题，后来才被一个大佬解决，当然，大佬六级已经过了。。。  </li>
</ul>
<hr>
<p>然后我觉得很该学习的，是他的逻辑，也就是他将一个需求抽象出来的思路。下面梳理一遍。  </p>
<ul>
<li>启动程序以后，MainActivity加载一个activity_main，而主活动有两个，根据设备的具体参数决定加载普通的活动界面还是large界面。<br>main_1中由一个fragment指定加载了NewsTitleFragment；main_2中第一个fragment也加载了NewsTitleFragment，第二个布局是FrameLayout，里边也有一个fragment，指定加载的是NewsContentFragment类。  </li>
<li>NewsTitleFragment类首先是初始化了一下初始的数据。然后在onActivityCreated方法中getActivity().findViewById(R.id.news_content_layout)判断当前是否分屏，保证该判断在活动被启动时能被调用。方法中先用getActivity()获得当前view实例，再尝试用findViewById在该view中找到news_content_layout，这是large_main中那个FrameLayout的id名。也就是说，如果find到的对象是null，那么意味着当前应为分屏状态的界面。如果能够找到（即!null），则为单界面。判断结果赋给一个全局的布尔变量。  </li>
<li>由于在列表布局的必要方法onCreateViewHolder中，通过inflate获得了列表子项的布局，所以顺便就在这里设置了子项的点击事件：如果是分屏的话，就在右边加载Content；否则就启动另一个活动，显示content内容。这里就用到了刚刚的全局布尔变量。</li>
</ul>
<p>基本就是这样子。</p>
<p>这样仔细地剖析，也是希望自己能在一次一次的学习中，get到一些大佬的抽象思维和一个需求功能落地的过程，让自己更快的体会开发的过程吧。。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技能帖</tag>
      </tags>
  </entry>
  <entry>
    <title>关于gradle 4.1 与 Android-Studio 3.1.2更新的一些变化（坑）</title>
    <url>/2018/06/17/Gradle%E5%8D%87%E7%BA%A7%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
    <content><![CDATA[<h1 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h1><p>其实这是前几天一直困扰我的问题，design中只有一个界面而没有任何控件，连标题栏都没有。<br>csdn上有人说把systle里边改为Base.Theme，改完控件可以显示了，但是仍然没有标题栏，我知道这一定不是问题根源。本来已经放弃了。<br><img src="/2018/06/17/Gradle%E5%8D%87%E7%BA%A7%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/design问题描述.png" alt="design问题描述">但是今天有了些转机。</p>
<a id="more"></a>
<h1 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h1><p>今天无意中打开app：build.gradle看，发现和记忆中的有些不同。对比design的project发现，确实不一样了。突然想起之前由于logcat不显示的问题重装过Android-Studio，并且更新了Gradle。大概就是这个问题。<br>且design的报错是<br><img src="/2018/06/17/Gradle%E5%8D%87%E7%BA%A7%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/design报错提示.png" alt="design报错提示"></p>
<blockquote>
<p>The following classes could not be instantiated:</p>
<ul>
<li>android.support.v7.widget.ActionBarContainer (Open Class, Show Exception, Clear Cache)</li>
<li>android.support.v7.widget.ActionBarContextView (Open Class, Show Exception, Clear Cache)</li>
<li>android.support.v7.app.WindowDecorActionBar (Open Class, Show Exception, Clear Cache)<br>Tip: Use View.isInEditMode() in your custom views to skip code or show sample data when shown in the IDE.</li>
</ul>
</blockquote>
<p>即support.v7.widget下有些包的导入出了问题。<br>在<a href="https://stackoverflow.com/questions/50736578/after-updating-android-studio-to-3-1-2-i-get-failed-to-load-appcompat-actionb?noredirect=1&amp;lq=1">stackOverFlow</a>果然查到了。</p>
<blockquote>
<p>我有同样的问题。我搜索了很多，我终于发现appcompat-v7:28.0.0-alpha3有一些与Android Studio的“设计视图”部分有关的错误。<br>因此，我建议改com.android.support:appcompat-v7:28.0.0-alpha3到com.android.support:appcompat-v7:28.0.0-alpha1版本，那么一切都OK。<br>当然你应该可以上网下载 com.android.support:appcompat-v7:28.0.0-alpha1</p>
</blockquote>
<p>不！这一段原文我也能读懂，我要放原话[一个刚在四级扑街的渣渣最后的倔强]：</p>
<blockquote>
<p>I had the same problem. I searched so much and I finally found that appcompat-v7:28.0.0-alpha3 has some bug with “Design View” part of Android Studio.<br>So I suggest to change com.android.support:appcompat-v7:28.0.0-alpha3 to com.android.support:appcompat-v7:28.0.0-alpha1 version and then everything is OK.<br>Of course you should have internet access to download com.android.support:appcompat-v7:28.0.0-alpha1</p>
</blockquote>
<p>也就是说是appcompat-v7:28.0.0-alpha3出了问题。。这和我想的是差不多的。。</p>
<h1 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h1><ul>
<li>我直接将以前的gradle复制进来，Sync后立竿见影。</li>
<li>StackOverFlow有人提出了，只要将<strong>alpha-3</strong>改为<strong>alph-1</strong>也能解决问题，实测有效！</li>
</ul>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><ul>
<li>Gradle升级后，打开一个旧的project都会提示你是否updata gradle，可以通过选择Don’t remind me in this prioject，则不会再提示更新gradle。</li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技能帖</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM</title>
    <url>/2019/07/17/JVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK JRE JVM"></a>JDK JRE JVM</h1><p><img src="/2019/07/17/JVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/JDKandJRE.png" alt="JDK JRE JVM关系图"></p>
<a id="more"></a>
<p>先简单过一遍历史，这算是常识。<br>1991.4 Oak语言：java前身，目标：电子产品上的程序架构<br>1996.1 JDK1.0发布。纯解释执行的Jvm实现<br>1997.2 发布JDK1.1。JDBC，内部类，反射等出现<br>1998.12 JDK1.2发布。拆分三个体系：J2SE（桌面开发），J2EE（企业级开发），J2ME（面向移动端）。集合类等出现。首次内置JIT编译器<br>1999.4 HotSpot虚拟机发布。JDK1.3以后成为Sun JDK的默认虚拟机<br>2002.2 JDK1.4发布。引入异常类，正则，NIO等<br>2004.9 JDK1.5发布，引入泛型，动态注解，枚举，可变长参数，foreach等。最后一个支持Win9x的Java版本<br>2006.12 JDK1.6发布。J2EE等更名。JVM内部机制较大修改。同年Java大会Sun宣布Java开源，OpenJDK建立<br>2009.4 Oracle收购Sun公司</p>
<p>Dalvik VM Google实现的android核心组成部分。<br><a href="https://juejin.im/post/59b7fa8cf265da066d3323bb">DalvikVM与JVM的区别</a></p>
<h2 id="对象头-18-11"><a href="#对象头-18-11" class="headerlink" title="对象头(18-11)"></a>对象头(18-11)</h2><p>对象在内存中的存储布局分为 对象头，实例数据，对齐填充。<br>对象头包括 对象自身运行时数据（Mark World 64Bits），类型指针。对象指向其类的元数据的指针（用于确定该对象是哪个类的实例）。<br>锁标志位，也保存在对象头中。锁标志位与是否偏向锁 对应到唯一的锁状态</p>
<div class="note default">
            <p>未完待续…</p>
          </div>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>秘籍帖</tag>
      </tags>
  </entry>
  <entry>
    <title>Java可变参数</title>
    <url>/2018/05/21/Java%E4%B8%AD%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Java可变参数"><a href="#Java可变参数" class="headerlink" title="Java可变参数"></a>Java可变参数</h1><p>在java方法定义是可以使用个数不确定的参数，对于同一个方法可以用不同个数的参数调用。</p>
<h3 id="1-定义方法"><a href="#1-定义方法" class="headerlink" title="1. 定义方法"></a>1. 定义方法</h3><p><strong>…表示可变参数</strong><br>在有可变参数的方法中可以把参数当做数组使用。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环输出所有参数值</span></span><br><span class="line">print(String... args)&#123;</span><br><span class="line">    <span class="keyword">for</span>(String temp:args)&#123;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//补充：这里temp为String，args为对象</span></span><br></pre></td></tr></table></figure><br>实际上，变长参数会<em>被转型为一个数组</em>传入方法体。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String...varargs)</span></span>&#123;&#125;</span><br><span class="line">foo(<span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>, <span class="string">&quot;arg3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述过程和下面的调用是等价的</span></span><br><span class="line">foo(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>, <span class="string">&quot;arg3&quot;</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-调用"><a href="#2-调用" class="headerlink" title="2. 调用"></a>2. 调用</h3><p>可变长参数方法调用</p>
<ul>
<li>既可以不带参数，也可以带多个参数。</li>
<li>在调用带有可变参数的方法时，JVM优先调用固定参数的方法</li>
<li>若要调用的方法可以和两个可变参数匹配，则编译出现错误，因为JVM不知道该调用哪一个方法<h3 id="3-一个方法只能带一个可变参数，且必须作为其参数表的最后一个参数"><a href="#3-一个方法只能带一个可变参数，且必须作为其参数表的最后一个参数" class="headerlink" title="3. 一个方法只能带一个可变参数，且必须作为其参数表的最后一个参数"></a>3. 一个方法只能带一个可变参数，且必须作为其参数表的最后一个参数</h3></li>
</ul>
<hr>
<h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><ul>
<li>避免带有可变长参数的方法重载，编译器虽然知道怎么调用，但人容易陷入调用的陷阱及误区</li>
<li>别让null值和空值威胁到变长方法。为了说明null值的调用，重新给出一个例子：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarArgsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String test, Integer... is)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String test,String...args )</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VarArgsTest1 test = <span class="keyword">new</span> VarArgsTest();</span><br><span class="line">        test.print(<span class="string">&quot;hello&quot;</span>);            <span class="comment">//编译不通过</span></span><br><span class="line">        test.print(<span class="string">&quot;hello&quot;</span>, <span class="keyword">null</span>);      <span class="comment">//编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
两个方法都匹配，所以编译不通过。同时还有个非常不好的编码习惯，即<em>调用者隐藏了实参类型</em>，这是非常危险的，不仅仅调用者需要“猜测”该调用哪个方法，而且被调用者也可能产生内部逻辑混乱的情况。故应在调用前加：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strs = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarArgsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = <span class="keyword">new</span> Son();</span><br><span class="line">        base.print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        son.print(<span class="string">&quot;hello&quot;</span>);     <span class="comment">//编译不通过    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里边要注意的主要是方法覆写的要点</li>
</ul>
<ol>
<li>重写方法不能降低访问权限；</li>
<li>参数列表必须与被重写方法相同（包括显示形式）；</li>
<li>返回类型必须与被重写方法的相同或是其子类；</li>
<li>重写方法不能抛出新的异常，或者超过了父类范围的异常，只可以抛出更少、更有限的异常，或者不抛出异常。</li>
</ol>
<h3 id="一个需要注意的问题"><a href="#一个需要注意的问题" class="headerlink" title="一个需要注意的问题"></a>一个需要注意的问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarArgsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">(String s, String... ss)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ss.length; i++) &#123;</span><br><span class="line">            System.out.println(ss[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        m1(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        m1(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        m1(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译结果：</span></span><br><span class="line"><span class="comment">//bbb</span></span><br></pre></td></tr></table></figure>
<p>参考文章：<a href="http://www.cnblogs.com/lanxuezaipiao/p/3190673.html">Java中可变长参数的使用及注意事项</a></p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>秘籍帖</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA类定义之初始代码块</title>
    <url>/2018/05/19/Java%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
    <content><![CDATA[<p>  今天学长出了一道题，我发现我竟然对初始化代码块的存在一无所知。<br>初始化代码块（initialization block）是初始化数据域的第三种机制（前两种分别是构造器和声明时赋值）。只要构造类的对象，只写代码块就会被自动执行，不需要调用。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> name;</span><br><span class="line"><span class="comment">//object initilization block</span></span><br><span class="line">    &#123;</span><br><span class="line">         id = <span class="number">4</span>;</span><br><span class="line">         name++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>构造类时，先运行初始化代码块，再运行构造方法的主体。<br>注：<br>为了避免循环定义，不要读取初始化以后的域<br>Java是按照编程顺序来执行实例变量初始化器和实例初始化器中的代码的，并且不允许顺序靠前的实例代码块初始化在其后面定义的实例变量<br>对静态域进行初始化，可直接提供一个初始化值（private ststic int id = 1;），也可通过静态的初始化块进行初始化。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>再类第一次加载时，即进行静态域的初始化。且所有的静态初始化语句与静态初始化块都将按类的定义顺序执行。<br>注：<br>JVM加载类时执行（仅执行一次）</p>
<ol>
<li>随类的加载执行，只执行一次，并优先于主函数main。</li>
<li>静态代码初始化块是给类初始化，构造代码块是给对象初始化。</li>
<li>静态代码块中的变量是局部变量，等同于普通函数中的局部变量。</li>
<li>一个类中可以有多个静态代码块。</li>
</ol>
<p>当涉及到继承时，按照如下顺序执行：<br>执行父类的静态代码块，初始化父类静态成员变量<br>执行子类的静态代码块，初始化子类静态成员变量<br>执行父类的构造代码块，执行父类的构造函数，初始化父类普通成员变量<br>执行子类的构造代码块，执行子类的构造函数，初始化子类普通成员变量</p>
<p><img src="/2018/05/19/Java%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A3%E7%A0%81%E5%9D%97/Java初始化顺序.png" alt="hexo image"></p>
<p>I.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#123;</span><br><span class="line">	b = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> b;</span><br></pre></td></tr></table></figure><br>II.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b; </span><br><span class="line">&#123; </span><br><span class="line">    b = a; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure><br>I能够通过编译，但II报错：非法前引用。</p>
<blockquote>
<p>静态代码块只能对其之前的数据进行访问，对于其之后的数据可以赋值但不能被访问。<br>—《深入理解Java虚拟机》</p>
</blockquote>
<p>总结：<br>调用构造器的具体处理步骤：</p>
<ol>
<li>所有数据域被初始化为默认值（0，false，null）</li>
<li>按类声明的顺序执行 与初始化语句和初始化</li>
<li>若构造器首行调用了第二个构造器，则执行第二个构造器主体</li>
<li>执行构造器</li>
</ol>
<p>一个Java对象的创建过程往往包括类初始化和类实例化两个阶段，类实例化包括实例变量初始化、实例代码块初始化以及构造函数初始化</p>
<p>实际上，如果我们对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后，构造函数本身的代码之前</p>
<p>实例化对象时，JVM首先会检查相关类型是否已经加载并初始化，如果没有，则JVM立即进行加载并调用类构造器完成类的初始化。在类初始化过程中或初始化完毕后，根据具体情况才会去对类进行实例化。</p>
<p>其实一般也很少使用到初始化块，因为都是在构造方法内完成类的初始化。初始化块一般适用于加载类时加载本地库。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>秘籍帖</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安装与环境变量配置</title>
    <url>/2018/07/20/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>  好像很是奇怪，学了半年多的Java，到今天还写这么一篇关于安装Java的博客。因为最近重装系统，从头开始配置Java，所以发现了一些问题和收获。。<br>  开始学习Java的时候，遇到的第一个拦路虎就是Java的环境变量配置，因为Java的一次编写，到处运行的特性，它需要在虚拟机上运行，为了在任意文件处可以使用Java，就有了环境变量配置的问题。但我当时安装的时候一切顺畅，并没有遇到麻烦，但后来总是在帮小伙伴安装的时候出现差错。当我重装完系统时安装java，竟也遇到问题。查阅博客得以解决以后，决定自己写一篇指南纪念（祭奠）一下。</p>
  <a id="more"></a>
<h2 id="JAVA下载"><a href="#JAVA下载" class="headerlink" title="JAVA下载"></a>JAVA下载</h2><p>首先是下载Java的JDK。JDK(Java Development Kit)，是编写Java程序的程序员使用的软件，里边有各种程序开发需要的库。<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk10-downloads-4416644.html">官网下载传送门</a><br>下载后安装。一般来说，JDK安装时会附带安装JRE。JRE(Java Runtime Environment)，是运行Java程序所需的软件（环境），包含虚拟机但不含编译器。如果安装缺失JRE，也可以通过官网下载。<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre10-downloads-4417026.html">JRE传送门</a>。<br>安装过程的话，看不懂的一路Next也是没有问题的啦。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>安装完成后，就开始惊心动魄的环境变量配置了。<br>其实也没有什么，只要一步一步照做，是不会有问题的啦。<br>首先右键“此电脑”，打开属性，选择进入左侧菜单栏里的“高级系统设置”，打开环境变量。<br><img src="/2018/07/20/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/环境变量.png" alt="环境变量"><br>需要在系统变量中设置三项个变量，分别为JAVA_HOME,PATH,CLASSPATH。如果有的变量名已存在，则点击编辑；如果不存在，则点击新建。<br>变量参数如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME : JDK安装路径</span><br><span class="line">CLASSPATH : .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;		&#x2F;&#x2F;注意最前边的.</span><br><span class="line">PATH : %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</span><br></pre></td></tr></table></figure><br>这是许多教程都会给到的方法。然而此时按照一般的检验方式，即在控制台输入java，javac，java -version，但输入javac会报错。这也是我后来帮小伙伴安装常常出现的问题。<br>Google半天终于找到缘由。在命令行里运行的<strong>java.exe</strong>来自JRE，它会找到系统上JRE的具体路径去运行Java程序。而<strong>javac.exe</strong>不是JRE的一部分，而是JDK的。JDK的安装程序不会自动将自己的bin目录配置到PATH环境变量上，所以在命令行里也看不到它。要解决这个问题需要把JDK的bin目录配置到PATH环境变量里，或者在命令行用JDK的全路径去访问javac.exe。而在 Windows10 中，因为系统的限制，path 变量只可以使用 JDK 的绝对路径。%JAVA_HOME% 会无法识别，导致配置失败。<br>综上，path的变量值应为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PATH : JDK&#x2F;bin绝对路径</span><br></pre></td></tr></table></figure><br>以我自己的配置举例，就是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME : D:\Java\jdk-10.0.2\</span><br><span class="line">CLASSPATH : .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;		&#x2F;&#x2F;注意最前边的.</span><br><span class="line">PATH : D:\Java\jdk-10.0.2\bin</span><br></pre></td></tr></table></figure></p>
<h2 id="检验成果"><a href="#检验成果" class="headerlink" title="检验成果"></a>检验成果</h2><p>这时在控制台输入java，javac，java -version即可看到返回。</p>
<p>PS：</p>
<ul>
<li>JAVA_HOME：该环境变量的值就是 Java 所在的目录，一些 Java 版的软件和一些 Java 的工具需要用到该变量，设置 PATH 和 CLASSPATH 的时候，也可以使用该变量以方便设置。</li>
<li>PATH：指定一个路径列表，用于搜索可执行文件的。执行一个可执行文件时，如果该文件不能在当前路径下找到，则依次寻找 PATH 中的每一个路径，直至找到。或者找完 PATH 中的路径也不能找到，则报错。Java 的编译命令 (javac)，执行命令 (java) 和一些工具命令 (javadoc, jdb 等) 都在其安装路径下的 bin 目录中。因此我们应该将该路径添加到 PATH 变量中。</li>
<li>CLASSPATH：也指定一个路径列表，是用于搜索 Java 编译或者运行时需要用到的类。在 CLASSPATH 列表中除了可以包含路径外，还可以包含 .jar 文件。Java 查找类时会把这个 .jar 文件当作一个目录来进行查找。通常，我们需要把 JDK 安装路径下的 jre/lib/rt.jar (Linux: jre/lib/rt.jar) 包含在 CLASSPATH 中。</li>
</ul>
<p>PATH 和 CLASSPATH 都指定路径列表，列表中的各项 (即各个路径) 之间使用分隔符分隔。在 Windows 下，分隔符是分号 (;)，而在 Linux 下，分隔符是冒号 (:)。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>技能帖</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Socket使用</title>
    <url>/2018/11/10/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="JAVA-WEB网络编程"><a href="#JAVA-WEB网络编程" class="headerlink" title="JAVA WEB网络编程"></a>JAVA WEB网络编程</h2><h3 id="Socket套接字"><a href="#Socket套接字" class="headerlink" title="Socket套接字"></a>Socket套接字</h3><ul>
<li>socket使用TCP实现计算机间的通信机制。client创建一个socket，并尝试连接服务器的socket。</li>
<li><p>客户与服务端可以使用对Socket的读写来实现通信。</p>
<p>ServerSocket类为服务器提供一种监听客户端并建立连接的机制。<br>具体实现：</p>
<ol>
<li>Server端实例化一个ServerSocket，表示通过服务器上的端口通信。</li>
<li>ServerSocket.accept()方法将一直等待直到客户端连接上服务器的端口</li>
<li>Client端实例化Socket，指定服务器地址与端口号请求连接。</li>
<li>Socket的构造函数尝试连接。通信被建立后，则可通过Socket通信，否则抛出IOException</li>
<li>Server端accept()返回一个scoket引用，该socket连接到Client的Socket<a id="more"></a>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TCPServer.class</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">6066</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(<span class="string">&quot;等待远程连接，端口号为：&quot;</span> + server.getLocalPort() + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            System.out.println(client.getRemoteSocketAddress());</span><br><span class="line">            <span class="comment">//获取输入流</span></span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">            System.out.println(in.readUTF());</span><br><span class="line">            DataOutputStream out = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">            out.writeUTF(<span class="string">&quot;欢迎连接：&quot;</span> + server.getLocalSocketAddress() + <span class="string">&quot;\nGoodbye!&quot;</span>);</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SocketTimeoutException s)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Time out !&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TCPClient.class</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String serverName = localhost;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">6066</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;连接到主机：&quot;</span> + serverName + <span class="string">&quot;，端口号：&quot;</span> + port);</span><br><span class="line">            <span class="comment">//尝试连接服务器</span></span><br><span class="line">            Socket client = <span class="keyword">new</span> Socket(serverName, port);</span><br><span class="line">            <span class="comment">//获取套接字连接的远程地址</span></span><br><span class="line">            System.out.println(<span class="string">&quot;远程主机地址：&quot;</span> + client.getRemoteSocketAddress());</span><br><span class="line">            <span class="comment">//获取套接字的输出流</span></span><br><span class="line">            OutputStream outToServer = client.getOutputStream();</span><br><span class="line"></span><br><span class="line">            DataOutputStream out = <span class="keyword">new</span> DataOutputStream(outToServer);</span><br><span class="line">            out.writeUTF(<span class="string">&quot;Hello from &quot;</span> + client.getLocalSocketAddress());</span><br><span class="line">            <span class="comment">//获取套接字输入流</span></span><br><span class="line">            InputStream inFromServer = client.getInputStream();</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(inFromServer);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器响应： &quot;</span> + in.readUTF());</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Tip : 利用输入输出流传输数据，DataOutputStream(字节流)，并且以UTF编码写入。</p>
<h3 id="Web服务器实现"><a href="#Web服务器实现" class="headerlink" title="Web服务器实现"></a>Web服务器实现</h3><ul>
<li>Web服务器，使用http与客户端通信。主要包括HttpServer类，Request类，Response类</li>
<li>应用程序的入口在HttpServer类中，main()方法创建一个HttpServer实例，然后调用其await()方法，在指定端口上等待HTTP请求，对其进行处理，然后发送响应信息回客户端，在接收到关闭命令前，它会保持等待状态。</li>
<li>该Web服务器仅发送位于指定目录的静态资源的请求，如html文件和图像，它也可以将传入到的http请求字节流显示到控制台，但不发送任何头信息到浏览器，如日期或者cookies等。</li>
<li>我只简单实现了服务器的代码，请求与响应部分先直接交给浏览器处理。</li>
</ul>
<p><strong>TIP:</strong><br>返回客户端时服务器发送的数据:</p>
<ol>
<li>HTTP/1.0 200 Document Follows(writeBytes)</li>
<li>Content-Type:image/jpg(writeBytes)   (解析方式)</li>
<li>Content-Lenght(writeBytes)</li>
<li>文件 -&gt; write(文件的字节形式, 0, Lenght)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HTTPServer.class</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket server;</span><br><span class="line">    <span class="keyword">private</span> String[] msg;</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Server</span><span class="params">(<span class="keyword">int</span> post)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        server = <span class="keyword">new</span> ServerSocket(post);</span><br><span class="line">        msg = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Socket client = server.accept();</span><br><span class="line">                BufferedReader read = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">                msg = read.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(msg[<span class="number">0</span>].equals(<span class="string">&quot;GET&quot;</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(msg[<span class="number">1</span>].startsWith(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">                        fileName = msg[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">                    File f = <span class="keyword">new</span> File(fileName);</span><br><span class="line">                    <span class="keyword">int</span> lenght = (<span class="keyword">int</span>) f.length();</span><br><span class="line">                    <span class="keyword">byte</span>[] fileInByte = <span class="keyword">new</span> <span class="keyword">byte</span>[lenght];</span><br><span class="line">                    FileInputStream fin = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">                    fin.read(fileInByte);</span><br><span class="line"></span><br><span class="line">                    DataOutputStream outputToClient = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">                    outputToClient.writeBytes(<span class="string">&quot;HTTP/1.0 200 Document Follows\r\n&quot;</span>);</span><br><span class="line">                    outputToClient.writeBytes(<span class="string">&quot;Content-Type:image/jpg\r\n&quot;</span>);</span><br><span class="line">                    outputToClient.writeBytes(<span class="string">&quot;Content-Lenght:&quot;</span> + lenght + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">                    outputToClient.writeBytes(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">                    outputToClient.write(fileInByte, <span class="number">0</span>, lenght);</span><br><span class="line">                    outputToClient.close();</span><br><span class="line">                &#125;<span class="keyword">else</span> System.out.println(<span class="string">&quot;bad request message&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SocketTimeoutException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Time out ...&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;bad requset file &quot;</span> + fileName);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Server(<span class="number">6066</span>).start();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Network</tag>
        <tag>秘籍帖</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的itchat接口</title>
    <url>/2018/01/17/Python%E7%9A%84itchat%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="关于itchat的学习体验"><a href="#关于itchat的学习体验" class="headerlink" title="关于itchat的学习体验"></a>关于itchat的学习体验</h1><h3 id="pip模块下载"><a href="#pip模块下载" class="headerlink" title="pip模块下载"></a>pip模块下载</h3><p>在控制台窗口用pip install下载，并用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure><br>查看，已载入。在python-Shell下始终无法导入。后来改用命令pip3 install安装成功。pip3 list已载入，再导入，成功！</p>
<h3 id="itchat初体验"><a href="#itchat初体验" class="headerlink" title="itchat初体验"></a>itchat初体验</h3><ol>
<li><strong>获取网页登陆的二维码</strong><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itchat.auto_login( )</span><br></pre></td></tr></table></figure></li>
<li><strong>发信息</strong><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itchat.send</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itchat.search_friends(name = <span class="string">u&quot;备注名称或昵称&quot;</span>)  <span class="comment">#获取对方的全部信息（列表）</span></span><br></pre></td></tr></table></figure>
列表中只有一个元素，是一个字典，引索”UserName”得到微信号，是一长串十六进制的数字<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itchat.send(msg = <span class="string">&#x27; &#x27;</span>,toUserName = user)</span><br></pre></td></tr></table></figure>
下图是失败与成功的返回信息。</li>
</ol>
<hr>
<p>2018/1/19/13：26</p>
<p>今天开始系统了解itchat。这应该是官方的文档：<br><a href="http://itchat.readthedocs.io/zh/latest/">itchat官方文档</a></p>
<p>-入门实例</p>
<blockquote>
<p>itchat.auto_login( ) 登陆账号<br>itchat.logout( ) 注销账号<br>itchat.run( ) 运行<br>user = itchat.search_friends(name = “昵称或备注”) 获取对方账户信息<br>itchat.send(msg = “文本信息”, toUserName = “对方微信号”)<br>user[0].send(msg = “文本信息”) </p>
</blockquote>
<p>PS:</p>
<p>微信移动端只要退出登录（断网），其网页版PC版e也会被强制登出，故需要<strong>保持移动端登录状态</strong></p>
<p>有一些微信账户天生不能给自己发信息，可以改用filehelper</p>
<p>用对方发给自己的文本消息回复<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"><span class="meta">@itchat.msg_register(<span class="params">itchat.content.TEXT</span>) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text_reply</span>(<span class="params">msg</span>):</span> </span><br><span class="line">	<span class="keyword">return</span> msg.text</span><br><span class="line">itchat.auto_login()</span><br><span class="line">itchat.run()</span><br></pre></td></tr></table></figure><br>itchat.search_friend 方法搜索用户</p>
<ul>
<li>仅获取自己的用户信息:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itchat.search_friends()</span><br></pre></td></tr></table></figure></li>
<li>获取特定UserName的用户信息:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itchat.search_friends(userName=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>获取备注、微信号、昵称中的任何一项等于name键值的用户:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itchat.search_friends(name=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>获取备注、微信号、昵称分别等于相应键值的用户:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itchat.search_friends(wechatAccount=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>前两项功能可以一同使用:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itchat.search_friends(name=<span class="string">&#x27; &#x27;</span>, wechatAccount=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="（正式开始预警-分割线。。。）"><a href="#（正式开始预警-分割线。。。）" class="headerlink" title="（正式开始预警+分割线。。。）"></a>（正式开始预警+分割线。。。）</h2><p><strong>-登陆配置</strong></p>
<p>itchat提供了登陆状态暂存，关闭程序后一定时间内不需要扫码即可登录。由于目前微信网页版提供上一次登录的微信号不扫码直接手机确认登陆，所以如果开启登陆状态暂存将会自动使用这一功能。该方法会生成一个静态文件itchat.pkl，用于存储登陆的状态。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itchat.auto_login(hotReload = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>-Send方法回复<br>返回Bool值。对象为空则发给自己。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">send(msg=<span class="string">&#x27;Text Message&#x27;</span>, toUserName=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><br><strong>请确保该程序目录下存在：gz.gif 以及 xlsx.xlsx</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itchat.send(<span class="string">&#x27;@img@%s&#x27;</span> % <span class="string">&#x27;gz.gif&#x27;</span>)                  <span class="comment">#识别为发送图片</span></span><br><span class="line">itchat.send(<span class="string">&#x27;@fil@%s&#x27;</span> % <span class="string">&#x27;xlsx.xlsx&#x27;</span>)               <span class="comment">#识别为发送文件</span></span><br><span class="line">itchat.send(<span class="string">&#x27;@vid@%s&#x27;</span> % <span class="string">&#x27;demo.mp4&#x27;</span>)               <span class="comment">#识别为发送视频</span></span><br></pre></td></tr></table></figure><br>其他：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">send_msg(msg=<span class="string">&#x27;Text Message&#x27;</span>, toUserName=<span class="literal">None</span>)</span><br><span class="line">send_file(fileDir, toUserName=<span class="literal">None</span>)</span><br><span class="line">send_img(fileDir, toUserName=<span class="literal">None</span>)</span><br><span class="line">send_video(fileDir, toUserName=<span class="literal">None</span>)        <span class="comment">#需保证发送视频为一实质的mp4文件</span></span><br></pre></td></tr></table></figure></p>
<h4 id="注册消息方法"><a href="#注册消息方法" class="headerlink" title="注册消息方法"></a>注册消息方法</h4><p>itchat将根据接收到的消息类型寻找对应的已经注册的方法。如果一个消息类型没有对应的注册方法，该消息将会被舍弃。在运行过程当中也可以动态注册方法，注册方式与结果不变。</p>
<h5 id="不带具体对象注册，将注册为普通消息的回复方法"><a href="#不带具体对象注册，将注册为普通消息的回复方法" class="headerlink" title="不带具体对象注册，将注册为普通消息的回复方法"></a>不带具体对象注册，将注册为普通消息的回复方法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_reply</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I received: %s&#x27;</span> % msg[<span class="string">&#x27;Text&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h4 id="带对象参数注册，对应消息对象将调用该方法"><a href="#带对象参数注册，对应消息对象将调用该方法" class="headerlink" title="带对象参数注册，对应消息对象将调用该方法"></a>带对象参数注册，对应消息对象将调用该方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@itchat.msg_register(<span class="params">TEXT, isFriendChat=<span class="literal">True</span>, isGroupChat=<span class="literal">True</span>, isMpChat=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text_reply</span>(<span class="params">msg</span>):</span></span><br><span class="line">    msg.user.send(<span class="string">&#x27;%s: %s&#x27;</span> % (msg.<span class="built_in">type</span>, msg.text)) </span><br></pre></td></tr></table></figure>
<h4 id="注册消息的优先级"><a href="#注册消息的优先级" class="headerlink" title="注册消息的优先级"></a>注册消息的优先级</h4><p>优先级分别为：<strong>后注册消息先于先注册消息，带参数消息先于不带参数消息</strong>。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itchat.content <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">@itchat.msg_register </span></span><br><span class="line"><span class="meta">@itchat.msg_register(<span class="params">TEXT</span>)</span></span><br></pre></td></tr></table></figure><br>看了这个例子，我也终于懂了itchat处理信息的机制。<strong>@msg_register方法注册信息类型</strong>，其后定义函数来表明处理该类信息的方法。<br>尝试打印<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">search_friends( )</span><br><span class="line"><span class="built_in">list</span> = itchat.search_friends()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><br>得到一个字典，保存自己的用户信息</p>
<blockquote>
<p>MemberList     UserName    City    DisplayName     PYQuanPin   RemarkPYInitial     Province    KeyWord     RemarkName   PYInitial   EncryChatRoomId    Alias   Signature   NickName    RemarkPYQuanPin     HeadImgUrl  UniFriend   Sex     AppAccountFlag      VerifyFlag      EncryChatRoomId   HideInputBarFlag       AttrStatus      SnsFlag    MemberCount      OwnerUin    ContactFlag   Uin   StarFriend      Statues    WebWxPluginSwitch      HeadImgFlag </p>
</blockquote>
<p>写了一段代码实现一个简单的微信自动回复。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"><span class="keyword">from</span> itchat.content <span class="keyword">import</span> *</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="meta">@itchat.msg_register(<span class="params">PICTURE, RECORDING</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_reply</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    print(<span class="string">&quot;收到一条信息。。(第%d条)&quot;</span> % count)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我还看不懂图片语音，发文字谢谢。。&quot;</span></span><br><span class="line"><span class="meta">@itchat.msg_register(<span class="params">TEXT</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text_reply</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    print(<span class="string">&quot;收到一条信息。。(第%d条)&quot;</span> % count)</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;嗯？&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> count == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;说什么大点声。。&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> count == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;好吧我是机器人。。&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> count &gt;= <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我看到了马上回复你哈。。&quot;</span></span><br><span class="line">itchat.auto_login(hotReload = <span class="literal">True</span>)</span><br><span class="line">itchat.run()</span><br></pre></td></tr></table></figure><br>但是前边那个注册信息不带参数却能处理所有信息的语句我还是无法实现。</p>
<p>关于动态注册，并不能完全看懂，文档中有一个例子。</p>
<h4 id="微信消息内容"><a href="#微信消息内容" class="headerlink" title="微信消息内容"></a>微信消息内容</h4><p>这一页都挺重要的，特别贴出来。<a href="http://itchat.readthedocs.io/zh/latest/intro/messages/">消息内容 - itchat</a></p>
<h4 id="命令行二维码显示"><a href="#命令行二维码显示" class="headerlink" title="命令行二维码显示"></a>命令行二维码显示</h4><p>通过以下命令可以在登陆的时候使用命令行显示二维码：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itchat.auto_login(enableCmdQR=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>部分系统可能字幅宽度有出入，可以通过将，故赋enableCmdQR赋值为特定的倍数进行调整：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如部分的linux系统，块字符的宽度为一个字符（正常应为两字符）值为2</span></span><br><span class="line">itchat.auto_login(enableCmdQR=<span class="number">2</span>) </span><br><span class="line"><span class="comment"># 默认控制台背景色为暗色（黑色），若背景色为浅色（白色），可以将enableCmdQR赋值为负值：</span></span><br><span class="line">itchat.auto_login(enableCmdQR=-<span class="number">1</span>) </span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>秘籍帖</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView常用封装</title>
    <url>/2018/11/01/Recycler%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<h1 id="RecyclerView常用的一种封装方式"><a href="#RecyclerView常用的一种封装方式" class="headerlink" title="RecyclerView常用的一种封装方式"></a>RecyclerView常用的一种封装方式</h1><p>本文介绍一种RecyclerView的常用封装形式，最后效果是调用时只需定义回调方法getItemViewType()与onCreateViewHolder(View, int)<br>因为在使用时一般会有特殊的item填充的需求，以及不同使用场景会使用不同的ViewHolder进行填充的需求。<br>先上代码…</p>
<h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">RecyclerAdapter</span>.<span class="title">ViewHolder</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span>, <span class="title">AdapterCallBack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AdapterListener&lt;T&gt; mListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造模块</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecyclerAdapter</span><span class="params">(List&lt;T&gt; dataList, AdapterListener&lt;T&gt; listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mListener = listener;</span><br><span class="line">        <span class="keyword">this</span>.list = dataList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecyclerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecyclerAdapter</span><span class="params">(AdapterListener&lt;T&gt; listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> ArrayList&lt;T&gt;(), listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ViewId获取模块</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * 复写默认布局返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> position 坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回布局id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getItemViewType(position, list.get(position));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取布局类型(id)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> position 坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data     当前数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 布局id，用于创建ViewHolder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position, T data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ViewHolder创建模块</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * 创建一个ViewHolder</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> viewType Item的类型，约定为XML的id（简化操作）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ViewHolder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewHolder&lt;T&gt; <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        LayoutInflater inflater = LayoutInflater.from(parent.getContext());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将一个xml id为ViewType的文件初始化为一个root View</span></span><br><span class="line">        View root = inflater.inflate(viewType, parent, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 通过子类必须实现的方法得到一个ViewHolder</span></span><br><span class="line">        ViewHolder&lt;T&gt; holder = onCreateViewHolder(root, viewType);</span><br><span class="line">        <span class="comment">// 对Holder的事件操作实际上是对view进行操作。对一个ViewHolder设置事件实际上还是对其根布局设置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置View的Tag为Holder进行双向绑定</span></span><br><span class="line">        root.setTag(R.id.tag_recycler_holder, holder);</span><br><span class="line">        <span class="comment">// 设置事件点击</span></span><br><span class="line">        root.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行界面注解绑定</span></span><br><span class="line">        holder.unBinder = ButterKnife.bind(holder, root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定callback</span></span><br><span class="line">        holder.callBack = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当得到一个新的ViewHolder</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent   根布局</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> viewType 布局类型，即xml的id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ViewHolder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ViewHolder&lt;T&gt; <span class="title">onCreateViewHolder</span><span class="params">(View parent, <span class="keyword">int</span> viewType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holder数据绑定模块</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> holder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> position</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder&lt;T&gt; holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到需要绑定的方法</span></span><br><span class="line">        T data = list.get(position);</span><br><span class="line">        <span class="comment">// 触发Holder的绑定方法</span></span><br><span class="line">        holder.bind(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作数据列表模块</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        list.add(data);</span><br><span class="line">        notifyItemInserted(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入一堆数据并通知这段集合更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datalist data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T... datalist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (datalist != <span class="keyword">null</span> &amp;&amp; datalist.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> startPos = list.size();</span><br><span class="line">            Collections.addAll(list, datalist);</span><br><span class="line">            notifyItemRangeInserted(startPos, datalist.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入一堆数据并通知这段集合更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datalist data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Collection&lt;T&gt; datalist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (datalist != <span class="keyword">null</span> &amp;&amp; datalist.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> startPos = list.size();</span><br><span class="line">            list.addAll(datalist);</span><br><span class="line">            notifyItemRangeInserted(startPos, datalist.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.clear();</span><br><span class="line">        notifyDataSetChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 替换为一个新的集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataList 新集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replace</span><span class="params">(Collection&lt;T&gt; dataList)</span> </span>&#123;</span><br><span class="line">        list.clear();</span><br><span class="line">        <span class="keyword">if</span> (dataList == <span class="keyword">null</span> || dataList.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        list.addAll(dataList);</span><br><span class="line">        <span class="comment">// 全部更新</span></span><br><span class="line">        notifyDataSetChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点击设置及监听模块</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        ViewHolder holder = (ViewHolder) v.getTag(R.id.tag_recycler_holder);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 得到ViewHolder当前对应适配器中的坐标</span></span><br><span class="line">            <span class="keyword">int</span> pos = holder.getAdapterPosition();</span><br><span class="line">            <span class="comment">// 回调</span></span><br><span class="line">            <span class="keyword">this</span>.mListener.onItemClick(holder, list.get(pos));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置适配器点击监听</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> adapterListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setListener</span><span class="params">(AdapterListener&lt;T&gt; adapterListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mListener = adapterListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdapterListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 当cell点击时触发</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(RecyclerAdapter.ViewHolder holder, T data)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onItemLongClick</span><span class="params">(RecyclerAdapter.ViewHolder holder, T data)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加上abstract使子类实现时至少实现其中一个方法</span></span><br><span class="line"><span class="comment">     * 抽象方法不需要子类实现所有抽象方法，而接口要求实现所有方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterListenerImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">AdapterListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(ViewHolder holder, T data)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemLongClick</span><span class="params">(ViewHolder holder, T data)</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ViewHolder的封装类</span></span><br><span class="line"><span class="comment">     * 使用时需继承该类并实现onBind()方法完成控件与数据的绑定</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Unbinder unBinder;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> AdapterCallBack&lt;T&gt; callBack;</span><br><span class="line">        <span class="keyword">protected</span> T data;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用于绑定数据的触发</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> data 数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            onBind(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通知整个列表更新的消息</span></span><br><span class="line"><span class="comment">         * 通过ViewHolder反向调用此方法进行更新</span></span><br><span class="line"><span class="comment">         * Holder自己对自己对应的data进行更新的</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updataData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.callBack != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.callBack.updata(data, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 触发帮顶数据时的回调。必须复写</span></span><br><span class="line"><span class="comment">         * 界面刷新赋值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> data 绑定的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onBind</span><span class="params">(T data)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码看着有点多，因此分为几个模块，分开理解就都很简单了。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>其实注释已经写得很清楚了但还是具体分析一下。</p>
<h4 id="构造模块"><a href="#构造模块" class="headerlink" title="构造模块"></a>构造模块</h4><ul>
<li>传入AdapterListener监听器实例</li>
</ul>
<h4 id="ViewType模块"><a href="#ViewType模块" class="headerlink" title="ViewType模块"></a>ViewType模块</h4><ul>
<li>getItemViewType() 复写默认布局返回，布局id用于创建ViewHolder，返回调用同名抽象方法（不同参）</li>
</ul>
<h4 id="创建ViewHolder模块"><a href="#创建ViewHolder模块" class="headerlink" title="创建ViewHolder模块"></a>创建ViewHolder模块</h4><ul>
<li>onCreateViewHolder 创建一个ViewHolder<ul>
<li>调用类内定义的同名抽象方法onCreateViewHolder()获取holder，参数为View而不是ViewGroup</li>
<li>View与Holder进行双向绑定（两种实现方式）<ul>
<li>view.setTag()实现（key为一个特定id）</li>
<li>Butterknife.bind()实现，并将返回的UnBinder保存在Holder中备用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数据绑定模块"><a href="#数据绑定模块" class="headerlink" title="数据绑定模块"></a>数据绑定模块</h4><ul>
<li>onBindViewHolder<ul>
<li>触发 <strong>Holder.bind()</strong> 方法（有点会回调的意思）</li>
</ul>
</li>
</ul>
<h4 id="点击响应以及监听模块"><a href="#点击响应以及监听模块" class="headerlink" title="点击响应以及监听模块"></a>点击响应以及监听模块</h4><ul>
<li>AdapterListener 点击监听接口<ul>
<li>由onClick()方法回调接口方法</li>
<li>增加一个接口实现类，就可以只实现接口中的其中一个方法，而不需要全部实现</li>
</ul>
</li>
</ul>
<h4 id="ViewHolder抽象类模块"><a href="#ViewHolder抽象类模块" class="headerlink" title="ViewHolder抽象类模块"></a>ViewHolder抽象类模块</h4><ul>
<li>ViewHolder 内部类定义<ul>
<li>以前的写法是在构造方法中绑定控件，但是这里是定义了一个bind(T)进行绑定<ul>
<li>bind()中调用abstract onBind()方法</li>
</ul>
</li>
<li>需要通知整个列表更新的消息，定义方法updataData()<ul>
<li>updataData方法回调了AdapterCallBack（外部定义）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数据操作模块"><a href="#数据操作模块" class="headerlink" title="数据操作模块"></a>数据操作模块</h4><ul>
<li>add() &amp; clear() &amp; replace() &amp; 以及必须实现的 getItemCount()<ul>
<li>对数据源进行修改，注意刷新列表更新</li>
</ul>
</li>
</ul>
<hr>
<p>对RecyclerView使用的一种常用封装，为了开发是能够便捷简明的调用而又不影响其复用。</p>
<p>以上是对这种封装形式的学习理解和分析，理解有所偏差或其他看法欢迎大佬交流，共同进步～</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技能帖</tag>
      </tags>
  </entry>
  <entry>
    <title>View事件分发机制理解</title>
    <url>/2019/10/24/View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近重新学习了一遍View的事件分发机制。其实之前已经把这一块差不多看过，不好理解，几遍下来，好像都了解了，但总觉得差点意思。<br>发现其实之前看《艺术探索》十分痛苦，主要是看得不够仔细，以及书中概念和知识点较多，没有一个大题的认识，很容易被绕进去。现在水平有些长进了，找了几本书和博客，终于有了更加深刻的理解。<br><a id="more"></a></p>
<h1 id="事件分发的基本流程"><a href="#事件分发的基本流程" class="headerlink" title="事件分发的基本流程"></a>事件分发的基本流程</h1><p>首先要知道View的触摸事件，主要有ACTION_UP，ACTION_MOVE，ACTION_DOWN。以一个ACTION_DOWN事件开始到一个ACTION_UP事件的一系列事件作为一个事件序列。</p>
<p>View的事件分发，主要有三个流程，dispatchTouchEvent（分发），onInterceptTouchEvent（拦截），onTouchEvent（消费处理）。<br>Activity，View，ViewGroup处理事件的能力不全相同。<br>其中<strong>Activity和View只有dispatchTouchEvent()和onTouchEvent()</strong>方法，<strong>ViewGroup只有dispatchTouchEvent，onInterceptTouchEvent</strong>方法。</p>
<p>当一个点击事件产生后，事件传递顺序是：<strong>Activity -&gt; Window -&gt; View</strong>。<br>一个Activity收到一个事件后，触发dispatchTouchEvent()。该方法伪代码如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">fun <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(getWindows.superDispatchTouchEvent(ev))</span><br><span class="line">		reuturn <span class="keyword">true</span></span><br><span class="line">	<span class="keyword">return</span> onTouchEvent(ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先将事件交由Window进行分发。</p>
<ul>
<li>如果返回true，则事件循环结束，因为说明点击事件已被处理。</li>
<li>如果返回false，则触发Activity的onTouchEvent()</li>
</ul>
<p>当一个ViewGroup接收到一个事件，则触发dispatchTouchEvent()。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">fun <span class="title">dispatchTouchEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(onInterceptTouchEvent())</span><br><span class="line">		<span class="keyword">return</span> onTouchEvent()</span><br><span class="line">		<span class="comment">// 实际上是调用了 super.dispatchTouchEvent()，在其中调用view.onTouchEvent()</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> child.dispatchTouchEvent()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>先根据当前的业务逻辑，调用onInterceptTouchEvent()判断是否拦截该事件<ul>
<li>onIntercept()返回false，即不拦截，则调用子View的dispatchTouchEvent()，将当前事件传递到子View处理。</li>
<li>onIntercept()返回true，即为拦截，则调用onTouchEvent()消费该事件。</li>
</ul>
</li>
<li>onTouchEvnet()或child.dispatchTouchEvent()返回false，说明该ViewGroup或子View没有消费该事件，则将该事件传回父容器，<em>即调用父容器的onTouchEvent()方法</em>。<br>如果所有的View都不消费该事件，则Activity的onTouchEvent()会被调用。</li>
</ul>
<p>当一个View决定处理某个事件，其处理机制大抵如下。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">fun <span class="title">dispatchTouchEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span>(onTouchListener != <span class="keyword">null</span></span><br><span class="line">		&amp;&amp; onTouchListener.onTouch())</span><br><span class="line">		result = <span class="keyword">true</span></span><br><span class="line">	<span class="keyword">if</span>(!result &amp;&amp; onTouchEvent())</span><br><span class="line">		result = <span class="keyword">true</span></span><br><span class="line">		<span class="comment">// onTouchEvent()中会调用OnClickListener.onClick()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>先判断onTouchListener是否为空，不为空则调用onTouch()方法，onTouch()返回<strong>false</strong>才会调用onTouchEvent()方法。我们一般设置的OnClickListener.onClick()也是在其中被调用。也就是说onClick()方法一般是在事件传递的末端。</p>
<h1 id="源码探究"><a href="#源码探究" class="headerlink" title="源码探究"></a>源码探究</h1><h2 id="Activity对事件的分发"><a href="#Activity对事件的分发" class="headerlink" title="Activity对事件的分发"></a>Activity对事件的分发</h2><p>PhoneWindow是Window的唯一实现类。其中的superDispatchTouchEvent()方法实现，直接将事件传递给了DecorView。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码：PhoneWindows#superDispatchTouchEvent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>通过((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChlidAt(1)可以获取Activity所设置的View，这个mDecor显然就是getWindow().getDecorView()返回的View，而我们通过setContentView所设置的View则是他的一个子View。</p>
</blockquote>
<p>DecorView继承自FrameLayout，且是一个父View，所以事件最终会传递给顶级View，即是setContentView设置的View。</p>
<h2 id="ViewGroup对事件的分发"><a href="#ViewGroup对事件的分发" class="headerlink" title="ViewGroup对事件的分发"></a>ViewGroup对事件的分发</h2><p>当一个ViewGroup决定对点击事件进行拦截时，如果onTouchListener被设置，则调用onTouch()，否则调用onTouchEvent()（此过程与上文介绍的View的处理机制相似）。<strong>也就是说，如果都提供的话，onTouch会屏蔽掉onTouchEvnet()</strong>。<br>这个逻辑其实很好理解：onTouchListener是对触摸的监听，即触摸时候触发的回调；只有不对（普通）触摸做处理时，再进一步判断触摸事件，即点击，手势等。这里注意触摸和触摸事件的区别。</p>
<h3 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check for interception.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">   || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">	    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">	    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    intercepted = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">	<span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">	intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是ViewGroup中关于判断是否拦截事件的部分。</p>
<blockquote>
<p>当事件由ViewGroup的子View成功处理，mFirstTouchTarget会被赋值并指向子View</p>
</blockquote>
<p>这句话总是似懂非懂，简单翻了翻后边的代码，看到后边dispatchTransformedTouchEvent()中，使用super.dispatchTouchEvnet()，<del>我还以为当子View不处理事件时，会调用父View的dispatchTouchEvent()，此时就可以通过该标示得知该事件是否被处理。如果mFirstTouchTarget未被赋值，则直接intercept为true拦截该事件进行处理。</del><br>这段话写完我就产生了自我怀疑。我是在说个啥？？？<br>仔细又看一遍书后，算是明白了，这个操作其实实现的是：<strong>一个事件序列只能被一个View拦截且消耗。即一个元素拦截了某次事件，那么同一个事件序列内的所有事件都会直接被它处理</strong>。当某个View拦截了down事件，则该事件序列的后续事件都由它处理。</p>
<blockquote>
<p>一旦事件由当前ViewGroup拦截，mFirstTouchTarget != null 不成立。那么当UP和MOVE事件到来时，由于(actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)为false，则<strong>onInterceptTouchEvent()不会再被调用</strong>，并且同一序列中的其他事件都默认交由它处理。</p>
</blockquote>
<p>这里还有一种特殊情况，即是FLAG_DISALLOW_INTERCEPT。这个标志位是由requestDisallowIntercept()设置，一般用于禁止ViewGroup拦截除DOWN以外的任何事件。</p>
<ul>
<li>当分发DOWN事件时，会对该标志位进行重置，使得子View设置的标志位失效。所以面对DOWN事件，ViewGroup都会调用onInterceptTouchEvent()进行判断是否拦截</li>
</ul>
<h3 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h3><p>如果当前事件未被拦截，则开始对子View进行分发，即通过一个for循环对所有子View进行遍历。<br>首先判断当前子View是否可以接收到点击事件<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">		|| !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">	ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>canViewReceivePointerEvents()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns true if a child view can receive pointer events.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canViewReceivePointerEvents</span><span class="params">(<span class="meta">@NonNull</span> View child)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE</span><br><span class="line">		|| child.getAnimation() != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法通过判断child是否VISIBLE或者child是否处于播放动画状态。如果child不可见而且不处于动画状态（不是因为动画才在该位置不可见），那么它不是符合事件消费的条件。这样做的目的在于，即是一个child因为动画如位移而不在原来的位置可见，那也可以收到点击事件。这也解释了为什么位移动画（<strong>View动画</strong>）以后，View还可以在原来的位置接收到点击事件的原因。</p>
</li>
<li><p>isTransformedTouchPointInView()<br>判断child是否在点击范围内</p>
</li>
</ul>
<p>如果条件满足，则开始真正对child进行事件传递。主要调用<strong>dispatchTransformedTouchEvent()</strong>方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">            View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Canceling motions is a special case.  We don&#x27;t need to perform any transformations</span></span><br><span class="line">        <span class="comment">// or filtering.  The important part is the action, not the contents.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">        <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            event.setAction(oldAction);</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该方法中先判断了child是否为null</p>
<ul>
<li>如果为null，则调用super.dispatchTouchEvent()，即View.dispatchTouchEvent()，在其中实现对触摸事件进行处理消费。在ViewGroup中对子View进行分发后，如果事件没有被子View消耗，就会调用这个方法并传入null。</li>
<li>如果不为null。则调用child.dispatchTouchEvent()将事件进行分发。如果该方法发返回false，则说明child未消耗，将继续进行事件的分发。如果返回true。则说明child已消耗该事件，mFirstTouchEvent被赋值，跳出对子View的遍历分发。<br>如果没有任何子View对事件进行处理，则ViewGroup会如上所说，调用dispatchTransformtouchvnet()并传入null，从ViewGroup转到View.dispatchTouEvent()，自己对事件进行处理。</li>
</ul>
<h2 id="View对事件的处理"><a href="#View对事件的处理" class="headerlink" title="View对事件的处理"></a>View对事件的处理</h2><p>当事件被分发到某一个View中，此时View可能是一个底层View，也可能是一个ViewGroup，但都作为一个单独的元素，无法在向下传递事件，必须自己在View.dispatchTouchEvent()中，完成对View触摸事件的响应处理。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	......</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>实现逻辑跟上文体现的差不多，先判断是否设置了OnTouchListener，如果OnTouchListener中的onTouch()返回true，则onTouchEvent()不会被调用。<strong>所以OnTouchListener.onTouch()比onTouchEvent()优先级更高，这样做的好处是方便在外界处理点击事件。</strong>因为onTouch()作为一个外部实现的回调方法，与使用者联系会更为紧密。</p>
<h3 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent()"></a>onTouchEvent()</h3><p>可以查看一下onTouchEvent()内部实现。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">	setPressed(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">    <span class="comment">// A disabled view that is clickable still consumes the touch</span></span><br><span class="line">    <span class="comment">// events, it just doesn&#x27;t respond to them.</span></span><br><span class="line">    <span class="keyword">return</span> clickable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该方法一开始是实现对不可用（disabled）View的处理，可以看到不可用的View也可以消耗点击事件，只是不会作出响应。<br>并且以上代码还可以看出，无论View是否可用，只要设置了CLICKABLE或LONG_CLICKABLE，onTouchEvent()都会消耗该事件并返回true。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">	<span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">	    ......</span><br><span class="line">		<span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">		    performClickInternal();</span><br><span class="line">		&#125;</span><br><span class="line">	    mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上代码是对点击事件具体处理逻辑。没怎么看懂。。=_=（关于TOOLTIP，据说android8新添加的跟鼠标悬浮显示有关）</p>
<p>只知道核心代码部分即是触发了<strong>performClick()</strong>方法。在perfromClick()中，如果View设置了OnClickListener，则会调用我们一般设置的onClick()（终于，出现了点击事件中与我们接触最为频繁的）！由此也可见，onClick()方法其实是在事件分发机制中处于最最末端的。</p>
<h1 id="关于滑动冲突解决"><a href="#关于滑动冲突解决" class="headerlink" title="关于滑动冲突解决"></a>关于滑动冲突解决</h1><div class="note default">
            <p>未完待续…</p>
          </div>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技能帖</tag>
      </tags>
  </entry>
  <entry>
    <title>View事件体系之滑动学习心得</title>
    <url>/2019/04/30/View%E6%BB%91%E5%8A%A8%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="最近学习《Android开发艺术探索》的View事件体系，对View有了跟多的理解和心得体会，遂记录，加深理解也便同人交流。"><a href="#最近学习《Android开发艺术探索》的View事件体系，对View有了跟多的理解和心得体会，遂记录，加深理解也便同人交流。" class="headerlink" title="最近学习《Android开发艺术探索》的View事件体系，对View有了跟多的理解和心得体会，遂记录，加深理解也便同人交流。"></a>最近学习《Android开发艺术探索》的View事件体系，对View有了跟多的理解和心得体会，遂记录，加深理解也便同人交流。</h2><p>View一般有三种实现方式，<strong>ScrollTo/ScrollBy实现</strong>，<strong>动画实现</strong>，<strong>改变布局参数实现</strong>。注意其中除了动画以外，其余两种都是非弹性的滑动，即是“瞬移”。</p>
<h2 id="ScrollTo-ScrollBy实现"><a href="#ScrollTo-ScrollBy实现" class="headerlink" title="ScrollTo/ScrollBy实现"></a>ScrollTo/ScrollBy实现</h2><p>这是View内部的两个方法，主要区别就是绝对滑动和相对滑动。即</p>
<blockquote>
<p>ScrollTo()，基于所传递参数的绝对滑动<br>ScrollBy()，基于当前位置的相对滑动  </p>
</blockquote>
<a id="more"></a>
<p>这是书中的原话，但是我一开始却没有理解对“绝对滑动”。所谓相对滑动指的是相对于当前位置的滑动，所谓绝对滑动指的是content在View中的绝对位置，而非我一开始理解的相对于屏幕的绝对位置。关于这一点不理解的话，后边会有一个小例（keng）子。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the scrolled position of your view. This will cause a call to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</span></span><br><span class="line"><span class="comment"> * invalidated.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the x position to scroll to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y the y position to scroll to</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldX = mScrollX;</span><br><span class="line">        <span class="keyword">int</span> oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        invalidateParentCaches();</span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">            postInvalidateOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Move the scrolled position of your view. This will cause a call to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</span></span><br><span class="line"><span class="comment"> * invalidated.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the amount of pixels to scroll by horizontally</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y the amount of pixels to scroll by vertically</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由源码很明显看出，ScrollBy()就是直接调用了ScrollTo()，ScrollTo()中就只是记录了一下当前滑动的坐标然后对View进行了<strong>重绘</strong>（postInvalidateOnAnimation中触发重绘）。且在重绘之前还会调用 <strong>onScrollChanged()</strong> 方法。<br>关于其中mScrollX，和mScrollY属性，直接画了一个示意图方便理解。<br><img src="/2019/04/30/View%E6%BB%91%E5%8A%A8%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/Scroller.jpg" alt="Content-View"></p>
<p>关于ScrollTo方法十分需要注意的一点：<br><strong>ScrollTo()方法只能对View中的Content进行操作移动而不能移动View的位置</strong><br>View中的Content，例如TextView的Content即为文本，ImageView的Content即为Drawable。</p>
<h2 id="动画实现"><a href="#动画实现" class="headerlink" title="动画实现"></a>动画实现</h2><p>这种实现在效果上较于其他两种有所不同，动画可以通过设置移动时间实现弹性滑动的效果。动画在实质上其实是对translationX/translationY进行操作。</p>
<h3 id="View动画"><a href="#View动画" class="headerlink" title="View动画"></a>View动画</h3><p>View动画需要在res下建立anim文件夹，通过xml文件定义动画形式。<br>由于View动画实际上是对View的影像进行操作，因此在使用上有许多需要注意的地方</p>
<ul>
<li>需要指定 <strong>android:fillAfter=”true”</strong>，否则动画完成以后其结果会消失，回到原状。</li>
<li>由于操作的是影像，所以不能真正改变View的宽高。因此动画结束后，<strong>新的位置存在只是一个影像</strong>，View真正的位置其实还在原始位置。这在用户交互上显然是是一个很要命的问题，例如对一个设置了点击事件的Button进行了view动画，将无法在影响上响应点击事件，而是还要 <strong>回到原始位置触发</strong>。</li>
</ul>
<h3 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h3><p>属性动画则是直接在代码中对View进行动画操作。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对translationX进行操作 0-&gt;100</span></span><br><span class="line">ObjectAnimator.ofFloat(tatrgetView,<span class="string">&quot;translationX&quot;</span>, <span class="number">0</span>, <span class="number">100</span>).setDuration(<span class="number">100</span>).start();</span><br></pre></td></tr></table></figure><br>android3.0以前，View动画需要使用nineoldandroids库实现，但其实现的属性动画，实质上还是View动画，因此也具有View动画的缺点。但Android3.0以上的属性动画则可以解决以上的所有问题。</p>
<h4 id="《艺术探索》提供的解决（准确来说是规避）View动画缺点的参考方案"><a href="#《艺术探索》提供的解决（准确来说是规避）View动画缺点的参考方案" class="headerlink" title="《艺术探索》提供的解决（准确来说是规避）View动画缺点的参考方案"></a>《艺术探索》提供的解决（准确来说是规避）View动画缺点的参考方案</h4><p>在终点位置设置一个与原始View外观与点击事件都相同的View，动画结束以后通过visibility显示。</p>
<h2 id="改变布局参数实现"><a href="#改变布局参数实现" class="headerlink" title="改变布局参数实现"></a>改变布局参数实现</h2><p>改变布局参数即设置LayoutParams。一般有两种情形，一是直接设置目标View的LayoutParams（margin）实现滑动，二是改变旁边布局的Layoutparams（width）实现滑动，而实际上View是被“挤开”的。书中也介绍了两种重新设置Layoutparams的方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我一般使用</span></span><br><span class="line">view.setLayoutParams(lp);</span><br><span class="line"><span class="comment">// 涨见识</span></span><br><span class="line">view.requestLayout();</span><br></pre></td></tr></table></figure></p>
<h2 id="一个小坑"><a href="#一个小坑" class="headerlink" title="一个小坑"></a>一个小坑</h2><p>学习了相关知识以后，我决定写一个小demo检验+加深一下学习成果。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">btn_by.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        ObjectAnimator.ofFloat(viewP, <span class="string">&quot;translationX&quot;</span>, <span class="number">0</span>, <span class="number">300</span>).setDuration(<span class="number">1000</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">btn_to.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        viewP.scrollTo(-<span class="number">100</span>, -<span class="number">600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>逻辑十分简单，就是两个View用来滑动，为了体现滑动前后与用户的交互情况，给他们设置了点击事件并通过点击事件让自己滑动。其中viewP指的是两个view（Button）的父布局（LinearLayout），即两个view时viewP的content。<br>一开始一切实现效果都在我的预计之中，但当我将点击代码改为以上代码时，出现了与我想象完全不同的效果<br><img src="/2019/04/30/View%E6%BB%91%E5%8A%A8%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/演示1.gif" alt="演示1"><br>首先btn_to使用ScrollTo()，不应该两次移动到两个不同的位置，其次btn_by并不是按动画中设置的从0位置出发。纠结半天后，设置了背景色，问题就无处遁形了。<br><img src="/2019/04/30/View%E6%BB%91%E5%8A%A8%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/演示2.gif" alt="演示2"><br>可以很明显的发现，btn_by点击以后，动画是作用在整个viewP上的，所以点击btn_to之后，没有移动或者移动到指定位置为右边并没有问题，因为btn_to相对于其父布局来说确实是在指定位置了。<br>虽然这只是一个小乌龙，但提示了我两个问题：</p>
<ul>
<li><strong>只有ScrollTo()方法是作用在content上的</strong>，动画和LayoutParams都能直接作用于View。这一点出问题其间是有意识到的，但我一直以为ScrollTo所谓的绝对滑动指的是绝对于屏幕。这也就是下一点要说的</li>
<li><strong>ScrollTo()所谓的绝对滑动是相对于父布局（也就是调用ScrollTo()的View）而言</strong>，而不是我一开始认为的相对于屏幕的坐标。出了这个问题，再回头去看那个Content-View的图，一切就都很明了了。</li>
</ul>
<p>总结：</p>
<ul>
<li>ScrollTo/ScrollBy方法操作的是View的Content上，而其他两种方式则是直接作用在View上边的。且这种方式不影响内部元素的交互（点击事件）</li>
<li>使用View动画时注意设置fillAfter以“保存”动画结果，注意View动画无法移动实体只能移动影像对交互的影响。因此View动画适用于不需要与用户交互的情况</li>
<li>Android3.0以前实现属性动画需要使用到的nineoldandroids库实质上也是实现了View动画</li>
<li>一些复杂的效果只有动画可以实现</li>
</ul>
<p>Ps：通过对View一些原理上的学习，很大程度上的提升了对View机制的理解，也对很多之前写代码时候使用到的东西理解更加清晰透彻。</p>
<p>知其然，也知其所以然！</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技能帖</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Android Studio标红的解决方法</title>
    <url>/2018/05/26/android_studio%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<blockquote>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>今天打开android studio发现屏幕上星星点点全是标红，一般gradle未build完成会出现这个情况所以我还是很淡定的。但是gradle建立完还是标红，但是run一切正常。仔细查看发现是有几个package导入失败了，原因是未找到。所以只能google。<br>得到以下结果。</p>
</blockquote>
<hr>
<p>首先出现问题的话，肯定要rebuild project、重启andriod studio都先试一遍，甚至重启电脑、从SVN下载重新导入，因为android studio其实还是有些bug。</p>
<a id="more"></a>
<h2 id="Java类标红情况"><a href="#Java类标红情况" class="headerlink" title="Java类标红情况"></a>Java类标红情况</h2><p>其实是build缓存的问题，清除build缓存后即可解决。<br><img src="/2018/05/26/android_studio%E7%9A%84%E5%9D%91/清理build缓存.png" alt="清理build缓存"></p>
<h2 id="R文件标红情况："><a href="#R文件标红情况：" class="headerlink" title="R文件标红情况："></a>R文件标红情况：</h2><ol>
<li><p>布局文件出错或资源文件出错(拼写错误)，根据Message提示内容去找（常见错误）</p>
</li>
<li><p>File–&gt;Project Structure–&gt;选择项目名–&gt;修改 Build Tools Version–&gt;再改回来–&gt;（常用方法）</p>
</li>
<li><p>在同一java包中新建一个R.class类，此时R就不标红了然后运行程序，R文件将自动生成，这时就可以把刚刚的R.class删除啦</p>
</li>
<li><p>选择 Tools–&gt;Android–&gt;Sync Project With Gradle Files</p>
</li>
<li><p>删掉R文件代码段，clean Project将自动生成R文件</p>
</li>
<li><p>强行运行程序，失败了运行2次，有时候R就正常了</p>
</li>
<li><p>修改API</p>
</li>
</ol>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Android Studio的坑其实很多，因为他毕竟也不大成熟。有时候把标红的地方注释掉，run一遍重启，也许他就好了。有时候，电脑尤其是笔记本性能不是很好的情况下，也会出现bug。<br>其实我的问题这些都无解，最后解决是<strong>重新建立了project，将代码copy一遍</strong>就ok了。感觉可能是我linux和windows下分别都有SDK，使用过程中切来切去出现的错误，所以在linux下重建后就可以了。听说这个方法其实也是挺万能的。</p>
<hr>
<h3 id="6-5更新"><a href="#6-5更新" class="headerlink" title="6.5更新"></a>6.5更新</h3><ul>
<li>今天打开Android Studio新建一个项目，结果一直刷不出preview，一片空白连个屏幕都没有，build没有问题。运行提示select SDK，但是打开Project Structure发现SDK的路径没问题啊。然后我就想到了<strong>把Build Tools Version</strong>改完再改回来。居然自动rebuild后瞬间解决。但我仍然不知道为什么 <code>=_=</code>…</li>
<li>然后顺便提一个今天遇到的bug。<blockquote>
<p>too many padding sections on bottom border</p>
</blockquote>
</li>
</ul>
<p>build之后报以上错误，原因是.9文件出了问题。Android Studio对图片的要求很高，只要把这些图删了就没有问题了。</p>
<hr>
<h3 id="6-9更新"><a href="#6-9更新" class="headerlink" title="6.9更新"></a>6.9更新</h3><ul>
<li>今天终于找到解决最开始那个问题的方法了，copy是最傻的办法。因为我发现标红的都是需要添加依赖的package，所以我在build.gradle重新添加了一遍相关依赖，问题就消除了。</li>
</ul>
<hr>
<h3 id="7-27更新"><a href="#7-27更新" class="headerlink" title="7.27更新"></a>7.27更新</h3><ul>
<li>最近被Studio坑的体无完肤，每天打开AS一半的时间是在解决昨天还好好的代码突然一片红光，但也get了几个技能。</li>
</ul>
<h5 id="重载Gradle"><a href="#重载Gradle" class="headerlink" title="重载Gradle"></a>重载Gradle</h5><ul>
<li>删除.gradle文件重新Make Project，即重新下载gradle文件，或者留下wrapper中的<strong>gradle-4.1-milestone-1-all.zip</strong>，Studio锤后会对其进行解压与相关依赖的下载。但这其实十分费时，所以是下下策。</li>
</ul>
<h5 id="关于导包失败"><a href="#关于导包失败" class="headerlink" title="关于导包失败"></a>关于导包失败</h5><ul>
<li>最经常导包失败，或者说异常的，不外乎recyclerView了。今天发现一个问题，有可能是该包版本过旧。<br>打开 Project Structure -&gt; Dependencies，删除原有的包，通过右边的加号，搜索包名重新添加包，此时可以找的该包的<strong>最新版本</strong>。Rebuild之后即可。如图：<br><img src="/2018/05/26/android_studio%E7%9A%84%E5%9D%91/手动添加依赖.png" alt="手动添加依赖"></li>
</ul>
<ul>
<li>还有一件事，，有时候添加依赖时报错，先检查拼写，然后多build几次，缘分到了就没问题了啦[滑稽]。<br>参考博客: <a href="https://blog.csdn.net/keepfriend/article/details/76040045">https://blog.csdn.net/keepfriend/article/details/76040045</a></li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title>Android/Java连接Mysql数据库</title>
    <url>/2019/02/05/android%E8%BF%9E%E6%8E%A5Mysql/</url>
    <content><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>听说其实Android直接连接数据库的情况是比较少的，出于安全和内存都不建议，一般是连接服务器，通过服务器操作数据库。<br>但毕竟还是有必要掌握这项技能（其实是已经记不清前几天是为什么要写这么个东西了，纠缠几天下来已然混乱）<br>这几天这是焦头烂额，每一步都会卡一下，网上的博客也是看了不少，没能很直接解决问题（虽然最后的结果也是令我哭笑不得）  </p>
<blockquote>
<p>可能出现的问题：<br>JDBC URL中的IP地址或主机名错误<br>本地DNS服务器无法识别JDBC URL中的主机名<br>JDBC URL中的端口号丢失或错误<br>数据库服务器关闭<br>数据库服务器不接受TCP/IP连接<br>数据库服务器已用完连接<br>Java和DB之间的某些东西阻止了连接，例如防火墙或代理  </p>
<p>可以尝试以下操作：<br>测试ip地址能否ping通<br>刷新DNS或使用JDBC URL中的IP地址<br>根据MySQL DB的my.cnf进行验证<br>启动数据库服务<br>验证是否在没有–skip-networking选项的情况下启动mysqld<br>重新启动数据库并相应地修改代码，以便最终关闭连接<br>禁用防火墙和/或配置防火墙/代理以允许/转发端口<br>注意别忘了给app添加internet权限  <code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</code></p>
</blockquote>
<p>以上是在其他地方看到简单总结的一些要点。<br>然后要开始来讲故事了。。<br><a id="more"></a></p>
<h1 id="Mysql的远程登录授权"><a href="#Mysql的远程登录授权" class="headerlink" title="Mysql的远程登录授权"></a>Mysql的远程登录授权</h1><p>Mysql需要在允许远程登录的情况下才能被其他主机访问。像在android中就不可能可以本地登录吧，无论是在实体机中还是虚拟机中。</p>
<blockquote>
<p>这里顺便记录一下一些虚拟机中主机的IP地址：<br>Google模拟器<br>emulator-5554<br>开发机地址: [net.eth0.gw]: [10.0.2.2]<br>模拟器本机地址: [net.gprs.local-ip]: [10.0.2.15]<br>夜神模拟器<br>127.0.0.1:62001<br>开发机地址: [dhcp.eth1.gateway]: 172.17.100.2<br>模拟器本机地址: [dhcp.eth1.ipaddress]: [172.17.100.15]<br>逍遥模拟器<br>127.0.0.1:21503<br>开发机地址: [dhcp.eth1.gateway]: [10.0.3.2]<br>模拟器本机地址: [dhcp.eth1.ipaddress]: [10.0.3.15]  </p>
</blockquote>
<h2 id="开放3306端口"><a href="#开放3306端口" class="headerlink" title="开放3306端口"></a>开放3306端口</h2><p>查看3306端口情况<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ netstat -an | grep 3306</span><br><span class="line">tcp6       0      0 :::3306                 :::*                    LISTEN</span><br></pre></td></tr></table></figure><br>说明3306只是监听本地，拒绝了其他IP访问，mysql默认状态下是不开放对外访问功能。那么开放端口。<br>打开etc/mysql/my.cnf（也有人说是/etc/mysql/mysql.conf.d/mysqld.cnf），找到bind-address = 127.0.0.1（大概47行）加 # 注释即可。  </p>
<ul>
<li>其实可能是因为我是tar二进制直接安装的缘故，没有找到mysql.cnf，但后来也是可以连接上emmm  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">连接成功时3306的状态如下</span><br><span class="line">$ netstat -an | grep 3306</span><br><span class="line">tcp6       0      0 :::3306                 :::*                    ESTABLISHED</span><br></pre></td></tr></table></figure>
<h2 id="MySQL授权"><a href="#MySQL授权" class="headerlink" title="MySQL授权"></a>MySQL授权</h2><p>启动mysql.server，进入账户<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo .&#x2F;mysql.server start</span><br><span class="line">Starting MySQL</span><br><span class="line">[ ok ..</span><br><span class="line">$ mysql -uroot -p</span><br></pre></td></tr></table></figure><br>然后问题来了。其他IP的访问授权方式有两种，<strong>授权法</strong> 和 <strong>改表法</strong>。注意Mysql5和Mysql8的授权方法有所不同，主要是语法上的改变。</p>
<h3 id="授权法"><a href="#授权法" class="headerlink" title="授权法"></a>授权法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant all on 数据库名.表名 to &#39;root&#39;@&#39;%&#39; identified by &#39;password&#39;;</span><br><span class="line"></span><br><span class="line"># all 代表权限，可以是select,insert,update,delete等一个或多个，all和all privileges代表所有权限</span><br><span class="line"># 数据库.表名 指定具体开放的数据库表，不用加&#39;&#39;</span><br><span class="line"># root 是远程登录用的用户名，加不加&#39;&#39;都可以</span><br><span class="line"># % 是指定开放的具体IP，%指对所有主机开放，需加&#39;&#39;，@两边不要有空格</span><br><span class="line"># password是远程登录时用的密码</span><br></pre></td></tr></table></figure>
<p>以上在Mysql5下使用，也是网上查到的99%的方法。然而在Mysql8中会报语法错误<br>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to<br>your MySQL server version for the right syntax to use near ‘identified by ‘psw’’ at line 1<br>这个问题也折腾了我一下午，最后是求助了学长才意识到版本的问题。<br><strong>Mysql8</strong> 下的授权方法如下，没错就是没有identified部分。<br>而且需要 <strong>先创建一个用户，在对其进行授权</strong>，否则直接grant会报错 You are not allowed to create a user with GRANT。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 先创建用户</span><br><span class="line">create user &#39;root&#39;@&#39;%&#39; identified by &#39;pwd&#39;;</span><br><span class="line"></span><br><span class="line"># 再进行授权</span><br><span class="line">grant all on *.* to &#39;root&#39;@&#39;%&#39; with grant option;</span><br><span class="line"></span><br><span class="line"># 权限刷新</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><br>注意最后 <strong>刷新权限</strong>。</p>
<h3 id="改表法"><a href="#改表法" class="headerlink" title="改表法"></a>改表法</h3><p>其实最后我是通过这个方法完成的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; update user set host&#x3D;&#39;%&#39; where user&#x3D;&#39;root&#39;;</span><br><span class="line">Query OK, 1 row affected (0.63 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.21 sec)</span><br></pre></td></tr></table></figure><br>如上，进入mysql数据库，查看user，host可看到root用户的host是localhost。修改该项为%，刷新权限。<br>我是使用idea集成的数据库工具测试连接，连接成功。</p>
<h1 id="Android-Java数据库连接"><a href="#Android-Java数据库连接" class="headerlink" title="Android/Java数据库连接"></a>Android/Java数据库连接</h1><h2 id="导入数据库驱动JDBC"><a href="#导入数据库驱动JDBC" class="headerlink" title="导入数据库驱动JDBC"></a>导入数据库驱动JDBC</h2><p>到官网下载获取JDBC的jar包，常见的版本是mysql-connector-java-5.1.47.jar，较新的版本是mysql-connector-java-8.0.13。（有空了会试着把这两个上传）。<br>导包方式：复制jar到项目的libs目录下<br>右键jar选择Add as libs<br>或者直接在app的build.gradle中添加<br>implementation files(‘libs/mysql-connector-java-5.1.47.jar’)</p>
<h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态加载类</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">// 设置连接地址以及数据库名称</span></span><br><span class="line">String DB_URL = <span class="string">&quot;jdbc:mysql://mysql.数据库所在主机IP:3306/表名&quot;</span>;</span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line">Connection conn = DriverManager.getConnection(DB_URL, <span class="string">&quot;用户名&quot;</span>, <span class="string">&quot;密码&quot;</span>);</span><br><span class="line"><span class="comment">// 创建Statement对象(可执行SQL语句的对象)</span></span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line"><span class="comment">// 执行sql语句 返回一个ResultSet对象（返回数据集合）</span></span><br><span class="line">ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"><span class="comment">// rs调用数据</span></span><br><span class="line">rs.getString(<span class="number">1</span>);  <span class="comment">// 遍历索引</span></span><br><span class="line">rs.getString(<span class="string">&quot;name&quot;</span>); <span class="comment">// 字段名索引</span></span><br></pre></td></tr></table></figure>
<h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><h3 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h3><p>Android不支持在转线程执行网络请求（耗时操作）会有UnsupportedOperationException。<br>注意包括stmt.executeQuery(str) 方法也是联网操作，也要放在多线程中执行</p>
<h3 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h3><p>5.0和8.0驱动包有几个地方不同  </p>
<ul>
<li><p>加载8.0驱动的时候报错</p>
<blockquote>
<p>Loading class <code>&#39;com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class is &#39;com.mysql.cj.jdbc.Driver&#39;</code>. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.  </p>
</blockquote>
<p>提示，8.0包的驱动名应该改为 <strong>com.mysql.cj.jdbc.Driver</strong></p>
</li>
<li><p>建立连接时报错</p>
<blockquote>
<p>Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.</p>
</blockquote>
<p>mysql8.0是不需要建立ssl连接，需要使用useSSL=false手动关闭。即URL改为 <strong>jdbc:mysql://mysql.数据库所在主机IP:3306/表名?useSSL=false</strong></p>
</li>
<li>8.0驱动包只能兼容minSdkVersion = 26，我的测试机SdkVersion是24的，所以我只能用5.0的驱动包</li>
</ul>
<h3 id="一些报错"><a href="#一些报错" class="headerlink" title="一些报错"></a>一些报错</h3><ul>
<li>serverTimezone=UTC，可以指定时区（非必要）</li>
<li>数据库或表明出错会有报错：No address associated with hostname，Unknown database</li>
<li>用户名或密码错误：Access denied for user (using password: YES)</li>
<li>网络原因（无权限，无网络连接，在主线程执行）：com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server.  </li>
<li>注意在适当位置关闭相关资源流</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String JDBC_DRIVER = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DB_URL = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/table&quot;</span>;</span><br><span class="line">    <span class="comment">// 注意修改DB_URL，和UER，PASS</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String USER = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PASS = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ResultSet re;</span><br><span class="line">        Connection con;</span><br><span class="line">        Statement stmt;</span><br><span class="line">        String str = <span class="string">&quot;select * from books&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Fail to load JDBC dirver.&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            con = DriverManager.getConnection(DB_URL, USER, PASS);</span><br><span class="line">            stmt = con.createStatement();</span><br><span class="line"></span><br><span class="line">            re = stmt.executeQuery(str);</span><br><span class="line">            <span class="keyword">while</span>(re.next())&#123;</span><br><span class="line">                System.out.println(re.getString(<span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            con.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String JDBC_DRIVER = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DB_URL = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/table?useSSL=false&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String USER = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PASS = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResultSet re;</span><br><span class="line">    <span class="keyword">private</span> Connection con;</span><br><span class="line">    <span class="keyword">private</span> Statement stmt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="keyword">final</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String str = <span class="string">&quot;select book_title from books&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Class.forName(JDBC_DRIVER);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;驱动加载失败&quot;</span>, e.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    con = DriverManager.getConnection(DB_URL, USER, PASS);</span><br><span class="line">                    stmt = con.createStatement();</span><br><span class="line"></span><br><span class="line">                    re = stmt.executeQuery(str);</span><br><span class="line">                    <span class="keyword">if</span> (re != <span class="keyword">null</span>)</span><br><span class="line">                        Log.i(<span class="string">&quot;标记&quot;</span>, <span class="string">&quot;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">while</span> (re.next())</span><br><span class="line">                        Log.i(<span class="string">&quot;Data&quot;</span>, re.getString(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;连接失败&quot;</span>, e.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="我碰到的问题："><a href="#我碰到的问题：" class="headerlink" title="我碰到的问题："></a>我碰到的问题：</h2><p><del>以下内容非重点</del>  </p>
<ul>
<li>Communications link failure  </li>
<li>The last packet sent successfully to the server was 0 milliseconds ago.The driver has not received any packets from the server.  </li>
</ul>
<p>这两个报错贯穿了我两天的debug过程，也大概是android连接Mysql最常见的报错<br>查到的都是超时相关问题，超时回收机制云云。<strong>该问题是程序运行过程中使用的连接池不知道连接被回收了所以报出的异常，解决方案大概是 修改连接池配置 或 修改mysql空闲超时时间配置</strong>，否则默认是8小时。  </p>
<p>但这是数据库连接中断的问题，我连都连不上。这大年初一的，就是熬夜掉头发，想起这一年的漫漫debug之路，忍不住捏了把汗。<br>我不抱希望修改了如下URL，然后气急败坏的跑去和我妹看电视。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;table?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;autoReconnect&#x3D;true&amp;failOverReadOnly&#x3D;false</span><br></pre></td></tr></table></figure><br>半晌，就在我回来继续时候，看到logout上终于打上了数据库的内容，欣喜若狂，扯着一脸问号的妹妹条了半天广场舞。<br>接下来的事令我不知该哭还是该笑，倒不是程序又不能跑了，是就在我将上面的指令一个一个删去，尝试找到罪归祸首时，发现已经是把代码恢复到原来状态了，app还是十分乖巧的连上了数据库，即jdbc:mysql://ip:3306/table。<br>我：？？？？？<br>刚刚到底发生什么了，难道还有打开某个开关以后他就默认开启之类的操作？</p>
<p>无论如何，总算是成功了。老泪纵横。<br>愿天下码农和八哥终成眷属。。TAT</p>
<hr>
<p><a href="https://blog.csdn.net/CristianTang/article/details/79553947">参考博客</a></p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>技能帖</tag>
      </tags>
  </entry>
  <entry>
    <title>Deepin又一次折腾记录</title>
    <url>/2019/07/05/deepin%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Deepin-15-10-2-stable"><a href="#Deepin-15-10-2-stable" class="headerlink" title="Deepin 15.10.2 stable"></a>Deepin 15.10.2 stable</h2><p>最近又重装了一遍Deepin，全新安装最新版本Deepin15.10.1，然后更到15.10.2（赶上这几天Deepin更新了）。此次安装折腾了两天，解决了很多之前的问题，当然，也出现很多之前没有出现过的问题（流泪）。<br>得到了很多经验体会，特此记录<br>（这几天不断地强制关机，感觉我的机械硬盘命不久矣噢…TAT）<br><a id="more"></a></p>
<h2 id="安全模式安装系统"><a href="#安全模式安装系统" class="headerlink" title="安全模式安装系统"></a>安全模式安装系统</h2><p>首先是全新安装，日常出现卡在DeepinLogo处死机的现象。重新开机（没错就是先强制重启），选择install faillsafe，进入安全模式。（这里有时候也会进不去，多试两次就进去了）。<br>（这里出现过一个很有意思的问题：安全模式下长时间不操作，系统待机，唤醒后是用户登录页，需要输入密码，我都没有设置用户和密码怎么登录？？蒙了好几个所谓初始密码后，放弃，强制重启）<br>安全模式中，我是先安装了intel-microcode，因为在开机日志里会看到update microcode to version 0x52</p>
<blockquote>
<p>sudo apt-get install intel-microcode</p>
</blockquote>
<p>注：使用其他源（如上交大源）可能会无法定位该包，建议先切回官方源。<br>然后更新独显驱动，因为15.5版本的时候，一更新系统内核就会崩，即卡在logo无法进入系统，直到更新了显卡驱动，后才能正常时候新内核</p>
<blockquote>
<p>sudo apt-get install nvidia-driver    // 其实是安装了一个闭源的显卡驱动</p>
</blockquote>
<p>然后点击桌面的安装程序开始安装。<br>安装成功后即可进入系统。注意重新安装一下intel-microcode，和显卡驱动，因为安全模式的安装的软件，到正常系统就没有了（安全模式大概就类似windows下的PE系统吧）。</p>
<h2 id="更新软件列表及更换镜像源"><a href="#更新软件列表及更换镜像源" class="headerlink" title="更新软件列表及更换镜像源"></a>更新软件列表及更换镜像源</h2><p>接着更新软件列表</p>
<blockquote>
<p>sudo apt-get update</p>
</blockquote>
<p>注意，在此之前可以先更换一下软件源，因为官方源一般会比较慢。据说在广东及河南等地，上交大的镜像源会比较快。另外华为云在社区口碑也不错。更换方式如下，进入/etc/apt/source.list直接添加(1)或命令行添加(2)：</p>
<blockquote>
<ol>
<li>deb [by-hash=force] <a href="http://ftp.sjtu.edu.cn/deepin">http://ftp.sjtu.edu.cn/deepin</a> panda main contrib non-free</li>
<li>sudo sed -i “s@<a href="http://packages.deepin.com/deepin@https://mirrors.huaweicloud.com/deepin@g&quot;">http://packages.deepin.com/deepin@https://mirrors.huaweicloud.com/deepin@g&quot;</a> /etc/apt/sources.list</li>
</ol>
</blockquote>
<p>该命令会顺带更新系统。</p>
<h2 id="独显问题开始作妖"><a href="#独显问题开始作妖" class="headerlink" title="独显问题开始作妖"></a>独显问题开始作妖</h2><p>升级完系统后，又出现问题了。<br>我的dde桌面突然退到2D模式，即关闭了桌面动画，而且系统软件打开后都会出现厚厚的黑框框。经查确实是处于2D模式且无法切换为3D模式。我就感觉，必然又是显卡出了问题。折腾大半天，切换为大黄蜂显卡驱动方案可以解决问题。<br>切换方式可以通过</p>
<blockquote>
<p>sudo apt-get install bumblebee-nvidia nvidia-driver nvidia-settings</p>
</blockquote>
<p>安装大黄蜂驱动，也可以直接在系统软件“显卡驱动管理器”中自动安装切换。具体方式如下：<br><a href="https://wiki.deepin.org/index.php?title=Deepin%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0NVIDIA%E9%A9%B1%E5%8A%A8&amp;language=en">安装大黄蜂显卡驱动</a><br>其实一开始切换是有点慌的，因为在社区见过有旁友装了大黄蜂以后无法进入系统。</p>
<h2 id="待机后无法唤醒"><a href="#待机后无法唤醒" class="headerlink" title="待机后无法唤醒"></a>待机后无法唤醒</h2><p>然而后来确实出现问题了。我发现待机时间过长，显示屏关闭后，无法唤醒显示屏。虽然可以听到系统确实已经启动，可以听到wifi连接的提示音，但是显示屏就是不亮。<br>这个在社区已经臭名昭著的待机后无法唤醒的问题，今天终于被我遇上了。。TAT<br>在社区看了很多帖子，都说没有可以真正解决的方式，无非强制计算机不待机（？？）。期间我也试过切换回开源驱动，即默认的驱动，但是没有效果，于是最后只得切回大黄蜂（听说该驱动省电），然后…强制不待机…<br>感觉很多问题挖到后边都能和独显扯上关系啊…</p>
<h2 id="pcspkr问题？？"><a href="#pcspkr问题？？" class="headerlink" title="pcspkr问题？？"></a>pcspkr问题？？</h2><p>这一次更新系统后，还出现一个新的现象，出现系统Logo后，一般就进入用户登录界面了，但现在在Logo页还会打印log，其中是一条报错信息</p>
<blockquote>
<p>Error: Driver ‘pcspkr’ is already registered, aborting…</p>
</blockquote>
<p>甚至在前几次开机时，出现该log后，是有一定几率进不去系统的。。貌似upate以后就可以稳定进入了但是每次到那个地方还是会有停顿的样子。每次都会提一口气担心系统又这样挂掉了。<br>查了一下，这是一个跟蜂鸣器相关的内核模块，想想确实Deepin在那个时间会调蜂鸣器发出进入系统的提示音。找了一圈找到的解决方式是</p>
<ol>
<li><blockquote>
<p>aptitude install alsa-base<br>echo blacklist snd-pcsp &gt;&gt; /etc/modprobe.d/alsa-base-blacklist</p>
</blockquote>
</li>
<li><p>据说该方法原理是屏蔽该模块</p>
<blockquote>
<p>echo -e “# Used for shielding pcspkr module, this module seems to be related to buzzer.\nblacklist pcspkr” | sudo tee /etc/modprobe.d/blacklist-pcspkr.conf</p>
</blockquote>
</li>
</ol>
<p>由于我虽然出现这个问题，但是后来都不影响启动，所以我也没折腾这个问题。但据社区的帖子所说，这两个方法貌似都没能根治该问题…</p>
<hr>
<h2 id="臭名昭著的Logo死机问题"><a href="#臭名昭著的Logo死机问题" class="headerlink" title="臭名昭著的Logo死机问题"></a>臭名昭著的Logo死机问题</h2><p>关于开机时卡在logo处的问题，另找到一个解决方案：<br>开机后在grub引导时，选择deepin系统，先不要按Enter，按e键进入编辑模式</p>
<blockquote>
<p>在菜单中的代码中，找到倒数第二行，会出现如下所示的代码：<br>linux /vmlinuz-4.15.0-29deepin-generic root=UUID=b66d8ffa-aed9-466c-bc12-6bb801e45901 ro splash quiet<br>表示加载的linux内核文件，后面是内核的参数，各项含义为<br>root告诉内核根分区的设备<br>ro表示在设备启动时为read-only，如果是rw表示read-write<br>splash表示开机动画<br>quiet表示在启动过程中只有重要信息显示，类似硬件自检的消息不会显示quiet表示在启动过程中只有重要信息显示，类似硬件自检的消息不会显示<br>single以单用户模式登录，一般用于修改系统，比如deepin密码忘记了等等。single以单用户模式登录，一般用于修改系统，比如deepin密码忘记了等等。<br><strong>在quiet的后面空一格加上如下所示的代码：acpi_osi=! acpi=”windows 2009”，按F10保存即可。这时会重新开始登录deepin系统，耐心等待进入桌面。</strong></p>
</blockquote>
<p>但是以上操作只能成功进入系统一次，大概因为以上对grub的设置其实写到一个临时文件中，所以不能对以后的进入奏效。<br>所以需要对grub的设置文件进行修改，永久性解决该问题。进入系统以后，执行</p>
<blockquote>
<p>sudo gedit /boot/grub/grub.cfg</p>
</blockquote>
<p>打开配置文件。如果系统没有gedit可以使用vim或nano打开，仍在原来的位置加上，<strong>acpi_osi=! acpi=”windows 2009”</strong>。<br>据说这种操作的原理是：旧版的BIOS无法打识别一些新版的linux内核，所以添加该语句让系统“误以为”是Windows系统。<br><a href="https://blog.csdn.net/HuaCode/article/details/83216338">参考原文</a></p>
<hr>
<h2 id="备注：系统的显卡驱动管理器中原本有一个NV-PRIME方案，用于混合显卡的驱动。但15-10-2stable版本中官方禁用了prime方案（暂时）。"><a href="#备注：系统的显卡驱动管理器中原本有一个NV-PRIME方案，用于混合显卡的驱动。但15-10-2stable版本中官方禁用了prime方案（暂时）。" class="headerlink" title="备注：系统的显卡驱动管理器中原本有一个NV-PRIME方案，用于混合显卡的驱动。但15.10.2stable版本中官方禁用了prime方案（暂时）。"></a>备注：系统的显卡驱动管理器中原本有一个NV-PRIME方案，用于混合显卡的驱动。但15.10.2stable版本中官方禁用了prime方案（暂时）。</h2><p><strong>如果对上述问题有较好的解决方式或看法，欢迎交流[邮箱 <a href="mailto:xiaohuangren028@gmail.com">xiaohuangren028@gmail.com</a>]</strong></p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>技能帖</tag>
        <tag>Deepin</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈equals()和hashCode()</title>
    <url>/2020/10/18/equals%E5%92%8ChashCode/</url>
    <content><![CDATA[<blockquote>
<p>开始思考这个问题，要从一道面试题开始，面试官问我，HashMap中存的对象没有重写hashCode()会有什么影响…</p>
</blockquote>
<a id="more"></a>
<h1 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h1><p>众所周知，equals()是Java中Object的基本方法，用于比较两个对象是否相等。</p>
<h2 id="和equals"><a href="#和equals" class="headerlink" title="==和equals()"></a>==和equals()</h2><p>经常会被问的问题是==和equals()的区别。使用==对对象进行比较时，是使用两个对象的内存地址进行比较，equals()的话，如果没有对它进行重写，其实也是比较对象的内存地址。所以一般需要我们对他根据具体的业务逻辑进行重写。</p>
<h1 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h1><p>这个方法很多人都知道，但不一定真的知道，比如我。<br>hashCode()也是Object的基本方法，用于计算对象的hash值，默认也是返回对象的内存地址。如果问有没有过重写hashCode的场景，我是没有的；但如果问，有没有使用HashMap存过自定义对象，那肯定是有的。但是使用HashMap存自定义对象却不重写hashCode()方法，那便有问题了。</p>
<h2 id="HashMap和hashCode"><a href="#HashMap和hashCode" class="headerlink" title="HashMap和hashCode()"></a>HashMap和hashCode()</h2><p>首先设定一个场景<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> k;</span><br><span class="line">    <span class="comment">// 先不对Key的equals和hashCode进行重写</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">HashMap&lt;Key, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="keyword">new</span> Key(<span class="number">1</span>), <span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.get(<span class="keyword">new</span> Key(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><br>假定int k可以唯一的标识一个Key对象（比如是身份证号），那么从业务角度说，map.get是可以get到上一行put的这个对象返回”1”的，因为认为两次new的Key是同一个对象。<br>但实际上get()返回的结果是null。为什么？<br>这要从HashMap的put操作开始说起。HashMap put对象时，会先通过hashCode()方法获取对象Hash值，进行计算得到索引位置以后存到对应位置。get对象时，仍然通过hashCode()方法获取hash值计算出索引，进而找到对象。而如果没有重写hashCode()，则默认返回对象的地址，所以以上场景，两次new的Key对象地址肯定不一样，所以get出来会是null。<br>那重写了hashCode方法，返回k.hashCode()，因为同样的k的Hash值肯定是一样的（<strong>Integer的hashCode()是返回自身的值</strong>），这个时候能否get到呢？实际上还是不能。因为还需要重写equals()。<br>上文说到HashMap方法get时通过对象的hash值找到具体位置，由于Java的HashMap实现是使用链表解决冲突，即冲突的对象们会在相应的索引位置以链表形式存储，因此hash值相同的对象可能会有多个，需要对链表元素进行遍历比较，这时候使用的便是equals()方法。由于没有重写equals()所以默认比较对象的地址，自然也不会有匹配的对象。<br>如果对equals()和hashCode()都进行重写，就能满足我们需要，返回”1”了。</p>
<p><img src="/Users/linweixian/Desktop/截屏2020-10-18 上午1.27.35.png" alt="code" style="zoom:45%;" /></p>
<h1 id="equals-与hashCode"><a href="#equals-与hashCode" class="headerlink" title="equals()与hashCode()"></a>equals()与hashCode()</h1><p>如此说来，equals()与hashCode()都能用于对象之间的比较，那么他们有何区别呢？</p>
<ul>
<li>从效果（可靠性）上说，使用equals()方法进行比较，如果结果是true的，则两个对象认为是同一个对象（业务逻辑上来说）；如果equals()比较是相等的，则hashCode()返回的结果也会是相等的，因为都是相同的数值进行计算嘛。但是如果是两个不同的对象，其hash值计算结果却是有可能相等的（否则也不会有hash冲突这一说了，这取决于计算的方式）。</li>
<li>从性能上来说，由于equals()的比较涉及具体的业务逻辑，更加全面往往复杂一些，效率就比较低；而hashCode()由于只是涉及hash码的计算生成，所以速度自然更快一些</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><blockquote>
<p>没有对equals()和hashCode()进行重写，默认都是使用对象的地址进行计算。<br>equals()返回true的两个对象一定相等，hashCode()返回true时equals()不一定返回true，即对象不一定相等，但hashCode()返回false的两个对象一定不相等<br>由于两个方法效果和性能的不同，当需要对多个对象进行比较时，可以通过先比较hashCode，如果hashCode一样再进行equals()的比较；如果hashCode都不一样，则没有必要再进行下一步比较了。从而节约一些性能。<br>需要对多个对象进行比较的场景，比如使用HashMap和HashSet进行存储，由于这两个都不允许存储相同的对象，因此存入过程中必定都涉及容器内已有对象的比较，这种时候先比较hashCode的性能优势就比较明显了。</p>
<p>关于hashCode()返回true，equals()返回false的场景，比如两个对象A，B，都拥有属性String a且是相等，则他们的hashCode就是相等的，实际上他们却是两个不同对象，所以equals()一定是false的。</p>
</blockquote>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>秘籍帖</tag>
      </tags>
  </entry>
  <entry>
    <title>Fragment的封装与调度优化 及BottomNavigationView的使用</title>
    <url>/2018/12/06/fragment%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>最近通过网课，了解到一种十分巧妙的fragment的封装以及调度方式。遂记录下理解</p>
</blockquote>
<h2 id="Fragment的封装"><a href="#Fragment的封装" class="headerlink" title="Fragment的封装"></a>Fragment的封装</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.<span class="title">app</span>.<span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="comment">//便于复用</span></span><br><span class="line">    <span class="keyword">protected</span> View mRoot;</span><br><span class="line">    <span class="keyword">protected</span> Unbinder mRootUnBinder;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当一个fragment被添加到一个acitvity中，最首先被调用的方法</span></span><br><span class="line"><span class="comment">     * context即为activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttach(context);</span><br><span class="line">        <span class="comment">//初始化参数</span></span><br><span class="line">        initArgs(getArguments());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> layId = getContentLayoutId();</span><br><span class="line">            <span class="comment">// 初始化当前根布局，但不在创建时就添加到container中去（return root后方法内部调度自动添加到container中去）</span></span><br><span class="line">            View root = inflater.inflate(layId, container, <span class="keyword">false</span>);</span><br><span class="line">            initWidget(root);</span><br><span class="line">            mRoot = root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 父布局不等于空，则把当前root从其父控件中移除</span></span><br><span class="line">            <span class="keyword">if</span>(mRoot.getParent() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ((ViewGroup)mRoot.getParent()).removeView(mRoot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mRoot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否获取到数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initArgs</span><span class="params">(Bundle bundle)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当view界面初始化创建完成以后</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        initData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前界面的资源文件id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 资源文件id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getContentLayoutId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initWidget</span><span class="params">(View root)</span></span>&#123;</span><br><span class="line">        mRootUnBinder = ButterKnife.bind(<span class="keyword">this</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回按键触发时调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回true代表我已处理返回逻辑，activity不用自己finish</span></span><br><span class="line"><span class="comment">     * 返回flase代表未处理逻辑(不拦截)，activity自己处理逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onBackPressed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Fragment的使用"><a href="#Fragment的使用" class="headerlink" title="Fragment的使用"></a>Fragment的使用</h2><p>fragment经常与BottomNavigationView一起使用，作为底部导航栏切换界面。所以接着学习一下BottomNavigationView的使用以及封装一个Helper让BottomNavigationView使用更加便捷和更好的提升fragment性能</p>
<h3 id="BottomNavigationView使用"><a href="#BottomNavigationView使用" class="headerlink" title="BottomNavigationView使用"></a>BottomNavigationView使用</h3><h4 id="menu布局"><a href="#menu布局" class="headerlink" title="menu布局"></a>menu布局</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--navigation_items.xml--&gt;</span></span><br><span class="line">&lt;item</span><br><span class="line">    android:icon=&quot;@drawable/ic_home&quot;</span><br><span class="line">    android:title=&quot;@string/action_home&quot;</span><br><span class="line">    app:showAsAction=&quot;always&quot; /&gt;</span><br><span class="line">&lt;item</span><br><span class="line">    android:icon=&quot;@drawable/ic_group&quot;</span><br><span class="line">    android:title=&quot;@string/action_group&quot;</span><br><span class="line">    app:showAsAction=&quot;ifRoom&quot; /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>always表示一定会显示，ifRoom表示如果存在空间就放上去。</li>
<li>默认在顶部菜单栏显示第一个控件，其余放在下拉选项中。也可用于底部导航栏<h4 id="底部导航栏示例"><a href="#底部导航栏示例" class="headerlink" title="底部导航栏示例"></a>底部导航栏示例</h4>菜单栏+颜色选择器<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;android.support.design.widget.BottomNavigationView</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;@dimen/len_52&quot;</span><br><span class="line">    android:layout_gravity=&quot;bottom&quot;</span><br><span class="line">    app:menu=&quot;@menu/navigation_items&quot;</span><br><span class="line">    app:itemIconTint=&quot;@color/text_nav&quot;</span><br><span class="line">    app:itemTextColor=&quot;@color/text_nav&quot;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="设置监听"><a href="#设置监听" class="headerlink" title="设置监听"></a>设置监听</h4></li>
<li>设置监听 setOnNavigationItemSelectedListener(Activity)</li>
<li>实现接口 BottomNavigationView.OnNavigationItemSelectedListener<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 底部导航栏被点击时触发</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNavigationItemSelected</span><span class="params">(<span class="meta">@NonNull</span> MenuItem menuItem)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现UI操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 记得返回true代表可以处理本次点击</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fragment的替换及调度"><a href="#fragment的替换及调度" class="headerlink" title="fragment的替换及调度"></a>fragment的替换及调度</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般替换fragment的方法</span></span><br><span class="line">getSupportFragmentManager()</span><br><span class="line">  .beginTransaction()</span><br><span class="line">  .add(R.layout, <span class="keyword">new</span> Fragment)</span><br><span class="line">  .commit();</span><br></pre></td></tr></table></figure>
<ul>
<li>getSupporrtFragment()会返回一个FragmentManager，里面带有一个当前Acivity下加载的Fragment列表，所以可以通过它查看当前Fragmant的状态</li>
<li>本以为用replace()代替add()，已经可以避免覆盖的问题，并且节约资源了。其实，每次都要new一遍fragment，就不是很节约资源，重要的是，很多fragment数据不能保留复用。于是定义一个NavHelper类，优化fragmnent的调度。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决Fragment的调度与重用问题</span></span><br><span class="line"><span class="comment"> * 达到最优的Fragment切换</span></span><br><span class="line"><span class="comment"> * 用于管理当前已加载的fragment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NavHelper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//所有的Tab集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SparseArray&lt;Tab&gt; tabs = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FragmentManager manager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> containerId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OnTabChangeListener&lt;T&gt; listener;</span><br><span class="line">    <span class="comment">//当前选中的Tab</span></span><br><span class="line">    <span class="keyword">private</span> Tab&lt;T&gt; currentTab;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NavHelper</span><span class="params">(Context context, <span class="keyword">int</span> containerId, FragmentManager manager, OnTabChangeListener&lt;T&gt; listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.manager = manager;</span><br><span class="line">        <span class="keyword">this</span>.containerId = containerId;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.listener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回NavHelper实例，便于链式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NavHelper&lt;T&gt; <span class="title">add</span><span class="params">(<span class="keyword">int</span> menuId, Tab&lt;T&gt; tab)</span></span>&#123;</span><br><span class="line">        tabs.put(menuId, tab);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tab&lt;T&gt; <span class="title">getCurrentTab</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行点击菜单的操作，接管对Meun的调度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> menuId 菜单项id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否可以处理该点击</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClickMenu</span><span class="params">(<span class="keyword">int</span> menuId)</span></span>&#123;</span><br><span class="line">        Tab&lt;T&gt; tab = tabs.get(menuId);</span><br><span class="line">        <span class="keyword">if</span>(tab != <span class="keyword">null</span>)&#123;</span><br><span class="line">            doSelect(tab);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行tab的选择操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSelect</span><span class="params">(Tab&lt;T&gt; tab)</span></span>&#123;</span><br><span class="line">        Tab&lt;T&gt; oldTab = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(currentTab != <span class="keyword">null</span>)&#123;</span><br><span class="line">            oldTab = currentTab;</span><br><span class="line">            <span class="keyword">if</span>(oldTab == tab)&#123;</span><br><span class="line">                <span class="comment">// 即二次点击</span></span><br><span class="line">                notifyReselect(tab);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        currentTab = tab;</span><br><span class="line">        doTabChanged(currentTab, oldTab);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行Fragment的真实调度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doTabChanged</span><span class="params">(Tab&lt;T&gt; newTab, Tab&lt;T&gt; oldTab)</span></span>&#123;</span><br><span class="line">        FragmentTransaction ft = manager.beginTransaction();</span><br><span class="line">        <span class="keyword">if</span>(oldTab != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(oldTab.fragment != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 从界面中移除，但是还在fragment的缓存空间中</span></span><br><span class="line">                ft.detach(oldTab.fragment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(newTab != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newTab.fragment == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 首次新建</span></span><br><span class="line">                Fragment fragment = Fragment.instantiate(context, newTab.clx.getName(), <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 保存到缓存中</span></span><br><span class="line">                newTab.fragment = fragment;</span><br><span class="line">                <span class="comment">// 提交到FragmentManger</span></span><br><span class="line">                ft.add(containerId, fragment, newTab.clx.getName());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 从FragmentManger的缓存空间中重新加载到界面中</span></span><br><span class="line">                ft.attach(newTab.fragment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        ft.commit();</span><br><span class="line">        notifyTabSelect(newTab, oldTab);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回调监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyTabSelect</span><span class="params">(Tab&lt;T&gt; newTab, Tab&lt;T&gt; oldTab)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listener != <span class="keyword">null</span>)&#123;</span><br><span class="line">            listener.onTabChanged(newTab, oldTab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyReselect</span><span class="params">(Tab&lt;T&gt; tab)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 刷新Tab</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义菜单的类型</span></span><br><span class="line"><span class="comment">     * static不能让外部类引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tab</span> </span>&#123;</span><br><span class="line">         <span class="comment">// Fragment对应的Class信息</span></span><br><span class="line">         Class&lt;?&gt; clx;</span><br><span class="line">         <span class="comment">// 额外字段，用户自己设定需要使用</span></span><br><span class="line">         <span class="keyword">public</span> T extra;</span><br><span class="line">         <span class="comment">// 内部缓存的对应的fragment，不能被外部获取</span></span><br><span class="line">         Fragment fragment;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="title">Tab</span><span class="params">(Class&lt;?&gt; clx, T extra)</span></span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.clx = clx;</span><br><span class="line">             <span class="keyword">this</span>.extra = extra;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnTabChangeListener</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onTabChanged</span><span class="params">(Tab&lt;T&gt; newTab, Tab&lt;T&gt; oldTab)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
NavHelper定义逻辑：</li>
<li>定义performClickMenu()，从导航栏被点击时自动触发的onNavigationItemSelected()方法那接管对menu的调度。返回boolean标示是否处理该点击</li>
<li><p>performClickMenu()方法判断点击的tab是否已添加</p>
<ul>
<li>Helper类中定义一个集合保存menu中所有的tab。（集合实现使用比Set，List更加轻量级的SparseArray）所以必须添加一个add()方法用于初始化helper后把menu中的tab添加进去。添加tab时需要传入menu的ItemId和Tab的实例。add()中调用SparseArray.put()添加并return this。所以调用时才能helper.add().add()…</li>
<li><p>定义一个内部类Tab，作用类似于一个中间变量，一个menu项，fragment置于其内。并定义为static类使得能够在其他类中引用。</p>
<ul>
<li>需要传递具体Fragment的Class信息，有内部成员Class&lt;? extends Fragment&gt;</li>
<li>定义字段fragment，缓存fragment信息。</li>
<li>切换fragment的同时切换一些其他的UI或数据，所以再定义一个额外字段，由用户自己设定需要的改动类型，所以定义为泛型。因此class Tab<T>。由于在Helper中定义了存放Tab的集合，所以Helper<T></li>
<li><p>若添加了该字段，那么Tab的构造方法中需要传入Fragment的具体Class，以及该字段信息。</p>
<p><strong>此处并不一定添加该字段</strong> 对于切换时更改UI，也可以放在Helper接管前执行。这样的话，Hepler中的所有泛型及后面的回调方法也可以不需实现。只是这样Helper就没有原来那么全权接管Nav的调度。感觉都可以。</p>
</li>
</ul>
<p>若已添加进集合，则调用doSelect()开始处理操作。</p>
</li>
</ul>
</li>
<li><p>doSelect()中调用doTabChanged()开始真正真正的替换操作。因为doTabChanged()方法中fragment替换分步进行而非一般直接用replace()，即先舍去旧的，再放上新的，需要一个oldTab和newTab。</p>
<ul>
<li>所以添加一个成员字段currentTab，方便操作。所以需要对该字段进行更新，该工作由doSelect()承担。</li>
</ul>
<p>定义一个oldTab，不做初始化。用更新前的currentTab给oldTab赋值。<br>若点击的tab是当前tab，则执行刷新notifyReselect()<br>若不是，更新currentTab，调用替换方法</p>
<p>为了严谨，在此之前判断currentTab是否为空，若为空，调用替换方法时传入的oldTab即为null。</p>
</li>
<li><p>doTabChanged()方法大抵与一般替换fragment方式相同：<br>用FragmentManager.beginTransaction()初始化一个fragmentTransaction</p>
<ul>
<li>FragmentManager需要在接管时由activity传入，因此需定义内部字段manager</li>
</ul>
<p>使用transaction调用detach()，attach()在内存中替换fragment。提交，然后调用notifyTabSelect()通知并刷新。</p>
<ul>
<li>notifyTabSelect()方法中回调接口方法onTabChanged()，所以需要添加成员字段OnTabChangeListener listener;</li>
</ul>
<p>在替换前需要判断是否为空。若oldTab不为空，且oldTab.fragment也不为空，则在界面中移除其中的fragment。</p>
<p>若newTab不为空，但newTab.fragment为空，则新建一个Fragment，<u>缓存到fragment中</u>，并transaction.add(containerId, fragment实例, newTab.clx.getName())提交到manager。这里需要一个containerId容器ID，也需要从外部传入。</p>
<ul>
<li>通过Fragment.instantiate(Context, newTab.clx.getName(), null)初始化。这里 <strong>使用到了Tab的Class信息</strong>，也需要一个Context。所以需要在成员字段中添加一个Context，并在初始化时传入。此处相当于一般操作时 new MyFragment()。</li>
</ul>
<p>若fragment不为空，从manage缓存空间中重新接载到界面attach()。</p>
</li>
<li>所以最后编写构造方法，传入所以需要从外部传入的实例ContainerId, Context, OnTabChangeListener, FragmentManager。这些内部字段包括Sparse集合在类中都为final字段。<strong>不是很明白为什么</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NavHelper的使实际调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">NavHelper</span>.<span class="title">OnTabChangeListener</span>,</span></span><br><span class="line"><span class="class">    <span class="title">BottomNavigationView</span>.<span class="title">OnNavigationItemSelectedListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BindView(R.id.navigation)</span></span><br><span class="line">    BottomNavigationView mNavigation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NavHelper mNavHelper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        initWidget();</span><br><span class="line">        <span class="comment">//从底部导航中接管menu，手动进行触发</span></span><br><span class="line">        Menu menu = mNavigation.getMenu();</span><br><span class="line">        menu.performIdentifierAction(R.id.action_home, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化底部栏辅助工具类</span></span><br><span class="line">        mNavHelper = <span class="keyword">new</span> NavHelper(<span class="keyword">this</span>, R.id.lay_container, getSupportFragmentManager(), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        mNavHelper.add(R.id.action_home, <span class="keyword">new</span> NavHelper.Tab(ActiveFragment.class))</span><br><span class="line">                .add(R.id.action_contact, <span class="keyword">new</span> NavHelper.Tab(ContactFragment.class))</span><br><span class="line">                .add(R.id.action_group, <span class="keyword">new</span> NavHelper.Tab(GroupFragment.class));</span><br><span class="line"></span><br><span class="line">        mNavigation.setOnNavigationItemSelectedListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 底部导航被点击时触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNavigationItemSelected</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将事件流转接到工具类中</span></span><br><span class="line">        <span class="keyword">return</span> mNavHelper.performClickMenu(menuItem.getItemId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NavHelper处理完成后回调的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTabChanged</span><span class="params">(NavHelper.Tab newTab, NavHelper.Tab oldTab)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际调用：</p>
<ul>
<li>先初始化NavHelper类，传入Context(this), FragmentManager(getSupportFragmentManager()), ContainerId(IdRes), OnTabChangeListener(this, activity已继承该接口)</li>
<li>调用NavHelper.add()将所有的fragment以Tab的形式添加到集合中，在此处传入其具体类型为Class clx赋值</li>
<li><p>别忘了为BottomNavigationView添加监听。</p>
<ul>
<li><p>添加监听时继承OnNavigationItemSelectedListener接口，需要实现接口方法onNavigationItemSelected，标示能否处理此次点击，同时调用NavHelper.performClickMenu()方法实现fragment调度的交接。</p>
<p>在NavHelper中完成切换后，会回调接口方法OnTabChangeListener.onTabChanged()。实现该方法，完成切换fragment时UI修改。</p>
</li>
</ul>
</li>
</ul>
<p>FragmentTransaction操作区别</p>
<ul>
<li>add() :将fragment添加到container中</li>
<li>replace() :替换container中的fragment，移除其中所有的fragment。</li>
<li>hide/show() :隐藏与显示，不移除container中的fragment</li>
<li>attach/detach() :从布局上移除，但存储在缓存队列中。不会被测量到，但可以被重用，减少frag的重复创建，减少内存抖动。</li>
<li>remove() :直接移除</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技能帖</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title>初识MQTT</title>
    <url>/2021/02/25/mqtt/</url>
    <content><![CDATA[<blockquote>
<p>最近的小项目中需要使用mqtt作为服务端到硬件模块的传输协议，于是对MQTT进行了一些了解。<br>一开始总是云里雾里，通过知乎，论坛等平台文章进行了解后，记录下从我的角度第一次接触了解该协议需要了解理解的东西</p>
</blockquote>
<p><a href="https://www.emqx.cn/mqtt"><img src="/2021/02/25/mqtt/emqx-mqtt.png" alt="Emqx的MQTT介绍"></a><br><strong>MQTT协议是基于TCP建立的应用层协议，比TCP晚了25年。</strong>1999年IoT的概念刚被提出，Mqtt出现恰逢其时。</p>
<a id="more"></a>
<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031">Mqtt英文文档</a><br><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/">Mqtt中文文档</a></p>
<h1 id="TCP与MQTT的区别"><a href="#TCP与MQTT的区别" class="headerlink" title="TCP与MQTT的区别"></a>TCP与MQTT的区别</h1><h2 id="设计背景"><a href="#设计背景" class="headerlink" title="设计背景"></a>设计背景</h2><p>TCP最初被设计用于卫星基站间的通信，实现不同的短硬件之间可以互相通信。<br>Mqtt最初被设计用于石油管道的监控，将管道上的传感器信息传输到服务器上，实现石油管道的无人值守。需要实现：</p>
<ul>
<li>沿途鲜有网络设施，使用卫星通信更加经济，但需要注意流量的开销成本</li>
<li>管道线路长，传感器数量大，即客户端数量庞大，服务器要支持大量的客户端连接</li>
<li>通信频率低，且传输数据量较小</li>
<li>现场采集的网关数量大，cpu与存储资源有限。因此协议的客户端软件需要能在资源有限的单片机，RTU上运行</li>
<li>高轨卫星延迟高，低轨卫星覆盖面低，因此切换卫星时会出现网络中断。Server和Client需要具备保留消息收发状态的功能，保证恢复网络后的续传</li>
<li>需提供不同等级的消息服务质量，即优先级，且保证高优消息在恶劣网络环境中的可靠性</li>
</ul>
<blockquote>
<p>需要传输协议能够异步管理消息。在卫星通信中断时：MQTT网络中的服务器/代理可以保存和转发从客户端到客户端的消息，如果断开连接，它将能够在以后重新连接时获取消息。</p>
</blockquote>
<p><a href="https://www.zhihu.com/question/23373904/answer/636518156">参考文章</a></p>
<h2 id="协议定位"><a href="#协议定位" class="headerlink" title="协议定位"></a>协议定位</h2><p>TCP作为一种传输层的协议，以包package为传输单位。主要处理异构网络下的丢包，阻塞，乱序，重复问题<br>Mqtt作为一种应用层协议，以消息为单位。主要解决<strong>在低带宽延迟不可靠的资源有限的硬件环境下，进行相对可可靠的数据传输</strong>。<br>TCP通过ACK与重传机制，保证发送的数据可靠稳定收到；<strong>Mqtt提供三种可选的消息发布的Qos服务等级，Mqtt客户端和Mqtt代理服务器通过seeion机制保证消息的传输可靠性</strong>。</p>
<h1 id="消息服务等级"><a href="#消息服务等级" class="headerlink" title="消息服务等级"></a>消息服务等级</h1><p>由上所述，MQTT支持不同等级的消息服务。通过将消息等级分为qos0，qos1，qos2，简化消息发送不同等级质量的工作量。<br>Mqtt客户端和Broker端底层通过session保障不同的qos等级。</p>
<ul>
<li>根据<strong>topic</strong>划分消息业务，又灵活的topic订阅机制</li>
<li>异常情况下有LWT遗嘱机制，通知相应的topic订阅者客户端已离线</li>
<li>支持TLS，保证安全性</li>
</ul>
<p><a href="https://www.jianshu.com/p/6cf5a4c740f6">Qos机制讲解</a></p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>由于基于TCP实现，所以具有其拥有的缺点</p>
<ul>
<li>对网络环境要求较高</li>
<li>存在RST攻击，容易被运营商拦截</li>
<li>相对UDP消耗大，需要建立维护断开连接</li>
</ul>
<blockquote>
<p>MQTT就是观察者模式的网络放大版</p>
</blockquote>
<p><a href="https://www.runoob.com/w3cnote/mqtt-intro.html"><img src="/2021/02/25/mqtt/runoob-mqtt.png" alt="mqtt"></a><br>这是MQTT在实际应用中的<a href="https://zhuanlan.zhihu.com/p/110063556">一个例子</a>，可以从架构层面感受一下MQTT协议在实际应用中的位置。</p>
<h1 id="MQTT服务器"><a href="#MQTT服务器" class="headerlink" title="MQTT服务器"></a>MQTT服务器</h1><p>之后我打算通过实际的使用协议进行通信，实践中更好的体会一下。<br>Arduino社区有一位大佬写了<a href="https://www.arduino.cn/thread-82851-1-1.html">一篇帖子</a>，讲了一下从TCP到MQTT的连接以及关于Esp8266的编程。</p>
<h2 id="MQTT-nodejs实现broker"><a href="#MQTT-nodejs实现broker" class="headerlink" title="MQTT nodejs实现broker"></a>MQTT nodejs实现broker</h2><p>使用依赖：mosca mqtt<br><a href="https://www.jianshu.com/p/8315acec4e6b"><img src="/2021/02/25/mqtt/Vmsk2q.png" alt="mosca"></a></p>
<blockquote>
<p><a href="https://link.jianshu.com?t=https://github.com/mcollina/mosca">Mosca</a>是MQTT在Node.js中的一个Broker的开源实现，通俗讲也就是MQTT中的Server实现。<br> 同时作者也维护着<a href="https://link.jianshu.com?t=https://github.com/mqttjs/MQTT.js">MQTT.js</a>这一模块，这一模块大家可理解为MQTT的Client实现。而纵观整个Node.js的module中比较有分量的也就以上两个module.</p>
</blockquote>
<p>Mosca支持直接在命令行单独使用，<a href="https://itbilu.com/nodejs/npm/Ny_j-wsve.html">详见</a></p>
<p>当然也支持在node.js中进行调用。首先通过<code>new mosca.Server(&#123;port: xx&#125;)</code>的方式创建一个MqttServer实例，其中以json的格式配置port信息。然后一个mqtt服务器算是建立起来了</p>
<p>然后可以进行事件监听。目前知道几个事件tag</p>
<ul>
<li>clientConnected    有客户端连接时回调，回调参数是client，大概是客户端的实例，可以通过<code>client.id</code>获取客户端id</li>
<li>published        有消息推送到服务器时回调，参数是packet和client，大概是消息和客户端的实例。可以通过<code>packet.topic</code>获取时事件的主题</li>
<li>ready        server运行时回调</li>
</ul>
<p>订阅和发送MQTT消息时，甚至更加容易。<br>首先<code>mqtt.connect(&quot;mqtt://127.0.0.1:port&quot;)</code>连接到创建的服务器，得到一个client实例，然后可以通过该实例进行消息订阅和推送。<br>同样可以进行事件监听</p>
<ul>
<li>connect        服务器连接成功时的回调</li>
<li>message        收到消息时回调，当然，只会收到订阅过的消息<br><a href="https://blog.csdn.net/unforgettable2010/article/details/103918143">更多使用</a></li>
</ul>
<p>代码示例：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -----创建MQTT服务器-----</span></span><br><span class="line"><span class="keyword">const</span> mosca = <span class="built_in">require</span>(<span class="string">&quot;mosca&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> mosca.Server(&#123;</span><br><span class="line">  port: <span class="number">1883</span></span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">&quot;clientConnected&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 	客户端连接回调</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;A client connected..&quot;</span>, client.id);</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">&quot;published&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">packet, client</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> topic = packet.topic;</span><br><span class="line">  <span class="keyword">switch</span>(topic) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;MyTopic&quot;</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----连接MQTT服务器并订阅/推送消息-----</span></span><br><span class="line"><span class="keyword">const</span> mqtt = <span class="built_in">require</span>(<span class="string">&quot;mqtt&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> client = mqtt.connect(<span class="string">&quot;mqtt://127.0.0.1:1883&quot;</span>);</span><br><span class="line">client.on(<span class="string">&quot;connect&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 服务器连接成功回调</span></span><br><span class="line">  <span class="comment">// 订阅主题为MyTopic的消息</span></span><br><span class="line">  client.subscribe(<span class="string">&quot;MyTopic&quot;</span>, &#123;<span class="attr">qos</span>: <span class="number">1</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">client.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">top, message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;主题：&quot;</span> + top);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;内容：&quot;</span> + message.toString());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 推送主题为MyTopic的消息</span></span><br><span class="line">client.publish(<span class="string">&quot;MyTopic&quot;</span>, <span class="string">&quot;Hello World&quot;</span>, &#123;<span class="attr">qos</span>: <span class="number">0</span>, <span class="attr">retain</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="EMQX在线mqtt平台"><a href="#EMQX在线mqtt平台" class="headerlink" title="EMQX在线mqtt平台"></a>EMQX在线mqtt平台</h2><p>有很多提供Mqtt服务器的平台，例如这个<a href="https://www.emqx.cn/mqtt/public-mqtt5-broker">EMQX</a>（附<a href="https://blog.csdn.net/qq_46042542/article/details/107564395">使用介绍</a>）。实际上他也有客户端版本，可以支持在本地创建服务器，但是我没有下。<a href="http://tools.emqx.io/">tools.emqx.io</a>这个是该平台基于WebSocket实现的版本，一个免费的公共服务器，使用的远程第三方服务器。</p>
<p>相当于远程创建一个Mqtt服务器后，网页上以其中一个连接到该服务器的客户端呈现，可以发送自定义主题的消息，也可以创建subscriber，以对话的形式显示订阅消息的显示。</p>
<p>实际上创建这么一个服务器以后，理论上也是可以通过nodejs在本地订阅和发布的。但是我尝试了几种URI却没能连上服务器（也是在这里才知道这里用的是远程服务器）</p>
<p>后来通过<a href="https://zhuanlan.zhihu.com/p/259186061">这篇文章</a>了解到，协议应该是<strong><code>ws</code></strong>（WebSocket）而不是mqtt。因此使用以下方式可以连接到该公共服务器（<code>/mqtt</code>是网页配置的路径，其上可以看到）。<br>（可是多了一个子路径之后，有些库api要求只有ip和端口，应该怎么调用呢？？）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> client = mqtt.connect(<span class="string">&quot;ws://broker.emqx.io:8083/mqtt&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上几个比较重要的信息</p>
<ul>
<li>MQTT是基于TCP的应用层协议</li>
<li>MQTT由于报文紧凑等原因可以在低带宽高延迟的网络环境进行稳定传输，适用于大多数物联网开发数据传输</li>
<li>主要的通信模式是：存在一个MQTT服务器，连接到该服务端的终端通过消息订阅与推送机制收发消息</li>
</ul>
<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><h2 id="2021-05-08-MQTT-Return-Code"><a href="#2021-05-08-MQTT-Return-Code" class="headerlink" title="2021-05-08    MQTT Return Code"></a>2021-05-08    MQTT Return Code</h2><p>MQTT连接异常时会返回错误信息，其中携带返回码。根据返回码可以了解异常原因，附上<a href="https://www.vtscada.com/help/Content/D_Tags/D_MQTT_ErrMsg.htm">返回码文档</a><br><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0302-CONNACK.html">MQTT连接的请求报头信息</a></p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>秘籍帖</tag>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>低仿微信聊天界面的实现</title>
    <url>/2018/06/08/%E4%BD%8E%E4%BB%BF%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E7%95%8C%E9%9D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>概要：今天想运用一下已学的知识试着实现一下微信的聊天界面。主要实现的功能只是聊天内容的发送和显示。<br>这其实是《第一行代码》中的一个实战样例，主要想记录一下心得体会。</p>
</blockquote>
<a id="more"></a>
<h2 id="First"><a href="#First" class="headerlink" title="First"></a>First</h2><p>定义一个消息类Msg.class。主要属性有，消息的内容，消息的类型（接受的还是发送的），并定义两个方法用于get内容与类型。</p>
<h2 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h2><h4 id="布局主界面。"><a href="#布局主界面。" class="headerlink" title="布局主界面。"></a>布局主界面。</h4><p>界面主要是对话列表与底下的输入框及输入按钮组成。先定义一个RecyclerView列表布局，当然，需要现在build.gradle中先添加依赖。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.android.support:recyclerview-v7:24.2.1&#x27;</span></span><br><span class="line"><span class="comment">//官方已不支持使用compile</span></span><br></pre></td></tr></table></figure><br>然后就可以愉快的使用RecyclerView啦。</p>
<h4 id="对话列表布局"><a href="#对话列表布局" class="headerlink" title="对话列表布局"></a>对话列表布局</h4><p>布局完主界面就要对列表子项进行布局，即设置我们的对话框。新建一个message.xml，注意父布局宽度应为wrap_content。因为对话框接收与发送的方向不同，所以需要设置两个子布局，然后使用时再在代码中对其中一个进行隐藏。<br>接着是设置对话框的气泡图片。在网上搜到合适的对话框图片然后添加到res/drawable文件夹中。建议图片的尺寸最好小一点，这样最后效果好看一点。<br>这里还要插入一个知识点：</p>
<h5 id="Nine-Patch图片的使用"><a href="#Nine-Patch图片的使用" class="headerlink" title="Nine-Patch图片的使用"></a>Nine-Patch图片的使用</h5><p>以前制作.9图片，需要使用Android sdk/tools/draw9patch.bat，但AndroidStudio开始，就将此功能集成到了IDE中。只要右键png图片选择Create 9-Patch file即可创建。<br>.9图片有什么用呢，它能更方便于做出更好的图片效果。<br>打开.9.png，拖动图片边框黑点，左上边框用于定义图片可被拉长的部分，右下边框用于定义图片被添加内容时的位置，这样即使的我们布局时候更加方便。</p>
<h2 id="Third"><a href="#Third" class="headerlink" title="Third"></a>Third</h2><p>定义列表的配适器，建立recyclerview与数据间的联系<br>一直认为自定义列表配适器特别麻烦，但是写多了，思路也就清晰了。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>首先定义一个成员变量用于接收数据内容，一般是一个list。然后在构造方法中进行数据的赋值。<br>然后这个Adapter需要继承自RecyclerView.Adapter&lt;Adapter类名.HolderView&gt;</p>
<h4 id="定义一个子类ViewHolder类（继承自RecyclerView-Holder）"><a href="#定义一个子类ViewHolder类（继承自RecyclerView-Holder）" class="headerlink" title="定义一个子类ViewHolder类（继承自RecyclerView.Holder）"></a>定义一个子类ViewHolder类（继承自RecyclerView.Holder）</h4><p>这个类用于缓存数据内容，无需重复获取控件的实例，提高list的运行效率。<br>首先定义成员变量，都是需要缓存的数据或控件。接着是构造方法，需传入一个RecyclerView子项的最外层布局的view，直接传给ViewHolder的父级构造方法，然后开始对view中的控件进行获取和赋值。</p>
<h4 id="加载布局，在代码中获取并将布局返回"><a href="#加载布局，在代码中获取并将布局返回" class="headerlink" title="加载布局，在代码中获取并将布局返回"></a>加载布局，在代码中获取并将布局返回</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.message, parent, <span class="keyword">false</span>);</span><br><span class="line">        ViewHolder holder = <span class="keyword">new</span> ViewHolder(view);</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码一般没有太多改动，其中R.layout.message是要加载布局的定义。</p>
<h4 id="将数据添加到布局中，子项滚动进入屏幕时执行"><a href="#将数据添加到布局中，子项滚动进入屏幕时执行" class="headerlink" title="将数据添加到布局中，子项滚动进入屏幕时执行"></a>将数据添加到布局中，子项滚动进入屏幕时执行</h4><p>在这里进行消息类型的判断，用setVisibility()对布局进行显示或隐藏。</p>
<p>####<br>最后是一个每次必须重写的方法，获取子项个数。</p>
<p>自此Adapter就已经准备完毕，逐个理解并多加实践便不会觉得太复杂。</p>
<h2 id="Forth"><a href="#Forth" class="headerlink" title="Forth"></a>Forth</h2><p>到此一切准备就绪，可以开始编写MainActivity。</p>
<p>首先定义数据列表，msg配适器，获取EditText，Button，RecyclerView实例，定义一个LinearLayoutManager，指定RecyclerView的布局方式</p>
<p>然后将数据列表传入配适器，指定RecyclerView的配适器。</p>
<p>最后设置Button的点击事件，先获取输入框内容新建一个Msg对象并添加到列表，</p>
<p>使用<strong>adapter.notifyItemInserted(list.size() - 1)</strong>，实现有新消息时刷新RecyclerView的显示</p>
<p>然后<strong>recyclerview.scrollToPosition(list.size() - 1)</strong>，实现将RecyclerView定位到最后一行，使每次增加对话后不会回到顶部。</p>
<p>到这里就大功告成了。<br>如果愿意的话，可以先初始化一部分Msg数据用于一开始的显示。</p>
<hr>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>下面贴出源代码</p>
<p>MainActivity.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.widget.LinearLayoutManager;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.widget.RecyclerView;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Msg&gt; msgList = <span class="keyword">new</span> ArrayList&lt;Msg&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RecyclerView msgRecycleView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MsgAdapter adapter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinearLayoutManager manager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        initMsg();</span><br><span class="line">        msgRecycleView = (RecyclerView) findViewById(R.id.list);</span><br><span class="line">        manager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">        msgRecycleView.setLayoutManager(manager);</span><br><span class="line">        adapter = <span class="keyword">new</span> MsgAdapter(msgList);</span><br><span class="line">        msgRecycleView.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">        Button send = (Button) findViewById(R.id.send);</span><br><span class="line">        textView = findViewById(R.id.text);</span><br><span class="line">        textView.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        send.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                String content = textView.getText().toString();</span><br><span class="line">                Msg msg = <span class="keyword">new</span> Msg(content ,<span class="number">1</span>);</span><br><span class="line">                msgList.add(msg);</span><br><span class="line">                msgRecycleView.setLayoutManager(manager);</span><br><span class="line">                adapter = <span class="keyword">new</span> MsgAdapter(msgList);</span><br><span class="line">                msgRecycleView.scrollToPosition(msgList.size() -<span class="number">1</span>);</span><br><span class="line">                msgRecycleView.setAdapter(adapter);</span><br><span class="line">                textView.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Msg msg_1 = <span class="keyword">new</span> Msg(<span class="string">&quot;Hello, How are you?&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        msgList.add(msg_1);</span><br><span class="line">        Msg msg_2 = <span class="keyword">new</span> Msg(<span class="string">&quot;I am fine! Thank you!&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        msgList.add(msg_2);</span><br><span class="line">        Msg msg_3 = <span class="keyword">new</span> Msg(<span class="string">&quot;Oh yeah! I am from Guangzhou, are you?&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        msgList.add(msg_3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>MsgAdapter.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.support.v7.widget.RecyclerView;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">MsgAdapter</span>.<span class="title">ViewHolder</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Msg&gt; list;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> TextView leftContent;</span><br><span class="line">        <span class="keyword">protected</span> TextView rightContent;</span><br><span class="line">        <span class="keyword">protected</span> LinearLayout leftLayout;</span><br><span class="line">        <span class="keyword">protected</span> LinearLayout rightLayout;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(v);</span><br><span class="line">            leftLayout = (LinearLayout) v.findViewById(R.id.left_layout);</span><br><span class="line">            rightLayout = (LinearLayout) v.findViewById(R.id.right_layout);</span><br><span class="line">            leftContent = (TextView) v.findViewById(R.id.left);</span><br><span class="line">            rightContent = (TextView) v.findViewById(R.id.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MsgAdapter</span><span class="params">(List&lt;Msg&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.message, parent, <span class="keyword">false</span>);</span><br><span class="line">        ViewHolder holder = <span class="keyword">new</span> ViewHolder(view);</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        Msg message = list.get(position);</span><br><span class="line">        <span class="keyword">if</span>(message.getType() == <span class="number">0</span>)&#123;</span><br><span class="line">            holder.leftContent.setText(message.getContent());</span><br><span class="line">            holder.leftLayout.setVisibility(View.VISIBLE);</span><br><span class="line">            holder.rightLayout.setVisibility(View.GONE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(message.getType() == <span class="number">1</span>)&#123;</span><br><span class="line">            holder.rightContent.setText(message.getContent());</span><br><span class="line">            holder.rightLayout.setVisibility(View.VISIBLE);</span><br><span class="line">            holder.leftLayout.setVisibility(View.GONE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Msg.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.minions.uibestpractice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Msg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> type_recrived = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> type_send = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Msg</span><span class="params">(String content, <span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>activity_main.xml<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span>&gt;</span><br><span class="line">    &lt;android.support.v7.widget.RecyclerView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/list&quot;</span></span><br><span class="line">        android:layout_weight=<span class="string">&quot;1&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;0dp&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/android.support.v7.widget.RecyclerView&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:orientation=<span class="string">&quot;horizontal&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span>&gt;</span><br><span class="line">        &lt;EditText</span><br><span class="line">            android:id=<span class="string">&quot;@+id/text&quot;</span></span><br><span class="line">            android:layout_weight=<span class="string">&quot;1&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;0dp&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;match_parent&quot;</span> /&gt;</span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id=<span class="string">&quot;@+id/send&quot;</span></span><br><span class="line">            android:background=<span class="string">&quot;#9090&quot;</span></span><br><span class="line">            android:textColor=<span class="string">&quot;#fff&quot;</span></span><br><span class="line">            android:layout_margin=<span class="string">&quot;3dp&quot;</span></span><br><span class="line">            android:text=<span class="string">&quot;Send&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><br>message.xml<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">    android:padding=<span class="string">&quot;10dp&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:id=<span class="string">&quot;@+id/left_layout&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;left&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:background=<span class="string">&quot;@drawable/message_left&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:textSize=<span class="string">&quot;25dp&quot;</span></span><br><span class="line">            android:id=<span class="string">&quot;@+id/left&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:id=<span class="string">&quot;@+id/right_layout&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;right&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:background=<span class="string">&quot;@drawable/message_right&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=<span class="string">&quot;@+id/right&quot;</span></span><br><span class="line">            android:textSize=<span class="string">&quot;25dp&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>秘籍帖</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea报错：限制口令文件读取访问权限</title>
    <url>/2019/07/07/%E5%85%B3%E9%97%ADJVM%E5%AE%89%E5%85%A8%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>此先说明，我的操作系统环境是deepin-15.10.2。Tomcat版本是9.0.13<br>某天将JetBrains-Idea从182更新到191后（是了一百年没更新了），正常启动tomcat跑程序时候，突然刷的一下报错</p>
<blockquote>
<p><strong>错误: 必须限制口令文件读取访问权限: …/.IntelliJIdea/system/tomcat/Test/jmxremote.password </strong></p>
</blockquote>
<p>（心急的旁友直接看下边方案吧，不着急可以看看我的解决过程噢..）</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p><strong>在TomcatHome/bin/catalina.sh文件中添加以下参数，位置大概在原文注释以后，所有代码以前</strong></p>
<blockquote>
<p>JAVA_OPTS=”$JAVA_OPTS -Dcom.ibm.team.jfs.app.oauth.OAuthHelper.disableSecureCookies=true”<br>JAVA_OPTS=”$JAVA_OPTS -Dcom.sun.management.jmxremote.authenticate=false”<br>JAVA_OPTS=”$JAVA_OPTS -Dcom.sun.management.jmxremote.ssl=false”</p>
</blockquote>
<a id="more"></a>
<h1 id="填坑过程"><a href="#填坑过程" class="headerlink" title="填坑过程"></a>填坑过程</h1><p>（开始讲故事…）<br>一开始我是一脸懵逼啊，从来没见过这样的问题，遂Google。原来是因为 <strong>jmxremote.password 文件中存储了明文密码，所以此文件必须只能由所有者读取，否则程序将关闭并报错</strong> 。<br>虽然不知道细节但是既然如此chmod走一波…并未生效？？重复几次，仍如此。<br>在linux中摸爬滚打多（== 2）年的我预感到了，这大概又是一个大坑。果不其然，Google得知， <strong>linux无法修改其他磁盘分区的文件，chmod只能在linux分区下生效，否则权限改不了,因为FAT或NTFS文件系统中根本没有linux中的这些文件权限的概念</strong> 。 <a href="http://www.voidcn.com/article/p-aoxdvfon-tc.html">出处在此</a><br>但是搜索原来问题给出的解决方法都是修改文件权限，Windows下直接修改或者linux下chmod操作，并不能为我所用。于是灰溜溜的滚回去用182版本。<br>三个月后也就是今天，刚重装了Deepin又解决了一堆坑的我决定（顺便）直面这个问题。这次我决定从两个版本为什么会不一样看起。对比了下前面目录下各个工程的文件，发现只有新版本的文件下会有jmxremote.password和jmxremote.access。这其实是tomcat使用JMX安全连接所需的安全认证证书密码。JMX使用SSL认证启动后，即可以使用https访问tomcat服务器了。<a href="https://www.ibm.com/support/knowledgecenter/zh/SSYMRC_6.0.1/com.ibm.jazz.repository.web.admin.doc/topics/t_server_mon_tomcat_option3.html">配置方法</a></p>
<blockquote>
<p>自Java 6开始，Java程序启动时都会在JVM内部启动一个JMX agent，JMX agent会启动一个MBean server组件，把MBeans（Java平台标准的MBean + 你自己创建的MBean）注册到它里面，然后暴露给JMX client管理。简单来说就是每个Java程序都可以通过JMX来被JMX client管理，而且这一切都是自动发生的。而VisualVm就是一个JMX Client。<br>VisualVm能够自动发现本机的Java进程，如果要监控远程主机上的Java进程则需要显式地配置JMX连接。</p>
</blockquote>
<p>附： <a href="https://chanjarster.github.io/post/visualvm-remote-monitoring-jmx/">JMX监听Java程序</a>/<a href="https://www.ibm.com/support/knowledgecenter/zh/SSHS8R_8.0.0/com.ibm.worklight.installconfig.doc/install_config/t_optional_config_app_server_tomcat.html">tomcat配置JMX连接</a>的配置方法</p>
<p>我认为,也就是说程序默认开启安全性设置，所以需要用到证书和密码，那如果我不需要安全连接，是不是可以关闭安全性设置，能像以前一样不需要证书密码，那么密码文件的权限也就无所意义了呢。<br>那么问题来了，如何关闭安全连接呢。我猜测大概是修改Java的运行时参数。问题又来了，直接在Idea中添加运行时参数吗？感觉有点蠢。。<br>我又想起tomcat启动时一般是调用的启动文件启动，也许就是在那里新增了对安全性设置的修改。<br>打开TomcatHome/bin/，找到startup.sh（startup.bat是Windows用的启动文件，其实Windows下是执行bin/tomcat.exe，直接读取的注册表的值），打开一看好像比较简单，没有类似运行时参数的配置格式。后来发现tomcat启动时主要调用的文件是Catalina.sh文件，是它了。（一开始是听到直接在cetenv.sh文件上添加参数，没有该文件的自己新建即可，新建完运行发现自动读取该文件了，但是参数都是not found不知道怎么回事..）<br>又翻了好久关于在启动文件中添加参数的格式，因为源文件中都是以脚本语言的形式添加的。</p>
<p>细化问题后，终于找到了解决方案。<br><a href="https://www.ibm.com/support/knowledgecenter/zh/SSYMRC_6.0.1/com.ibm.jazz.repository.web.admin.doc/topics/t_server_mon_tomcat_option1.html">不使用安全认证在Tomcat上激活JMX</a><br><a href="https://www.ibm.com/support/knowledgecenter/zh/SSYMRC_6.0.0/com.ibm.jazz.install.doc/topics/t_disable_server_certificates.html">禁用安全证书设置</a></p>
<p>于是添加以下参数到catalina.sh中，位置大概在原文注释以后，代码开始的地方吧(我觉得大概是无所谓的)..</p>
<blockquote>
<p><strong>JAVA_OPTS=”$JAVA_OPTS -Dcom.ibm.team.jfs.app.oauth.OAuthHelper.disableSecureCookies=true”</strong><br><strong>JAVA_OPTS=”$JAVA_OPTS -Dcom.sun.management.jmxremote.authenticate=false”    // 关闭身份验证</strong><br><strong>JAVA_OPTS=”$JAVA_OPTS -Dcom.sun.management.jmxremote.ssl=false”     // 关闭ssl连接</strong></p>
</blockquote>
<p>加完运行，居然成功了</p>
<h1 id="开始叭叭"><a href="#开始叭叭" class="headerlink" title="开始叭叭"></a>开始叭叭</h1><p>感动之余，发现即使不修改catalina.sh，在182版本中这些参数也会在运行日志中打印出来，说明182中这是默认的设置，但是191中就炸了。<br>因此我猜测，大概是191新版本中将安全连接设为了必须。但询问发现周围小伙伴都没有见过相关的问题（有我也不用困扰这么久了），但也许是因为他们使用的Windows所以密码文件的读取权限没有问题所以没有发现这个更新呢？<br>算了，至少问题总算解决（至少目前看来是这样的），写了三个月的后端，我都差点忘了自己其实是个android程序员了。。（虽说程序员不该界定自己的技术栈吧，，）</p>
<h1 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h1><p>由于该问题研究过程中，关联到太多的细节和底层问题，所以文中有些部分是自己结合技术文章的见解，有可能不是正解（这些部分我都有写明）而且最后方案不一定是准确解决了症结，但它确确实实解决了我的问题来的。写这篇文章的目的主要为了记录这次填坑之旅所遇到及了解到的知识，因此有其他意见希望向我提出交流。</p>
<p>博客的留言功能还没有折腾，欢迎发我[邮箱 <a href="mailto:xiaohuangren028@gmail.com">xiaohuangren028@gmail.com</a>]啊。</p>
<hr>
<p>关于修改密码文件的权限，后来我又找到<a href="https://www.cnblogs.com/Dhouse/p/7827175.html">这篇博客</a>，其中提到权限修改失败还有可能是因为方式错误。</p>
<blockquote>
<p>在配置JMX远程访问的时候，设置jmxremote.password文件权限，修改该文件时添加写权限，chmod +w jmxremote.password ，放开角色信息那俩行的注释，保存，再使用chmod 0400 jmxremote.password<br>这样就是它正确的权限设置<br>jmxremote.password 在jdk/jre/lib/management/下，jmxremote.password.template复制，去掉.template后缀</p>
</blockquote>
<p>如果不是因为挂载原因无法修改权限的，可以尝试以上方法。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>技能帖</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Android Studio后释放C盘的一系列操作</title>
    <url>/2018/07/23/%E5%AE%89%E8%A3%85AS%E5%90%8E%E9%87%8A%E6%94%BEC%E7%9B%98%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>  相信对于不少像我这样的“强迫症”一样的安卓开发者来说，面对安装Android Studio之后日渐臃肿的C盘肯定无法接受。下面给出这些天重装AS以后，查阅总结的C盘瘦身大法（只针对Android Studio）。</p>
<a id="more"></a>
<h2 id="更改SDK安装路径"><a href="#更改SDK安装路径" class="headerlink" title="更改SDK安装路径"></a>更改SDK安装路径</h2><p>  首先找到SDK的安装目录，一般默认是在C:\Users\用户名\AppData\Local\Android\sdk文件夹中。然后将SDK文件剪切到任意目录下，然后启动AS，打开<strong> File -&gt; Other Settings -&gt; Default Project Structure</strong>，可以看到Android SDK location，将SDK新路径的绝对路径粘贴进去，然后点击Apply即可。</p>
<h2 id="更改安卓虚拟机（AVD）储存路径"><a href="#更改安卓虚拟机（AVD）储存路径" class="headerlink" title="更改安卓虚拟机（AVD）储存路径"></a>更改安卓虚拟机（AVD）储存路径</h2><h4 id="转移AVD文件夹"><a href="#转移AVD文件夹" class="headerlink" title="转移AVD文件夹"></a>转移AVD文件夹</h4><p>  首先找到AVD的存储目录，一般默认是在C:\Users\用户名.android\avd中。将其中的虚拟机文件夹剪切到任意目录，留下其对应的ini配置文件。然后打开修改ini文件，将其中的path值由原来的路径修改为AVD的新路径。如：<br> <img src="/2018/07/23/%E5%AE%89%E8%A3%85AS%E5%90%8E%E9%87%8A%E6%94%BEC%E7%9B%98%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E6%93%8D%E4%BD%9C/AVD.png" alt="AVD"></p>
<h4 id="更改AVD默认储存位置"><a href="#更改AVD默认储存位置" class="headerlink" title="更改AVD默认储存位置"></a>更改AVD默认储存位置</h4><p>  这里是使以后创建的AVD都默认储存到指定的新目录，需要设置环境变量。安装Java大概都折腾过。现在在系统变量处，新建，变量名为ANDROID_SDK_HOME，变量的值即为AVD的新目录。例如新目录为D:\Windows\Android\AVD，则将在AVD文件夹下创建.android\avd目录，里边存放虚拟机及其配置文件。<br>  如果遇到后install apps失败的问题，到 <strong>file -&gt; settings</strong> 修改设置，取消首行的勾选，重启AVD。</p>
<h2 id="更改AS配置文件储存位置"><a href="#更改AS配置文件储存位置" class="headerlink" title="更改AS配置文件储存位置"></a>更改AS配置文件储存位置</h2><p>  在Android Studio的安装目录下，找到bin\idea.properties文件，打开修改。每次启动AS时，会加载此文件，读取config,system,plugins,log等配置信息。按照他的提示分别加入各个配置的相关路径信息即可。如<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">idea.config.path&#x3D;$&#123;user.home&#125;&#x2F;.AndroidStudio&#x2F;config</span><br><span class="line">	&#x2F;&#x2F;只需要替换$&#123;user.home&#125;的内容，可为任意路径。config再分别改为system,plugins,log即可</span><br></pre></td></tr></table></figure><br>算了还是上个图比较清楚：<br><img src="/2018/07/23/%E5%AE%89%E8%A3%85AS%E5%90%8E%E9%87%8A%E6%94%BEC%E7%9B%98%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E6%93%8D%E4%BD%9C/idea_properties.png" alt="idea.properties"><br>重启Android Studio生效。</p>
<h2 id="更改Gradle缓存目录"><a href="#更改Gradle缓存目录" class="headerlink" title="更改Gradle缓存目录"></a>更改Gradle缓存目录</h2><p>  一般情况下，gradle存放于C:\Users\用户名.gradle中，大小竟接近1G，表示无法接受，所以必须采取措施。<br>  首先更改Android Studio中的设置。Ctrl+Alt+S打开studio的 Settings -&gt; Build,Execution,Deployment -&gt; Gradle，如下图，<br>  <img src="/2018/07/23/%E5%AE%89%E8%A3%85AS%E5%90%8E%E9%87%8A%E6%94%BEC%E7%9B%98%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E6%93%8D%E4%BD%9C/Gradle路径.png" alt="Gradle路径"><br>  红框中的路径原为C盘内，修改为任意路径。有的教程还需要添加环境变量，其实没有必要。然后回到.gradle原路径将整个文件夹剪贴到刚刚设定的路径下即可。但我复制时候因为有两个文件无法进行剪切，跳过以后，工程rebuild一直无法成功，各种标红，各种报错<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Activity is not an Activity subclass or alias.</span><br><span class="line">Validates resource references inside Android XML files.</span><br></pre></td></tr></table></figure><br>  clean project 或清理缓存都无济于事。于是我一气之下，删除了.gradle文件，然后重新锤了Android Studio (Make Project)，也就是重新从官网下载了gradle文件，花了十分钟，解决一切毛病。其实不需要删除整个文件，留下wrapper中的<strong>gradle-4.1-milestone-1-all.zip</strong>，Studio锤后会对其进行解压与相关依赖的下载。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技能帖</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Hexo博客与github部署指南</title>
    <url>/2018/05/11/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E4%B8%8Egithub%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>因为经常会要用到Git以及Github，首先安装Git：<a href="https://git-scm.com/download/linux">https://git-scm.com/download/linux</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt update; apt install git</span><br></pre></td></tr></table></figure></p>
<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>Hexo是一款基于Node.js的静态博客框架，所以我们还需要安装它：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br>下载后移动到任意路径下解压，tar.xz解压命令为tar -xvJf 。然后建立全局软链接（全局变量）<br>sudo ln -s /../node.js/bin/npm /usr/local/bin/<br>sudo ln -s /../node.js/bin/node /usr/local/bin<br>然后检测是否成功<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><br>如果成功会出现版本号，这里是v8.11.1与5.6.0<br>附： <a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">node.js源码安装教程</a></p>
<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>然后开始安装Hexo。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g        //这是用npm方式部署hexo静态博客。</span><br></pre></td></tr></table></figure><br>遇到安装异常sh: 1: node-gyp: Permission denied，运行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> unsafe-perm <span class="literal">true</span>       //以后，再运行</span><br><span class="line">npm install -g hexo-cli          //但是我好像没有遇到这个问题。</span><br></pre></td></tr></table></figure><br>我的话主要是教程里都没有提醒我创建hexo的全局变量，导致我一直显示未找到命令。创建了变量后就成功了。这里用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><br>若出现版本信息，则安装成功，已在本地机器上搭建起了Hexo环境。</p>
<h3 id="部署Hexo文件夹。"><a href="#部署Hexo文件夹。" class="headerlink" title="部署Hexo文件夹。"></a>部署Hexo文件夹。</h3><p>任意位置创建文件夹hexo，在该文件夹内初始化hexo<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init             //将该文件夹初始化为博客目录   </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><br>安装相关依赖包，具体安装内容可以在package.json文件里找到<br>其中，_config.yml是配置站点的文件，public是hexo生成的静态站点文件夹，scaffolds是模板文件夹，source是存在用户资源的文件夹，themes是主题文件夹。接着<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><br>生成hexo静态页面，将我们写的Markdown文件 (.md后缀) 转换成html静态页面<br>生成完毕之后，hexo文件夹内又多了一个public文件夹，这就是静态博客的目录，如果我们需要部署到服务器或者托管平台，只要将hexo生成静态之后，将public文件夹里的文件传上去就可以了。其他系统文件还是放在本地。</p>
<h3 id="博客预览"><a href="#博客预览" class="headerlink" title="博客预览"></a>博客预览</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>然后在浏览器中输入地址<a href="http://localhost:4000">http://localhost:4000</a><br>使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server -p 5000</span><br></pre></td></tr></table></figure><br>可以改变接入端口。默认接入端口为4000。但是听说如果打开了福昕阅读器，他会占用4000端口。<br>也可以在_config.yml内加上如下代码更改hexo-server运行时的端口号：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 5000</span><br><span class="line">  compress: <span class="literal">true</span></span><br><span class="line">  header: <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>也可以先使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ant |grep 4000</span><br></pre></td></tr></table></figure><br>命令查看端口被什么占用，若是个没人用的东西,就kill掉这个进程</p>
<h3 id="进一步配置"><a href="#进一步配置" class="headerlink" title="进一步配置"></a>进一步配置</h3><p>找到博客根目录下的配置文件_config.yml，# Site部分，title是博客的名字，subtitle是副标题，author即为作者名字。</p>
<p>接下来是下一部分：</p>
<p>#将Hexo托管到Github<br>首先现在Github账户上新建一个仓库，作为以后博客的存放位置。仓库名为GithubUserName.github.io，然后Create</p>
<p>配置Github：<br>配置Name和Email:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;yourName&quot;</span></span><br><span class="line">$ git config --global user.eamil <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure><br>在某个项目根路径下面可以设置单独的Email与姓名:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.name <span class="string">&quot;tiemaocsdn&quot;</span></span><br><span class="line">git config user.email <span class="string">&quot;tiemaocsdn@qq.com&quot;</span></span><br></pre></td></tr></table></figure><br>创建公钥<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -C <span class="string">&quot;email@example.com&quot;</span> -t rsa</span><br></pre></td></tr></table></figure><br>在用户~/.ssh/下建立相应的密钥文件~/.ssh/id-rsa.pub，gedit打开该文件，复制文本。<br>添加公钥：<br>在Github首页点击setting，选择New SSH KEY，然后将密钥文件复制进去。</p>
<p>Hexo部署到github<br>打开hexo文件下的_config_yml，在底部添加<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/GithubUserName/GithubUserName.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><br>注：这是关键点！首先：后边必须有一个空格！然后次行repo有的教程是repository，听说会有bug；然后几乎所有教程io后会加.git，其实不用不知道为什么。最靠谱的是直接将你的仓库地址复制过来。<br>最后，因为hexo3.0以后deploy与hexo分离，所以还添加个插件就能将博客push到git上<br>npm install hexo-deployer-get –save</p>
<p>然后不要忘了上传<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br><span class="line">hexo g  为生成静态文件</span><br><span class="line">hexo g -d  为文件生成后立即部署网站</span><br><span class="line">或者hexo g  然后hexo d也行</span><br><span class="line">hexo d -g  为部署网站前生成静态文件</span><br><span class="line"></span><br><span class="line">git push [-u origin master]  仓库数据进行同步</span><br><span class="line">git pull 每次修改前进行更新</span><br></pre></td></tr></table></figure><br>编写博客<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;博客名&quot;</span></span><br><span class="line">显示博客的.md文件地址，打开即可编写</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></p>
<h2 id="本地Git库与远程仓库（Github）的关联建立"><a href="#本地Git库与远程仓库（Github）的关联建立" class="headerlink" title="本地Git库与远程仓库（Github）的关联建立"></a>本地Git库与远程仓库（Github）的关联建立</h2><p>只有在本地初始化git后才能使用git。<br>选择一个文件夹，执行命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init  初始化该本地文件夹为git管理的本地仓库</span><br></pre></td></tr></table></figure><br>注：Git将自动创建唯一一个master分支。当前目录下多了一个.git的目录（隐藏文件夹），这个目录是Git来跟踪管理本地库的，修改文件需谨慎，易破坏Git仓库。可通过删除目录来断开本地仓库与远程仓库的连接，就像刚刚没有创建本地仓库，每次更新都需要输入用户名与密码。<br>关联指定远程仓库<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:YotrolZ/helloTest.git</span><br></pre></td></tr></table></figure><br>注：origin即为远程库的名字，这是Git默认的叫法，可以改成别的;<br><a href="mailto:git@github.com">git@github.com</a>:YotrolZ/helloTest.git 为我们远程仓库的路径，可为url或仓库名。这里还直接仓库地址保险。</p>
<p>此时，可以尝试git pull拉取。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>技能帖</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio检查并安装最新版本的依赖</title>
    <url>/2018/09/09/%E6%A3%80%E6%9F%A5%E5%B9%B6%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h2 id="Android-Studio检查并安装最新版本的依赖"><a href="#Android-Studio检查并安装最新版本的依赖" class="headerlink" title="Android Studio检查并安装最新版本的依赖"></a>Android Studio检查并安装最新版本的依赖</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>之前我曾经在<a href="https://codeminions.github.io/2018/05/26/android_studio%E7%9A%84%E5%9D%91/">as标红解决办法</a>的差不多结尾部分介绍过关于as添加依赖的方法，这也一直被我奉为添加最新依赖版本的最好方法，直到最近这法子不好用了…</p>
<a id="more"></a>
<h3 id="新的方法"><a href="#新的方法" class="headerlink" title="新的方法"></a>新的方法</h3><p>最近想要导入com.android.support.desgin库的最新版本，但是在Project Structure里边却不能找到最新的版本，且无法下载导入。（但是今天再试一遍又可以了…网不好？？？）<br>因祸得福，我找到了另一种方法查询最新的版本。祭出地址如下 <strong><a href="http://mvnrepository.com">mvnrepository</a></strong></p>
<ul>
<li>进入后输入框输入你想查找的类，这里已design为例。找到你想要的那个库（完整库名）。点击进入…<br><img src="/2018/09/09/%E6%A3%80%E6%9F%A5%E5%B9%B6%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E4%BE%9D%E8%B5%96/依赖包版本1.png" alt=""></li>
<li>看到其详情界面，选择好发布者（应该是发布者吧…），<br>这里是google。就可以看到这个库的所有历史版本。点进去可能有连接啥的吧，反正我是直接把版本号复制到build.gradle。<br><img src="/2018/09/09/%E6%A3%80%E6%9F%A5%E5%B9%B6%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E4%BE%9D%E8%B5%96/依赖包版本2.png" alt=""></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以现在添加最新依赖有两个方法了。一个是Project Structure查找直接添加，一个是到Mvnrepository查询版本号再手动添加。讲道理这两个方法应该可以保我在添加依赖的道路上一帆风顺吧。。。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技能帖</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Java锁机制</title>
    <url>/2020/10/24/%E6%B5%85%E8%B0%88Java%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>锁的概念，来自于操作系统。<br>在操作系统中，进程是内存独立，实现进程间的通信需要通过一些其他的手段；但是线程之间是内存共享的，当有多个线程对某一临界资源（有可能被多个线程访问，存在线程安全的数据）进行读写访问时，就会出现线程安全的问题。<br><em>锁概念</em></p>
<a id="more"></a>
<p>根据锁对访问限制规则的不同，可以将锁进行分类。下面介绍一下在Java中主要的锁。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><h3 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h3><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><h2 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h2><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><h2 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h2><h1 id="Java锁实现"><a href="#Java锁实现" class="headerlink" title="Java锁实现"></a>Java锁实现</h1><p>在Java中，除了使用关键字synchronized进行加锁，在Java5以后，还引入了一个juc包，其中增加了许多适用于Java的线程安全的实现，比如一系列Lock类。<br>实现Lock的锁类型，可以通过lock.lock()或lock.unLock()进行灵活的加锁和释放锁。其底层实现原理其实是通过Java代码调用native层，再调系统接口实现的。而synchronized则主要是JVM层实现。这里主要讲一下synchronized的运作机制。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><img src="https://upload-images.jianshu.io/upload_images/2062729-b98084591219da8c.png" style="zoom:40%;" /></p>
<p>可以看到，经过编译以后，synchronized关键字的代码块，会被编译为两个虚拟机指令，分别对应着加锁和释放锁操作。</p>
<p>这里我想说一下自己对加锁的理解。Java中的加锁操作，其实是把某个对象当做锁（monitor），也就是每一个对象都是一个锁，对象头中的MaskWord中，记录着该对象的锁状态及拥有的线程信息。</p>
<p>当代码运行进入到同步代码块中，执行monitorenter指令，jvm会去尝试获取monitor的所有权。如果monitor的进入数为0，则线程可以拥有该monitor，并且进入数置1。synchronized是一种可重入锁，因此如果获取所有权时发现已有线程拥有，但是同一个线程，则可以直接进入，并且进入数+1。</p>
<p>当同步代码块运行结束，执行monitorexit，jvm会先去判断，执行该指令的必须是monitor的拥有者，然后进入数-1。如果进入数为0，则该线程不再是该monitor拥有者。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-8b7734120fae6645.png" style="zoom:40%;" /></p>
<blockquote>
<p>两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p>
</blockquote>
<h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>在Java1.6以前，synchronized的性能是比较糟糕的，比不上Lock。但是在Java1.6以后，对synchronized做了性能优化，和Lock其实是并驾齐驱的，可以根据具体场景进行选择。</p>
<p>在1.6中，synchronized增加了一个锁升级的过程。</p>
<p>首先，synchronized默认是乐观锁，可以认为是无锁，即假设没有线程竞争，通过cas操作实现。</p>
<p>如果锁一直只被一个线程持有，那么乐观锁转变为偏向锁。直接检测对象头里是否存在该线程id，而不是用cas操作，进而提高了性能。并且不会主动释放偏向锁。</p>
<p>当有其他线程访问同步代码块时，锁会升级为轻量锁，区别在于等待线程会进行自旋</p>
<p>自旋超过一定次数 或者有第三个线程竞争，则升级为重量锁，等待的线程直接挂起</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>秘籍帖</tag>
      </tags>
  </entry>
  <entry>
    <title>递归小结</title>
    <url>/2018/01/01/%E9%80%92%E5%BD%92%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>关于递归<br>这几日作递归题，一直都没什么思路，常常需要看看答案才能懂</p>
<p>幸亏，答案看着看着，好像可以大概总结出一套<strong>模板</strong>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">arguments</span>):</span></span><br><span class="line">	赋初值，定义容器</span><br><span class="line">	<span class="keyword">if</span> conditions条件：</span><br><span class="line">		返回值，递归，改变参数，‘循环体’</span><br><span class="line">		（返回值处理）</span><br><span class="line">		<span class="keyword">return</span> 返回值</span><br><span class="line">	<span class="keyword">else</span>：</span><br><span class="line">		<span class="keyword">return</span> 开始递归</span><br></pre></td></tr></table></figure><br>典例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def Bindec(x):</span><br><span class="line">	result &#x3D; &#39; &#39;</span><br><span class="line">	if x :</span><br><span class="line">		result &#x3D; Bindec(x &#x2F;&#x2F; 2)</span><br><span class="line">		return result + str(x % 2)</span><br><span class="line">	else:</span><br><span class="line">		return result</span><br><span class="line">print(&quot;二进制数为：&quot;,Bindec(1024))</span><br></pre></td></tr></table></figure></p>
<p><strong>递归分为递推和回推，注意返回条件设置</strong></p>
<p>总结出了模板，做题居然就不费劲了，我觉得主要是把上面的理论成功转化为了编程理论，所以思路顺畅了。</p>
<p>但模板还比较死，注意变通，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拆分参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">x</span>):</span></span><br><span class="line">	result = <span class="built_in">list</span>()</span><br><span class="line">	<span class="keyword">if</span> x:</span><br><span class="line">		result = get(x // <span class="number">10</span>)</span><br><span class="line">		result.append(x % <span class="number">10</span>)</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line"><span class="comment">#简单版</span></span><br><span class="line">result = <span class="built_in">list</span>()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple</span>(<span class="params">x</span>):</span></span><br><span class="line">	<span class="keyword">if</span> x:</span><br><span class="line">		result.insert(<span class="number">0</span>, x%<span class="number">10</span>)</span><br><span class="line">		simple(x//<span class="number">10</span>)</span><br><span class="line">i = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入一个数：&quot;</span>))</span><br><span class="line">print(get(i)) ; </span><br><span class="line">simple(i) ;</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>这道题标答中并不像我返回并放好列表元素，它递归直接返回元素然后放入外部的列表中。但其实很多标答都和我的模板一样，只是了简化语句，大多是简化递推那部分，比如下例简短而有代表性：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> n != <span class="number">1</span>:</span><br><span class="line">	a = age(n-<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> a + <span class="number">2</span>                    <span class="comment">#这两句可简化为一句：return age = (n-1)+2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h3><p><em>list.insert()方法的返回值为空类型！</em></p>
<hr>
<hr>
<p>2018-1-7 17：49</p>
<p>最近做的文件处理题目，用到递归且比较独特，于是前来补充：</p>
<p>独特之处在于这种递归<strong>没有返回值</strong>，</p>
<p>如下是搜索返回文件的程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">found</span>(<span class="params">file, folder</span>):</span></span><br><span class="line">	os.chdir(folder)</span><br><span class="line">	l1 = os.listdir(os.getcwd())</span><br><span class="line">	<span class="keyword">for</span> each <span class="keyword">in</span> l1:</span><br><span class="line">		<span class="keyword">if</span> os.path.isdir(each):</span><br><span class="line">			found(file, each)      <span class="comment">#继续执行函数但注意细节，如这里当前文件目录已经在递归过程中改变，需回位！！</span></span><br><span class="line">			os.chdir(<span class="string">&#x27;..&#x27;</span>)            </span><br><span class="line">		<span class="keyword">elif</span> each == file:</span><br><span class="line">			print(os.getcwd() + os.sep + file)     <span class="comment">#到递归底层打印结果，无返回值，直接开始回推</span></span><br><span class="line">folder = <span class="built_in">input</span>(<span class="string">&#x27;请输入待查找的初始目录：&#x27;</span>)</span><br><span class="line">file = <span class="built_in">input</span>(<span class="string">&#x27;请输入目标文件：&#x27;</span>)</span><br><span class="line">found(file, folder)</span><br></pre></td></tr></table></figure>
<hr>
<p>2018-04-28<br>多年以后的现在，跟杜市容了解了一下一些算法的东西    </p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>秘籍帖</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表入门</title>
    <url>/2018/01/24/%E9%93%BE%E8%A1%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="静态列表与动态列表"><a href="#静态列表与动态列表" class="headerlink" title="静态列表与动态列表"></a>静态列表与动态列表</h3><ol>
<li>静态列表：所有结点都是在程序中定义。</li>
<li>动态列表：所有结点临时开辟，用完释放，即一个个开辟结点并输入节点的值，建立前后连接关系。 <h3 id="gt-指向运算符"><a href="#gt-指向运算符" class="headerlink" title="-&gt; : 指向运算符"></a>-&gt; : 指向运算符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p -&gt; next        &lt;&#x3D;&gt;        (*p)next </span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>指向结构体的指针不指向结构体成员，因为类型不同 </li>
<li>定义动态链表，需要约定好链表结束的条件。</li>
</ul>
<ul>
<li>动态链表： 让p1指向新开辟的结点，p2指向链表最后一个结点，把p1所指的结点连接在p2所指的结点后面。</li>
</ul>
<ol>
<li>用malloc开辟结点1（n=1），使p1指向它。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p1 = (struct Name *) <span class="built_in">malloc</span> (Name长度)； </span><br></pre></td></tr></table></figure></li>
<li>输入节点数据； </li>
<li>链入结点2（n=2），p1的值赋给p2 -&gt; next，此时p2指向第一个节点，故 <strong>p2 -&gt; next = p1</strong> 将结点2的地址赋给结点1的 next； </li>
<li>使 p2 = p1，即使p2指向新结点。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct Student* <span class="title">creat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p1</span>, *<span class="title">p2</span>, *<span class="title">head</span>;</span></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    p1 = p2 = (struct Student *)<span class="built_in">malloc</span>(Len);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;(*p1).num, &amp;(*p1).age);</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>((*p1).num != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            head = p1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            (*p2).next = p1;      <span class="comment">//这里跟我的顺序不太一样，可以思考一下</span></span><br><span class="line">        p2 = p1;</span><br><span class="line">        p1 = (struct Student *)<span class="built_in">malloc</span>(Len);</span><br><span class="line"><span class="comment">// p2 = p1;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;(*p1).num, &amp;(*p1).age);</span><br><span class="line">    &#125;</span><br><span class="line">    (*p2).next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在建立链表的循环中，例1是</li>
</ol>
<ul>
<li>连接</li>
<li>创建</li>
<li>赋值（<strong>此时p2在旧结点p1在新结点</strong>）</li>
</ul>
<p><img src="/2018/01/24/%E9%93%BE%E8%A1%A8%E5%85%A5%E9%97%A8/链表示例1.png" alt="例1"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct Student* <span class="title">creat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p1</span>, *<span class="title">p2</span>, *<span class="title">head</span>;</span></span><br><span class="line">    head = (struct Student *)<span class="built_in">malloc</span>(Len);</span><br><span class="line">    p1 = p2 = head;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;(*p1).id, &amp;(*p1).age);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      p1 = (struct Student *)<span class="built_in">malloc</span>(Len);</span><br><span class="line">      (*p2).next = p1;</span><br><span class="line">      p2 = p1;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;(*p1).id, &amp;(*p1).age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((*p2).id != <span class="number">0</span>);</span><br><span class="line">    (*p1).next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在建立链表的循环中，例2是</p>
<ul>
<li>创建</li>
<li>链接</li>
<li>赋值（<strong>此时p2与p1都在新结点</strong>）</li>
</ul>
<p><img src="/2018/01/24/%E9%93%BE%E8%A1%A8%E5%85%A5%E9%97%A8/链表示例2.png" alt="例2"></p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>秘籍帖</tag>
        <tag>数据结构与算法</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Arduino+Esp8266实现远程的模块控制</title>
    <url>/2021/02/14/Arduino/</url>
    <content><![CDATA[<blockquote>
<p>最近尝试使用Arduino配合esp8266实现远程控制Arduino上外接的某些模块，于是开始一边摸索一遍折腾开始了一周的尝试，期间得到很一些对自己很有用的经验，遂记录。<br>本次使用的策略是Arduino通过串口与esp8266通信，esp8266通过wifi连接到网络，然后通过mqtt协议订阅模块的操作信息，客户端就可以通过远程向mqtt发送相关主题的操作信息从而控制Arduino做出相应的约定动作。</p>
</blockquote>
<a id="more"></a>
<h1 id="使用硬件信息"><a href="#使用硬件信息" class="headerlink" title="使用硬件信息"></a>使用硬件信息</h1><ul>
<li>国版Ardunio Uno Rev3【<a href="https://www.arduino.cc/en/guide/MacOSX?setlang=cn">MacOS搭建ardunio环境</a>】</li>
<li>Esp8266-01s</li>
<li>动作模块使用舵机（或者灯泡等）</li>
</ul>
<h2 id="关于ESP8266"><a href="#关于ESP8266" class="headerlink" title="关于ESP8266"></a>关于ESP8266</h2><p>ESP8266存在3种工作模式：STA，AP，STA+AP<br>Sta模式: Station，类似于无线终端，本身不接受无线接入，可连接到AP，也就是可以连接wifi。一般无线网卡即工作在该模式<br>AP模式：相当于路由器，自己发射WiFi，终端可以连接上它，但是无法像sta模式那样连接其他WiFi。<br>STA+AP模式：既可以自己发射WiFi供其他终端连接，又可以做终端连接其他WiFi。这也是默认的出厂模式。 </p>
<p>ESP8266默认携带AT固件，支持AT指令，通过AT指令可以实现模式切换，修改波特率，Wifi连接，TCP连接等功能。<br>当然，使用不同的固件实现的功能也将不同。例如这里的<a href="http://www.piaoyi.org/iot/ESP8266-MQTT-AT-lewei50.html">支持mqtt的AT固件</a></p>
<h1 id="Arduino与8266的串口通信"><a href="#Arduino与8266的串口通信" class="headerlink" title="Arduino与8266的串口通信"></a>Arduino与8266的串口通信</h1><p>ESP8266与Arduino的接线，软硬串口的通信可以参见<a href="https://www.jianshu.com/p/cde9f7072eab">这篇文章</a>。</p>
<h2 id="ESP8266AT指令不可用"><a href="#ESP8266AT指令不可用" class="headerlink" title="ESP8266AT指令不可用"></a>ESP8266AT指令不可用</h2><p>Arduino接上8266之后，通过串口发送AT指令没有响应。于是尝试重刷esp8266的支持AT指令固件</p>
<div class="note info">
            <p><strong>ESP8266重刷固件</strong></p><ul><li>在乐鑫官网获取<a href="https://www.espressif.com/zh-hans/support/download/other-tools?keys=flash+&amp;field_type_tid%5B%5D=14">下载工具</a>【需要在windows下使用】</li><li>同样在乐鑫官网获取所需的<a href="https://www.espressif.com/zh-hans/support/download/at">AT固件</a></li><li>下载工具和固件使用方式可以参考<a href="http://www.piaoyi.org/iot/espressif-ESP8266-MQTT-AT.html">这篇文章</a>。烧录使用的连接模块，我使用的是学弟借的ESP专用的U转串模块，插上即用（下图）。也有人使用pl2303。<br><img src="/2021/02/14/Arduino/IOT MCU.png" alt="IOTMCU CH340C ESP8266 ESP-01 Prog WIFI下载器"></li></ul>
          </div>
<div class="note warning">
            <p>重刷了固件之后AT指令还是没有生效。排除了接线问题，看到<a href="https://blog.csdn.net/Sandman06/article/details/112132550">这篇文章</a>提示，有可能是<strong>供电不足的原因</strong>。<br>重新紧了一下线，重插电源线（3.3V），8266的蓝灯一闪，然后微弱发光，这时候AT指令就生效了。（我使用的是MBP笔记本雷电口+usb转接器）<br><a href="https://www.bilibili.com/video/av50778938/">b站有个大佬</a>提供了一个使用外部电源输入的实现方式。<br><strong>所以AT指令不生效的情况，可以考虑一下供电的问题</strong></p>
          </div>
<h1 id="ESP8266连接wifi与MQTT服务器"><a href="#ESP8266连接wifi与MQTT服务器" class="headerlink" title="ESP8266连接wifi与MQTT服务器"></a>ESP8266连接wifi与MQTT服务器</h1><p>紧接着是8266上的代码编写，需要实现</p>
<ul>
<li>Wifi连接</li>
<li>MQTT服务通信</li>
<li>通过串口发送消息到Arduino</li>
</ul>
<h2 id="ESP8266代码烧录"><a href="#ESP8266代码烧录" class="headerlink" title="ESP8266代码烧录"></a>ESP8266代码烧录</h2><h3 id="ESP8266代码编写"><a href="#ESP8266代码编写" class="headerlink" title="ESP8266代码编写"></a>ESP8266代码编写</h3><p>ESP8266的代码可以使用ArduinoIDE编写，同时支持8266板的库函数管理相关。也可以使用VSCode安装PlatformIO扩展，然后在PlatformIO里安装相关应用库。<br>使用ArduinoIDE，需要先安装esp8266的开发板支持。否则使用如<code>ESP8266WiFi.h</code>这样的库函数会报错<code>sketch_apr17a:15:10: error: ESP8266WiFi.h: No such file or directory</code></p>
<ul>
<li>打开Arduino的设置页，在<code>附加开发版管理网址</code>中填入<code>http://arduino.esp8266.com/stable/package_esp8266com_index.json</code></li>
<li>打开<code>工具&gt;开发板&gt;开发板管理器</code>搜索esp8266，点击安装</li>
<li>安装成功以后即可在开发板选项中看到<code>ESP8266 Board</code>，选择<code>ESP8266 Module</code>，就可以使用8266的库函数进行开发。注意esp8266代码编译和上传（烧录）时，需要确认开发板和端口的选择，否则可能会失败</li>
</ul>
<div class="note warning">
            <p><strong>8266开发板支持包下载失败</strong><br>曾经在学校安装支持包速度蹭蹭，在家却是龟速+反复失败。于是想到了<a href="http://www.gaohaiyan.com/2573.html">手动下载安装</a>：</p><ul><li>浏览器打开<code>http://arduino.esp8266.com/stable/package_esp8266com_index.json</code>，可以看到其实是一大段记录支持包所需要的依赖包的地址（有点类似npm的package.json）</li><li>最主要的<code>esp8266-2.7.4.zip</code>，通过github下载其实速度还是感人。后来使用迅雷，10秒结束战斗！！真是个防止浪费生命的神器。</li><li>需要放到<code>/Library/Arduino15/staging/packages</code>目录下，再点击安装，就会跳过这个包了</li><li>还有一些零碎的依赖，看起来主要是根据不同的编译环境的一些不同包，上边的博客中提到可以把所有带osx，apple的都下下来。经过实际测试，应该不需要，主要是以下几个包。（测试使用笨方法，即点击安装，下载过程会在上述文件中生成文件，然后经过文件名到上边依赖包目录找到对应文件及地址进行下载，所以可能有一些比较小下载极快的这里就不列出来）<ul><li>x86_64-apple-darwin14.xtensa-lx106-elf-b40a506.1563313032.tar.gz</li><li>x86_64-apple-darwin14.mkspiffs-7fefeac.1563313032.tar.gz</li><li>x86_64-apple-darwin14.mklittlefs-fe5bb56.1578453304.tar.gz</li><li>python3-macosx-portable.tar.gz</li></ul></li></ul>
          </div>
<div class="note warning">
            <p><strong>pyserial or esptool directories not found next to this upload.py tool</strong><br>编译代码时出现以上报错。翻阅一堆博客论坛，找到了解决方法，并且有可能是MacOSBigSur的问题。</p><ol><li>下载 <a href="https://github.com/espressif/esptool/archive/v3.0.zip">https://github.com/espressif/esptool/archive/v3.0.zip</a></li><li>下载 <a href="https://github.com/pyserial/pyserial/archive/v3.4.zip">https://github.com/pyserial/pyserial/archive/v3.4.zip</a></li><li>下载解压出文件夹<code>esptool/</code>和<code>pyserial/</code>放到<code>~/Library/Arduino15/packages/esp8266/hardware/esp8266/2.7.4/tools/</code>文件夹下，替换原有的文件，具体点进目录中，根据文件名应该就明白了<br><strong><a href="https://www.esp8266.com/viewtopic.php?p=89446">参考链接</a></strong></li></ol>
          </div>
<h3 id="Esp8266代码烧录"><a href="#Esp8266代码烧录" class="headerlink" title="Esp8266代码烧录"></a>Esp8266代码烧录</h3><p>esp8266通过Arduino板子连接PC进行代码烧录，始终出现问题。说始终是因为前几个月就因为这个问题导致有个小项目搁置，所以出现这个问题也算是意料之中吧。<br>主要现象是代码编译通过以后点击上传，始终出现<code>Connecting...</code>打点，过会就出现<strong><code>Failed to connect to ESP32: Timed out waiting for packet header</code></strong>的报错，上传失败。使用的接线是</p>
<blockquote>
<p>将UTXD接到串口模块的TX上，CH_PD和VCC接3.3V，GND和GPIO0接GND<br>这是烧录模式，如果要工作的话请将GPIO0脚悬空，即断开，否则设备不会正常工作！</p>
</blockquote>
<p>找到<a href="https://randomnerdtutorials.com/solved-failed-to-connect-to-esp32-timed-out-waiting-for-packet-header/">一篇帖子</a>，其中说解决方式是在8266<code>EN</code>和<code>GND</code>之间外接一个10uF的电容。感觉…不太实际，没有尝试。</p>
<p>后来看<a href="http://www.gaohaiyan.com/2573.html">这篇博客</a>时，发现它实际上也有说到这个问题。提到需要先断开8266的<code>EN</code>和<code>IO0</code>，然后在<code>Connecting..</code>打点时，<code>IO0</code>接地，<code>EN</code>接3.3V，程序可以继续烧录，否则会出现以上报错。帖子中提到该方式的成功率不高，确实我一直没有成功，它说还是使用U转串（下载器）进行烧录比较好。（我…怎么没有想到）</p>
<p>帖子中提到的，需要安装驱动，但是我没有，直接插上，点击上传就烧录了==，很成功，就像重刷固件一样，connecting之后log会显示烧写的地址位。同样，需要注意切换端口。</p>
<p><strong>实际上我看了<a href="https://blog.csdn.net/weixin_39098367/article/details/87521226">这篇博客</a>才意识到了（是的 才），实际上烧录程序和输入固件是一样的，固件实际上也是包装好的程序，比如AT固件实际上只是就只通过接受串口的固定格式的数据（AT指令），然后操作并返回结果信息的程序罢了，而所谓的需要注意默认的波特率，是因为程序中<code>Serial.begin</code>同样的使用了该波特率罢了。</strong></p>
<p>走通了代码的编写和烧录流程，接下来终于可以愉快的写代码了。</p>
<h2 id="ESP8266代码编写-1"><a href="#ESP8266代码编写-1" class="headerlink" title="ESP8266代码编写"></a>ESP8266代码编写</h2><h3 id="ESP8266串口通信"><a href="#ESP8266串口通信" class="headerlink" title="ESP8266串口通信"></a>ESP8266串口通信</h3><p>在8266上发送串口数据和Arduino其实一样<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Serial.begin();		<span class="comment">// 指定串口波特率，注意通信的另一端（Arduino）需要统一波特率</span></span><br><span class="line">Serial.println();	<span class="comment">// 输出数据。此外8266上的Serial对象还支持printf格式化输出方式</span></span><br></pre></td></tr></table></figure></p>
<h3 id="ESP8266连接Wifi"><a href="#ESP8266连接Wifi" class="headerlink" title="ESP8266连接Wifi"></a>ESP8266连接Wifi</h3><p>使用8266开发板自带库函数头文件<code>ESP8266Wifi.h</code>，很方便实现Wifi连接。基本代码如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WiFi.begin(<span class="keyword">char</span>* ssid, <span class="keyword">char</span>* password);		<span class="comment">// 传入Wifi名和密码，开始连接</span></span><br><span class="line"><span class="keyword">if</span> (Wifi.status() != WL_CONNECTED)		<span class="comment">// 确认连接状态</span></span><br></pre></td></tr></table></figure><br>具体代码示例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ssid     = <span class="string">&quot;ESP8266 需要连接的WIFI的SSID&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* password = <span class="string">&quot;Wifi密码&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  delay(<span class="number">10</span>);</span><br><span class="line">  Serial.print(<span class="string">&quot;Connecting to &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 明确将ESP8266设置为WiFi客户端，否则默认情况下，它将尝试同时充当客户端和接入点，并可能导致WiFi网络上的其他WiFi设备出现网络问题 */</span></span><br><span class="line">  WiFi.mode(WIFI_STA);</span><br><span class="line">  <span class="comment">// 开始连接</span></span><br><span class="line">  WiFi.begin(ssid, password);</span><br><span class="line">  <span class="comment">// 状态确认</span></span><br><span class="line">  <span class="keyword">while</span> (WiFi.status() != WL_CONNECTED) &#123;</span><br><span class="line">    delay(<span class="number">500</span>);</span><br><span class="line">    Serial.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 连接成功</span></span><br><span class="line">  Serial.println(<span class="string">&quot;WiFi connected&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;IP address: &quot;</span>);</span><br><span class="line">  Serial.println(WiFi.localIP());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> whetherConnect = <span class="number">0</span>;</span><br><span class="line">WiFiClient client;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint16_t</span> port = <span class="number">8082</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * host = <span class="string">&quot;你的IP&quot;</span>; <span class="comment">// ip or dns</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 确认socket连接状态</span></span><br><span class="line">  <span class="keyword">if</span> (client.connected() == <span class="literal">true</span>)</span><br><span class="line">    whetherConnect = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    whetherConnect = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (whetherConnect == <span class="number">0</span>) &#123;</span><br><span class="line">    Serial.print(<span class="string">&quot;connecting to &quot;</span> + host);</span><br><span class="line">    <span class="keyword">if</span> (!client.connect(host, port)) &#123;</span><br><span class="line">      Serial.println(<span class="string">&quot;connection failed \n wait 5 sec...&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      whetherConnect = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Serial.available()) &#123;</span><br><span class="line">    <span class="comment">// 读取硬串口</span></span><br><span class="line">    <span class="keyword">if</span> (Serial.read() == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取ssid列表</span></span><br><span class="line">      <span class="keyword">int</span> n = WiFi.scanNetworks();</span><br><span class="line">      Serial.println(<span class="string">&quot;scan done&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        client.println(<span class="string">&quot;no networks found&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        client.println(n + <span class="string">&quot; networks found&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">          <span class="comment">// Print SSID and RSSI for each network found</span></span><br><span class="line">          client.print(WiFi.SSID(i));</span><br><span class="line">          client.println(WiFi.RSSI(i));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// This will send the request to the server</span></span><br><span class="line">      client.println(<span class="string">&quot;------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//read back one line from server</span></span><br><span class="line">      Serial.println(client.readStringUntil(<span class="string">&#x27;\r&#x27;</span>));</span><br><span class="line">      Serial.println(<span class="string">&quot;closing connection&quot;</span>);</span><br><span class="line">      client.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ESP8266与MQTT协议"><a href="#ESP8266与MQTT协议" class="headerlink" title="ESP8266与MQTT协议"></a>ESP8266与MQTT协议</h3><p>库管理中导入<code>PubSubClient.h</code>头文件，实现MQTT服务端的连接以及消息的订阅和发布。代码也不复杂<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WiFiClient espClient;</span><br><span class="line"><span class="function">PubSubClient <span class="title">client</span><span class="params">(espClient)</span></span>;</span><br><span class="line"></span><br><span class="line">client.setServer(<span class="keyword">char</span>* server_ip, <span class="keyword">int</span> port);	<span class="comment">// 设置服务器IP和端口（思考，如果IP下还带有子目录该如何实现？）</span></span><br><span class="line">client.setCallback(callback);			<span class="comment">// 设置回调，当有消息传入时会执行该回调</span></span><br><span class="line">client.connected();				<span class="comment">// 判断连接状态</span></span><br><span class="line">client.connect(String clientId);		<span class="comment">// 开始连接，传入客户端ID</span></span><br><span class="line">client.publish(<span class="keyword">char</span>* topic, <span class="keyword">char</span>* msg);		<span class="comment">// 消息发布</span></span><br><span class="line">client.subscribe(<span class="keyword">char</span>* topic);			<span class="comment">// 消息订阅</span></span><br><span class="line">client.loop();					<span class="comment">// 处理保持活动信号，以及处理传入消息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">char</span> *topic, byte * payload, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span> </span>&#123;	&#125;	<span class="comment">// 主题，消息，消息长度</span></span><br></pre></td></tr></table></figure><br>具体代码示例：<a href="https://www.emqx.cn/blog/esp8266-connects-to-the-public-mqtt-broker">参考</a><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;PubSubClient.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ssid     = <span class="string">&quot;ESP8266 需要连接的WIFI的SSID&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* password = <span class="string">&quot;Wifi密码&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* mqtt_server = <span class="string">&quot;MQTT服务器IP&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mqtt_port     = MQTT服务端口;</span><br><span class="line"></span><br><span class="line">WiFiClient espClient;</span><br><span class="line"><span class="function">PubSubClient <span class="title">client</span><span class="params">(espClient)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting to &quot;</span>);</span><br><span class="line">  </span><br><span class="line">  connectWiFi();	<span class="comment">// wifi连接如上文</span></span><br><span class="line"></span><br><span class="line">  client.setServer(mqtt_server, mqtt_port);</span><br><span class="line">  client.setCallback(callback);</span><br><span class="line">  <span class="keyword">while</span> (!client.connected()) &#123;</span><br><span class="line">    String client_id = String(WiFi.macAddress());</span><br><span class="line">    Serial.println(<span class="string">&quot;Connecting to public emqx mqtt broker.....&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (client.connect(client_id.c_str())) &#123;</span><br><span class="line">      Serial.println(<span class="string">&quot;Public emqx mqtt broker connected&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.print(<span class="string">&quot;failed with state &quot;</span>);</span><br><span class="line">      Serial.print(client.state());</span><br><span class="line">      delay(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;start to subsc&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span>* topic = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  client.publish(topic, <span class="string">&quot;hello emqx&quot;</span>);</span><br><span class="line">  client.subscribe(topic);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">char</span> *topic, byte * payload, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  Serial.print(<span class="string">&quot;Message arrived in topic: &quot;</span>);</span><br><span class="line">  Serial.println(topic);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;Message:(%d)  &quot;</span>, length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    Serial.print((<span class="keyword">char</span>) payload[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println();</span><br><span class="line">  Serial.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  client.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>还有大佬对PubSubClient库进行进一步封装实现了一个库。<a href="https://www.arduino.cn/thread-85101-1-2.html">可以看看这个</a><br>以及大佬编写的，关于客户端状态返回码的注释。如果连接MQTT服务器失败返回了状态码可以参考一下</p>
<blockquote>
<p>int - 客户端状态，可以采用以下值 (常量定义在 PubSubClient.h):<br>-4 : MQTT_ CONNECTION_ TIMEOUT - 服务器在保持活动时间内没有响应。<br>-3 : MQTT_ CONNECTION_ LOST - 网络连接中断。<br>-2 : MQTT_ CONNECT_ FAILED - 网络连接失败。<br>-1 : MQTT_ DISCONNECTED - 客户端干净地断开连接。<br>0 : MQTT_ CONNECTED - 客户端已连接。<br>1 : MQTT_ CONNECT_ BAD_ PROTOCOL - 服务器不支持请求的MQTT版本。<br>2 : MQTT_ CONNECT_ BAD_ CLIENT_ ID - 服务器拒绝了客户端标识符。<br>3 : MQTT_ CONNECT_ UNAVAILABLE - 服务器无法接受连接。<br>4 : MQTT_ CONNECT_ BAD_ CREDENTIALS - 用户名/密码被拒绝。<br>5 : MQTT_ CONNECT_ UNAUTHORIZED - 客户端无权连接。</p>
</blockquote>
<h2 id="关于MQTT"><a href="#关于MQTT" class="headerlink" title="关于MQTT"></a>关于MQTT</h2><p>对于MQTT，此前一直不了解，这几天查了些资料，根据自己的理解对MQTT进行了简单的介绍，大概是对TCP协议进一步封装的一个应用层协议，主要是消息订阅与发布广播的机制。可以看看<a href="../../../../2021/02/25/mqtt/">我对于MQTT的认识</a></p>
<p>查阅过程中，看到Arduino社区一位大佬写下的<a href="https://www.arduino.cn/thread-82851-1-1.html">科普贴</a>，觉得对理解MQTT还是很有帮助。<br>以及如果有node.js的环境，也可以使用node.js搭建MQTT服务器和客户端，实现消息的发送订阅。使用<code>mosca</code>库3 5行就可以实现。</p>
<h1 id="Arduino接收信息并输出"><a href="#Arduino接收信息并输出" class="headerlink" title="Arduino接收信息并输出"></a>Arduino接收信息并输出</h1><h2 id="Arduino接收串口信息"><a href="#Arduino接收串口信息" class="headerlink" title="Arduino接收串口信息"></a>Arduino接收串口信息</h2><p>实际上Arduino通过软串口连接8266的示例在<a href="#Arduino与8266的串口通信">上边</a>以及提供了，但我还是提供一下<a href="#代码示例">我的实现方式</a>。</p>
<h2 id="Arduino处理数据并控制动作模块"><a href="#Arduino处理数据并控制动作模块" class="headerlink" title="Arduino处理数据并控制动作模块"></a>Arduino处理数据并控制动作模块</h2><h4 id="Arduino-舵机"><a href="#Arduino-舵机" class="headerlink" title="Arduino+舵机"></a>Arduino+舵机</h4><p>舵机图如下，能通过pin口接收一个角度值然后将旋桨旋转到该角度。<a href="https://arduino.nxez.com/2016/12/20/use-arduino-to-control-the-steering-gear.html">舵机细节讲解</a></p>
<p>接线方式<a href="https://steemit.com/utopian-io/@cha0s0000/arduino-sg90">参考</a></p>
<p><img src="/2021/02/14/Arduino/Servo.png" alt="舵机"><br>控制代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Servo.h&gt;		// 头文件</span></span></span><br><span class="line">Servo myServo;</span><br><span class="line">pinMode(<span class="keyword">int</span> pin, myServo);	<span class="comment">// 和控制led灯类似，需传入对应的pin口号</span></span><br><span class="line">myServo.write(<span class="keyword">int</span> angle);		<span class="comment">// 写入角度值，进行旋转</span></span><br></pre></td></tr></table></figure>
<h4 id="Arduino处理串口数据"><a href="#Arduino处理串口数据" class="headerlink" title="Arduino处理串口数据"></a>Arduino处理串口数据</h4><p>说实话通过串口接受的数据处理也是废了不少脑筋。<br>经过测试，通过SoftwareSerial.read()读取的数据实际上是byte的字节流，需要强转为char类型，组装为原文字符串；而Serial.print()方法打印的数据，稍有不慎会出现乱序和重复的问题。然而这些问题都还没有结论，我也暂时没有深究。</p>
<p>由于在8266中输出的字符串文本接受时都是零散的字符，因此我输出文本时，将每一段文本都加上<code>#</code>开头，在Arduino接收时以一个<code>#</code>以及一个结尾的<code>\n</code>作为一句文本的标志，以此获得完整的字符串。<br>然而如果是要接受一段mqtt协议相关的消息，那么一段消息我需要得到的最主要信息就是<code>topic</code>和<code>message</code>至少两个部分。因此我决定让8266输出的信息拼装为一个json串，然后Arduino上以json的方式取用数据。</p>
<p><a href="#舵机">最后实现代码</a></p>
<div class="note primary">
            <p>实际上这个地方大可不必如此麻烦，直接让8266发送角度值，Arduino接受后送给舵机发动就好了，没必要整花里胡哨的。但我是考虑了如果Arduino上如果连接了多个外设，那就需要区分topic和消息内容了，索性折腾了一下</p>
          </div>
<div class="note info">
            <p><strong>Arduino上的Json库：ArduinoJson</strong><br>同样的库管理中下载该库。由于网上大部分都是v5版本，为此还在其官网徜徉了一番，找到<a href="https://arduinojson.org/v6/doc/upgrade/">版本变更点</a>，以及<a href="https://arduinojson.org/v6/example/parser/">v6正确打开方式</a>。<br>十分详尽，此处不过多介绍使用了</p>
          </div>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><h2 id="实现esp8266wifi连接且通过软串口输出到ardunio"><a href="#实现esp8266wifi连接且通过软串口输出到ardunio" class="headerlink" title="实现esp8266wifi连接且通过软串口输出到ardunio"></a>实现esp8266wifi连接且通过软串口输出到ardunio</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ESP8266代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ssid = <span class="string">&quot;ssid&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pwd = <span class="string">&quot;password&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line"></span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting to &quot;</span>);</span><br><span class="line">  WiFi.begin(ssid, pwd);</span><br><span class="line">  <span class="keyword">while</span>(WiFi.status() != WL_CONNECTED) &#123;</span><br><span class="line">    delay(<span class="number">500</span>);</span><br><span class="line">    Serial.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;Wifi connected&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;IP address: &quot;</span>);</span><br><span class="line">  Serial.println(WiFi.localIP());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ardunio代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SoftwareSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">SoftwareSerial <span class="title">mySerial</span><span class="params">(<span class="number">10</span>, <span class="number">11</span>)</span></span>; <span class="comment">// TX,RX</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  <span class="keyword">while</span> (!Serial) &#123;&#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;Goodnight moon!&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  delay(<span class="number">300</span>);</span><br><span class="line">  mySerial.begin(<span class="number">9600</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mySerial.available()) &#123;</span><br><span class="line">    Serial.write(mySerial.read());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Serial.available()) &#123;</span><br><span class="line">    mySerial.write(Serial.read());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/14/Arduino/first.png" alt="首次成功"></p>
<p><strong>值得注意的是，一直以来很多论坛说的Ardunio和ESP8266的RX和TX需要反着接，但是尝试之后好像不是这样的。并且成功的最后一步操作是，把两条反接的线再反过来一次，即TX对TX，RX对RX。这里不是很明白，望交流告知</strong>。因此如果没有反应，可以尝试把RX和TX反过来试试。</p>
<h2 id="舵机"><a href="#舵机" class="headerlink" title="舵机"></a>舵机</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ESP8266端代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;PubSubClient.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ssid = <span class="string">&quot;ssid&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pwd = <span class="string">&quot;pwd&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* mqtt_server = <span class="string">&quot;192.168.1.103&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mqtt_port = <span class="number">1883</span>;</span><br><span class="line"></span><br><span class="line">WiFiClient espClient;</span><br><span class="line"><span class="function">PubSubClient <span class="title">client</span><span class="params">(espClient)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectWifi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  WiFi.begin(ssid, pwd);</span><br><span class="line">  <span class="keyword">while</span> (WiFi.status() != WL_CONNECTED) &#123;</span><br><span class="line">    delay(<span class="number">500</span>);</span><br><span class="line">    Serial.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;Wifi connected&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Serial.println(<span class="string">&quot;IP address: &quot;</span>);</span><br><span class="line">  Serial.println(WiFi.localIP());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reConnectMqtt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!client.connected()) &#123;</span><br><span class="line">    String client_id = <span class="string">&quot;esp8266-client-&quot;</span>;</span><br><span class="line">    client_id += String(WiFi.macAddress());</span><br><span class="line">    Serial.println(<span class="string">&quot;Connecting to public emqx mqtt broker.....&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (client.connect(client_id.c_str())) &#123;</span><br><span class="line">      Serial.println(<span class="string">&quot;Public emqx mqtt broker connected&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.print(<span class="string">&quot;failed with state &quot;</span>);</span><br><span class="line">      Serial.print(client.state());</span><br><span class="line">      delay(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;start to subsc&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span>* topic = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  client.publish(topic, <span class="string">&quot;hello emqx&quot;</span>);</span><br><span class="line">  client.subscribe(topic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting to &quot;</span>);</span><br><span class="line"></span><br><span class="line">  connectWifi();</span><br><span class="line"></span><br><span class="line">  client.setServer(mqtt_server, mqtt_port);</span><br><span class="line">  client.setCallback(callback);</span><br><span class="line">  reConnectMqtt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">char</span> *topic, byte * payload, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  String content = <span class="string">&quot;#&#123;\&quot;topic\&quot;:\&quot;&quot;</span> + String(topic) + <span class="string">&quot;\&quot;, \&quot;msg\&quot;:\&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    content += (<span class="keyword">char</span>) payload[i];</span><br><span class="line">  &#125;</span><br><span class="line">  content += <span class="string">&quot;\&quot;, \&quot;other\&quot;:213&#125;&quot;</span>;</span><br><span class="line">  Serial.println(content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!client.connected()) &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;Reconnenct&quot;</span>);</span><br><span class="line">		reConnectMqtt();</span><br><span class="line">  &#125;</span><br><span class="line">  client.loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================</span></span><br><span class="line"><span class="comment">// Arduino端代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SoftwareSerial.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ArduinoJson.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Servo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Servo myServo;</span><br><span class="line"><span class="keyword">int</span> ServoPin = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SoftwareSerial <span class="title">mySerial</span><span class="params">(<span class="number">10</span>, <span class="number">11</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  pinMode(ServoPin, OUTPUT);</span><br><span class="line">  myServo.attach(ServoPin);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!Serial) &#123;&#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;Goodnight moon!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  delay(<span class="number">300</span>);</span><br><span class="line">  mySerial.begin(<span class="number">9600</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String con = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 0：未记录</span></span><br><span class="line"><span class="comment"> * 1：记录日志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> note = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(String)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mySerial.available()) &#123;</span><br><span class="line">    <span class="keyword">char</span> a = mySerial.read();</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;\n&#x27;</span> &amp;&amp; note == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 记录中且读到/n：关闭记录且输出，并清空缓存；</span></span><br><span class="line">      note = <span class="number">0</span>;</span><br><span class="line">      handler(con);</span><br><span class="line">      con = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">&#x27;#&#x27;</span> &amp;&amp; note == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 记录中又读到一个#：输出当前，清空缓存</span></span><br><span class="line">      handler(con);</span><br><span class="line">      con = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">      note = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (note == <span class="number">1</span>) &#123;</span><br><span class="line">      con += a;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StaticJsonDocument&lt;<span class="number">200</span>&gt; doc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* con = str.c_str();</span><br><span class="line">  <span class="keyword">auto</span> error = deserializeJson(doc, con);</span><br><span class="line">  Serial.println(str);</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;parseJson Fail&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* topic = doc[<span class="string">&quot;topic&quot;</span>];</span><br><span class="line">  <span class="keyword">char</span>* msg = doc[<span class="string">&quot;msg&quot;</span>];</span><br><span class="line">  <span class="keyword">int</span> other = doc[<span class="string">&quot;other&quot;</span>];</span><br><span class="line">  Serial.println(<span class="string">&quot;**&quot;</span> + String(topic) + <span class="string">&quot;**&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;**&quot;</span> + String(msg) + <span class="string">&quot;**&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;**&quot;</span> + String(other) + <span class="string">&quot;**&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (String(topic) == <span class="string">&quot;hello&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> te = atoi(msg);</span><br><span class="line">    <span class="comment">// Serial.println(&quot;Servo Angle &quot; + te);		// 若是打开这句输出，串口输出就会乱掉，不解</span></span><br><span class="line">    myServo.write(te);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/14/Arduino/end.png" alt="实物图"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次折腾了快一周，算是很有收获，搞清楚了之前一直云里雾里的8266编程和他的AT指令以及串口通信的使用。</p>
<p><strong>ESP8266和Arduino就像是两个的单片机，如果需要做AT指令不好完成的操作，当然需要另外编写代码烧录到8266中。而如果只是连接Wifi还是可以通过AT指令完成的，甚至进行MQTT通信，也可以使用对应的AT固件完成。</strong></p>
<p>实际上在各种查阅时候，确实看到某大佬自己编写的支持8266进行mqtt通信的指令固件，参见<a href="http://wenzheng.club/2019/02/14/index/">他的站点</a>。对于这种大佬也是只有崇拜啦</p>
<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><h2 id="2021-05-08-舵机抖动"><a href="#2021-05-08-舵机抖动" class="headerlink" title="2021-05-08    舵机抖动"></a>2021-05-08    舵机抖动</h2><p>使用<code>Servo.h</code>库操作舵机，出现问题：舵机在接到指令转动之前，会有极小角度的颤抖，然后再进行偏转；甚至在未接收到指令时，偶现出现自发的小幅转动。<br>经过一番查阅，发现这篇博客，解决了<a href="https://blog.csdn.net/acktomas/article/details/101771616">舵机抖动问题</a>。<br>由文章分析可知，官方提供的<code>Servo.h</code>代码中使用了定时器中断，由于串口通信也需要使用定时器，所以如果同时使用了Servo和串口通信功能，那么会出现舵机抖动的问题。<br>博主给出的解决方式，自己实现舵机的驱动程序，实际上也十分简单，也是往舵机的数字接口发送一定频率的高低电平实现，代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">servopulse</span><span class="params">(<span class="keyword">int</span> angle)</span><span class="comment">//定义一个脉冲函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//发送50个脉冲</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> pulsewidth = (angle * <span class="number">11</span>) + <span class="number">500</span>; <span class="comment">//将角度转化为500-2480的脉宽值</span></span><br><span class="line">    digitalWrite(servoPin, HIGH);   <span class="comment">//将舵机接口电平至高</span></span><br><span class="line">    delayMicroseconds(pulsewidth);  <span class="comment">//延时脉宽值的微秒数</span></span><br><span class="line">    digitalWrite(servoPin, LOW);    <span class="comment">//将舵机接口电平至低</span></span><br><span class="line">    delayMicroseconds(<span class="number">20000</span> - pulsewidth);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  delay(20);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>技能帖</tag>
        <tag>MQTT</tag>
        <tag>Arduino</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客本地迁移</title>
    <url>/2021/01/31/Hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<blockquote>
<p>背景：最近换了一台电脑，原来的主力机几近退役，故需要把工作台进行迁移。其中包括把Hexo的本地文件进行转移。经过查找总结，得出此文。</p>
</blockquote>
<h1 id="可能需保留的原文件"><a href="#可能需保留的原文件" class="headerlink" title="可能需保留的原文件"></a>可能需保留的原文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_config.yml	&#x2F;&#x2F; 保存对于hexo的一些个性化设置</span><br><span class="line">package.json	&#x2F;&#x2F; 记录hexo框架依赖的版本信息</span><br><span class="line">scaffolds&#x2F;	&#x2F;&#x2F; 自动生成post使使用的脚手架</span><br><span class="line">source&#x2F;		&#x2F;&#x2F; 文稿源文件</span><br><span class="line">themes&#x2F;		&#x2F;&#x2F; 使用的主题文件</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="npm安装hexo插件"><a href="#npm安装hexo插件" class="headerlink" title="npm安装hexo插件"></a>npm安装hexo插件</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure>
<p>该指令会通过package.json文件获取模块及版本信息，然后进行下载安装。可以使用npm update指令进行模块更新<br>如果没有package.json，也可以直接安装以下模块，可以保证hexo模块运行，但是一些其他的插件，需要自己重新安装<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-deployer-git --save</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-feed --save</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-sitemap --save</span></span><br></pre></td></tr></table></figure><br>通过npm安装模块之后，则会生成<strong>node_modules</strong>文件夹</p>
<h1 id="运行hexo"><a href="#运行hexo" class="headerlink" title="运行hexo"></a>运行hexo</h1><p>使用<strong>hexo g</strong>尝试生成部署文件（<strong>public文件夹</strong>）<br>使用<strong>hexo s</strong>在本地4000（可选择）端口运行服务<br>至此迁移工作完成～</p>
<h1 id="出现的一些问题"><a href="#出现的一些问题" class="headerlink" title="出现的一些问题"></a>出现的一些问题</h1><ol>
<li>swig插件问题<br>现象：generator过程中出现报错，且生成index.html文件不是正常的html标签<blockquote>
<p><code>&#123;% extends ‘_layout.swig’ %&#125; &#123;% import ‘_macro/post.swig‘ as post_template %&#125;</code></p>
</blockquote>
类似这样的信息<br>原因是hexo5以后删除了swig，需要自己手动安装<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-renderer-swig</span></span><br></pre></td></tr></table></figure></li>
<li><p>图片资源问题<br>关于博客中的插图，我之前的方案是放到theme/images/中，这样打包时候可以原封不动的打包到public/images中，然后我再引用。<br>如今发现一种正确的姿势，即在<code>_config.yml</code>中设置<strong>post_asset_folder</strong>为true，然后生成post（hexo new xx）时便会在source中同时生成一个同名文件夹，其中存放该文章的插图资源等，打包时将一同打包。最后在生成的public文件中，图片与文章的index文件是在同一级文件夹下的。<br>但是存在一个问题，图片的路径默认相对根目录是/year/month/day/title/image.jpg，而虽然在博客中直接通过图片名字引用<code>![xx](image.jpg)</code>是没有问题的，因为实际上就是在统一目录下。但是这样的写法，在其他页面如预览页时图片是无法加载的（因为用的不是图片同级的index.html，自然索引不到）。手动写上/year/month/day/title/image.jpg，又感觉怪怪的，因此有大佬为hexo框架提供了一个脚本模块<strong>hexo-asset-link</strong>，帮助我们实现了md文件转换为index.html时图片路径的填充完善。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-asset-link</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装hexo-asset-link模块之后，直接通过![xx](title/iamge.jpg)则可以加载图片</span></span><br></pre></td></tr></table></figure>
<p>看到很多帖子使用hexo-asset-image，但是这个插件填充的路径是基于<code>_config.yml</code>中的url项绝对路径访问，很多人都再去修改了其index.js文件代码，实现相对路径的访问，私以为有些画蛇添足。也有人直接将修改后的代码，封装为一个module，即是hexo-zngw-asset-image，因此这个插件跟hexo-asset-link一样也是直接可用的，只是实现方式不同而已。</p>
</li>
<li><p>关于hexo转义的小问题<br>现象：generator时候出现报错</p>
<blockquote>
<p>  err: Template render error: (unknown path)<br>  Error: template names must be a string: undefined<br>这时候可以通过<strong>hexo g –debug</strong>，看到更多的log信息。（有人说甚至可以显示具体行数）<br>可看到我这个问题是在渲染某篇文章出现的。经排查发现是使用了<code>&#123;[%]&#125;</code>这些符号导致转义出现问题。解决方式是使用<code></code>将文本块括起来，即可解决。</p>
</blockquote>
</li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上是本次迁移Hexo博客时候出现的一些问题与部分心得体会。加深了些对Hexo的理解。后续可以把这些原文件放到另一个仓库或另一个分支中，进行版本管理及备份，方便使用。</p>
<hr>
<h1 id="NexT主题配置"><a href="#NexT主题配置" class="headerlink" title="NexT主题配置"></a>NexT主题配置</h1><h2 id="通过css设置背景透明度等"><a href="#通过css设置背景透明度等" class="headerlink" title="通过css设置背景透明度等"></a>通过css设置背景透明度等</h2><p>首先在NexT的_config.yml中启用自定义style</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Define custom file paths.</span></span><br><span class="line"><span class="comment"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span></span><br><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
<p>其中显示的路径是相对根目录，即Hexo根目录的source文件夹下，新建_data文件夹（即跟<code>_post</code>文件夹放一块），其中新建styles.styl文件，写入以下代码，有一点点css基础的可以修改或者自己写（没有其实也可以）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 添加背景图片</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">      background: url(/images/wall.png);	// 背景图路径，相对NexT的source目录</span><br><span class="line">      <span class="selector-tag">background-size</span>: <span class="selector-tag">cover</span>;</span><br><span class="line">      <span class="selector-tag">background-repeat</span>: <span class="selector-tag">no-repeat</span>;</span><br><span class="line">      <span class="selector-tag">background-attachment</span>: <span class="selector-tag">fixed</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 博客内容透明化</span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//侧边框的透明度设置</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.85</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//菜单栏的透明度设置</span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.85</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//搜索框（<span class="selector-tag">local-search</span>）的透明度设置</span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.85</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>旧版本的NexT是在css/_custom/里做的修改，新版本已经取消了这个文件。具体方式请百度</li>
<li>Linux/Mac下可以用vim编辑，Windows可以用notepad（记事本）编辑</li>
</ol>
<h2 id="文末添加结束语"><a href="#文末添加结束语" class="headerlink" title="文末添加结束语"></a>文末添加结束语</h2><p>NexT同样为我们提供了自定义结束语样式的方式</p>
<ul>
<li><p>首先在theme/_config.yml的<code>custom_file_path</code>中取消<code>postBodyEnd</code>的注释，即启用该文件，然后在<code>_data</code>文件夹中创建该文件post-body-end.swig</p>
</li>
<li><p>我希望实现在文章配置中可以设定是否启用结束语。于是先自定义一个属性比如<code>end</code>，表示该文是否已经结束</p>
</li>
<li><p>在post-body-end.swig文件中通过判断该属性以决定是否显示自定义样式的结束语【索引属性方式会在<a href="#修改swig文件">这里</a>提到】。比如我是这么写的（html是东拼西凑乱写的，如果有更好的建议可以告诉我谢谢～）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;%- if post.end != false %&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot; width:100%; text-align:center; margin-left:15px; margin-right:15px;&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">&quot;width:30%;vertical-align:middle; display:inline-block;&quot;</span>/&gt;</span></span><br><span class="line">    	完结</span><br><span class="line">	    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-paw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">	    撒花 ฅ<span class="symbol">&amp;gt;</span>ω<span class="symbol">&amp;lt;</span>*ฅ</span><br><span class="line">		<span class="tag">&lt;<span class="name">hr</span> <span class="attr">style</span>=<span class="string">&quot;width:30%;vertical-align:middle; display:inline-block;&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<p>文章end属性不设置或设置true，则可以在文章底部看到效果如下：<img src="/2021/01/31/Hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E8%BF%81%E7%A7%BB/end.png" alt="end"></p>
</li>
</ul>
<h2 id="NexT配置文件"><a href="#NexT配置文件" class="headerlink" title="NexT配置文件"></a>NexT配置文件</h2><p>有点强迫症，稍微看了下NexT主题的_config.yml中的可配置项，稍作记录（基于v7.8.0）</p>
<p>【写完发现，已经有大佬对所有配置项进行解释，虽然版本可能没这么新，写的很详细，感谢<a href="https://blog.csdn.net/weixin_42119041/article/details/104101566">这篇文章</a>】</p>
<ul>
<li>前边minify等项配置运行时文件操作，如生出hexo generation生成的文件，缓存清理等</li>
<li>favicon标签：设置一些网站图标</li>
<li>footer：网站底部的这一部分。<br>  <img src="/2021/01/31/Hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E8%BF%81%E7%A7%BB/footer.png" alt="footer"><ul>
<li>since：设置起始时间</li>
<li>icon：指🧡图标，可修改图标，颜色，以及动画开关（跳动）</li>
<li>copyright：版权信息，默认使用hexo中配置的author</li>
<li>power：是否显示x x强力驱动信息</li>
<li>beian：显示备案信息</li>
</ul>
</li>
<li>scheme：配置主题，内置一共四款主题</li>
<li>darkmode：惊喜发现，居然内置了黑夜主题，并有一键开关</li>
<li>menu：配置菜单栏的单项，“||”之前代表跳转路径，“||”之后代表所使用的图标</li>
<li>sidebar：配置边栏的样式，宽度等</li>
<li>social：配置社交平台显示及地址</li>
<li>links_setting：关于友链设置。下边的links可添加友链。<ul>
<li>layout：多个友链的布局。块状或内联。可理解为垂直或水平</li>
</ul>
</li>
<li>toc：设置文章页边栏目录的展示情况<ul>
<li>number：目录添加序号</li>
<li>wrap：多级目录缩进</li>
<li>expand_all：直接展开全部，否则只完全展开当前小节</li>
</ul>
</li>
<li>tagcloud：为标签页添加标签云效果，即是以词云形式显示标签。需要集成如hexo-tag-cloud插件</li>
<li>calendar：设置云日历，可以显示提交日期。找到一个挺好的插件hexo-generator-calendar</li>
<li>codeblock：代码块样式。设置代码高亮，复制按钮，边框样式（mac）等</li>
<li>reading_progress：顶部显示阅读进度条</li>
</ul>
<p>以下是一些第三方插件的集成方式。最大的体验就是NexT真的是一个很成熟的主题框架，很多很多的地方都已经配置好了模版，只需要简单安装插件，配置项中启用即可！</p>
<h2 id="百度统计功能集成"><a href="#百度统计功能集成" class="headerlink" title="百度统计功能集成"></a>百度统计功能集成</h2><p>NexT的<a href="http://theme-next.iissnan.com/getting-started.html">官方文档</a>中即有百度统计集成方式</p>
<p>具体方法也是十分简单，首先进入<a href="https://tongji.baidu.com/">百度统计官网</a>，登陆后新增网址填写域名地址等信息，即可以得到一段js脚本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> _hmt = _hmt || [];</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> hm = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  hm.src = &quot;https://hm.baidu.com/hm.js?1af6bacc90d9688e38f7413e7080cb35&quot;;	# 需要注意这段id</span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;script&quot;</span>)[<span class="number">0</span>]; </span><br><span class="line">  s.parentNode.insertBefore(hm, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>将此脚本添加到博客网站的html文件中即可。但这段脚本模版NexT已经帮我们写好，我们只需要在主题配置文件_config.yml中配置<strong>baidu_analytics</strong>字段即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baidu_analytics:</span> <span class="comment"># 内容是脚本中的hm.src中的url中js?以后的那段id数字</span></span><br></pre></td></tr></table></figure>
<p>此时在浏览器中通过开发者工具查看html源码，搜索<code>baidu</code>字段即可看到该脚本已经在html中生成</p>
<p>根据百度官网提示，也可以通过<a href="https://tongji.baidu.com/web/help/article?id=93">这些方式</a>确认是否集成成功</p>
<h2 id="Gitalk评论功能集成"><a href="#Gitalk评论功能集成" class="headerlink" title="Gitalk评论功能集成"></a>Gitalk评论功能集成</h2><p>想要集成一个评论功能，看了好些第三方像畅聊，多说，网易等都停止服务了，disqus又可能因为qiang的原因不方便使用。后来发现了<strong>gitment</strong>和<strong>gitalk</strong>，都是基于github仓库的issues的评论服务，感觉很满足我的需求了，在NexT中配置gitalk比较方便，故使用之。</p>
<ol>
<li><p>首先需要在github注册OAuth Application。填写App名称，域名，和描述。两个URL需填写博客地址，其余无甚要求。注意URL需要加上https://，建议直接地址栏复制</p>
<p>申请成功后会得到一个Client ID和Client secrets，这是配置需要用到的两个字段</p>
</li>
<li><p>NexT的_config.yml中已经有gitalk字段，只要根据注释进行配置即可，大概是github用户名，博客地址，两个id这样。</p>
</li>
<li><p>由于是基于issues，所以每一篇文章都需要在githubc仓库的issues里进行初始化，否则会出现</p>
<p><img src="/2021/01/31/Hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E8%BF%81%E7%A7%BB/gitalk.png" alt="未初始化"></p>
</li>
</ol>
<p>此时部署成功之后，即可在文章底部看到评论栏。如果某一篇文章不开放评论功能，可以在文中设置<code>comment: false</code></p>
<h2 id="valine评论功能集成"><a href="#valine评论功能集成" class="headerlink" title="valine评论功能集成"></a>valine评论功能集成</h2><p>后来又发现一种更好的评论插件valine，也可以由NexT的_config.yml直接集成</p>
<p>valine是由cloudclean提供的评论功能，所以需要有一个Cloudclean平台账号，评论数据会存储在cloudclean平台里。因此管理（删除）评论也是直接操作平台数据库进行。</p>
<p>Cloudclean创建应用具体操作及配置可以参考<a href="https://www.luanzhuxian.com/post/c49d1b87.html">这篇博客</a>。</p>
<p>创建完应用，得到appid，appkey，就可以填入NexT的_config.yml中，enable启用，即可在页面上看到效果。且如果不开启验证的话<code>notify</code>，直接输入即可进行评论，效果将会以一个Anonymous的身份进行评论。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># For more information: https://valine.js.org, https://github.com/xCss/Valine</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">xxxxx</span> <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">xxxxx</span> <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># Mail notifier</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">language:</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># Article reading statistic</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line">  <span class="comment">#post_meta_order: 0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>source/categories/index.md</code>和<code>source/tags/index.md</code>里要禁用<code>comments</code>，否则分类和标签页面会显示评论框</p>
</blockquote>
<h2 id="配置站内搜索"><a href="#配置站内搜索" class="headerlink" title="配置站内搜索"></a>配置站内搜索</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="comment"># 根据输入自动发起检索不需要回车</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="comment"># 显示每篇文章中命中的前n个关键字。设置-1可展示所有结果</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>NexT主题_config.yml文件中local_search字段启用，根据提示安装插件<code>npm install hexo-generator-searchdb</code></p>
<h2 id="显示文章字数及阅读时间"><a href="#显示文章字数及阅读时间" class="headerlink" title="显示文章字数及阅读时间"></a>显示文章字数及阅读时间</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>同样在主题_config.xml中symbols_count_time，并安装插件<code>npm install hexo-symbols-count-time</code></p>
<h2 id="RSS配置"><a href="#RSS配置" class="headerlink" title="RSS配置"></a>RSS配置</h2><blockquote>
<p>RSS 广泛用于网上新闻频道，blog和 wiki，主要的版本有 0.91, 1.0, 2.0。使用 RSS 订阅能更快地获取信息，网站提供 RSS 输出，有利于让用户获取网站内容的最新更新。网络用户可以在客户端借助于支持 RSS 的聚合工具软件，在不打开网站内容页面的情况下阅读支持 RSS 输出的网站内容。</p>
</blockquote>
<p>RSS功能具体是干什么的，其实我还是看不明白。这里主要是配置过程中，发现一些其他的小小问题，所以顺便记录一下。</p>
<div class="note info">
            <p>后来通过这个<a href="https://www.zhihu.com/question/19580096/answer/20490041">回答</a>，对RSS有了一些了解，确实是一种现在很少见的订阅咨询方式</p>
          </div>
<p>同样，NexT支持直接配置rss，但还需要安装插件<strong><code>npm install hexo-generator-feed</code></strong>，然后在NexT的_config.yml中，直接取消rss的注释即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">follow_me:</span></span><br><span class="line">  <span class="attr">RSS:</span> <span class="string">/atom.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-rss</span></span><br></pre></td></tr></table></figure>
<p>感到奇怪的是，页面刷新了，但是没有看到在侧边栏出现RSS的图标按钮，public/下确实如其他文章所说出现了atom.xml文件。一筹莫展之际看到<a href="https://suyin-blog.club/2020/2M3YWE7/">这篇博客</a>，其中说到</p>
<blockquote>
<p>在 <code>social:</code> 下添加以上代码。在 Next v7.7.2 中将 RSS 设置在了 <code>follow_me:</code> 下，这个是在文章的结尾处显示 RSS，而且占地比较大，所以我不太喜欢这个位置，还是喜欢以前的 <code>social:</code> 这个位置，这样会显示在侧边栏里，而且占地很小。</p>
</blockquote>
<p>果不其然，follow me下设置的RSS，会出现在文章底下，而且确实有一大块。于是在_config.yml中找到social，虽然其中没有预置rss一项，但是直接将<code>follow me</code>下的rss复制过去即可。想想确实也没有毛病，符合格式，有链接，有图标，很正常</p>
<h2 id="修改swig文件"><a href="#修改swig文件" class="headerlink" title="修改swig文件"></a>修改swig文件</h2><p>修改主题样式时经常需要直接修改swig文件。关于swig，我其实没有见过，大概是一个用于生成html的模版文件，解释器根据该文件所以对应的布局文件进行整合，拼凑最终的html文件</p>
<ul>
<li>language的文案：在swig中，可以通过<strong><code>__(&#39;xx.xx&#39;)</code></strong>的方式获取language中配置的文本</li>
<li>theme/_config.yml配置：在swig中，可以通过<strong><code>theme.xx</code></strong>获取主题配置文件中的配置信息</li>
<li>post配置：在swig中，可以通过<strong><code>post.xx</code></strong>获取在文章中配置的信息，当然自定义的属性也可以</li>
</ul>
<h2 id="拉拉杂杂"><a href="#拉拉杂杂" class="headerlink" title="拉拉杂杂"></a>拉拉杂杂</h2><p>以下记录一下看到的一些好玩（花里胡哨）的配置。</p>
<ul>
<li><p>在线聊天插件<a href="https://www.daocloud.io/">DaoVoice</a></p>
<p>建站时间，在<code>/blog/themes/next/layout/_partials/footer.swig</code>中添加这部分代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;days&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show_date_time</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="string">&quot;show_date_time()&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    BirthDay=<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;04/17/2018 15:13:14&quot;</span>);<span class="comment">//修改为自己的blog建站时间</span></span><br><span class="line">    today=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    timeold=(today.getTime()-BirthDay.getTime());</span><br><span class="line">    sectimeold=timeold/<span class="number">1000</span></span><br><span class="line">    secondsold=<span class="built_in">Math</span>.floor(sectimeold);</span><br><span class="line">    msPerDay=<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span></span><br><span class="line">    e_daysold=timeold/msPerDay</span><br><span class="line">    daysold=<span class="built_in">Math</span>.floor(e_daysold);</span><br><span class="line">    e_hrsold=(e_daysold-daysold)*<span class="number">24</span>;</span><br><span class="line">    hrsold=setzero(<span class="built_in">Math</span>.floor(e_hrsold));</span><br><span class="line">    e_minsold=(e_hrsold-hrsold)*<span class="number">60</span>;</span><br><span class="line">    minsold=setzero(<span class="built_in">Math</span>.floor((e_hrsold-hrsold)*<span class="number">60</span>));</span><br><span class="line">    seconds=setzero(<span class="built_in">Math</span>.floor((e_minsold-minsold)*<span class="number">60</span>));</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;days&#x27;</span>).innerHTML=<span class="string">&quot;本站已安全运行&quot;</span>+daysold+<span class="string">&quot;天&quot;</span>+hrsold+<span class="string">&quot;小时&quot;</span>+minsold+<span class="string">&quot;分&quot;</span>+seconds+<span class="string">&quot;秒&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setzero</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;i=<span class="string">&quot;0&quot;</span> + i&#125;;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">show_date_time();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>文章加密功能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;&#123;&#123; page.password &#125;&#125;&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (prompt(<span class="string">&#x27;请输入文章密码&#x27;</span>) !== <span class="string">&#x27;&#123;&#123; page.password &#125;&#125;&#x27;</span>)&#123;</span><br><span class="line">                alert(<span class="string">&#x27;密码错误！&#x27;</span>);</span><br><span class="line">                history.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>修改字体大小。</p>
<p>在<code>themes/next/source/css/_variables/base.styl</code>中的<code>font-size-headings-step</code></p>
<p>以及<code>themes/next/source/css/_variables/Mist.styl</code>中的<code>font-size-headings-base</code></p>
</li>
</ul>
<h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><a href="http://theme-next.iissnan.com">官方文档</a></h2><p><a href="http://theme-next.iissnan.com/third-party-services.html#algolia-search">第三方插件配置</a>：以上配置文档基本都有说明</p>
<p><a href="http://theme-next.iissnan.com/tag-plugins.html">内置标签使用</a>：可以适当美化文章</p>
<p><a href="http://theme-next.iissnan.com/theme-settings.html">文章配置</a></p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>技能帖</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Retrofit2学习记录</title>
    <url>/2019/07/26/Retrofit%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Retrofit2"><a href="#Retrofit2" class="headerlink" title="Retrofit2"></a>Retrofit2</h1><p>学习使用Retrofit和RxJava，简单记录一下重要的api和使用方法<br><a id="more"></a><br>需啊添加的依赖如下：<br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Retrofit主要类库</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:retrofit:2.0.2&#x27;</span></span><br><span class="line"><span class="comment">// Gson</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:converter-gson:2.0.2&#x27;</span></span><br><span class="line"><span class="comment">// okHttp</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.okhttp3:okhttp:3.10.0&#x27;</span></span><br><span class="line"><span class="comment">// 日志拦截器</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.okhttp3:logging-interceptor:3.9.1&#x27;</span></span><br></pre></td></tr></table></figure><br>Retrofit主要使用注解，标记请求头，请求方式，请求参数，请求格式。主要记一下请求参数和请求格式的注解意义：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Body</td>
<td>多用于post请求发送非表单数据,比如想要以post方式传递json格式数据</td>
</tr>
<tr>
<td>@Filed</td>
<td>多用于post请求中表单字段,Filed和FieldMap需要FormUrlEncoded结合使用</td>
</tr>
<tr>
<td>@FiledMap</td>
<td>和@Filed作用一致，用于不确定表单参数</td>
</tr>
<tr>
<td>@Part</td>
<td>用于表单字段,Part和PartMap与Multipart注解结合使用,适合文件上传的情况</td>
</tr>
<tr>
<td>@PartMap</td>
<td>用于表单字段,默认接受的类型是Map&lt;String,REquestBody&gt;，可用于实现多文件上传</td>
</tr>
<tr>
<td>@Path</td>
<td>用于url中的占位符</td>
</tr>
<tr>
<td>@Query</td>
<td>用于Get中指定参数</td>
</tr>
<tr>
<td>@QueryMap</td>
<td>和Query使用类似</td>
</tr>
<tr>
<td>@Url</td>
<td>指定请求路径</td>
</tr>
</tbody>
</table>
<hr>
<table>
<thead>
<tr>
<th>注解</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>@FormUrlEncoded</td>
<td>表示请求发送编码表单数据，每个键值对需要使用@Field注解</td>
</tr>
<tr>
<td>@Multipart</td>
<td>表示请求发送multipart数据，需要配合使用@Part</td>
</tr>
<tr>
<td>@Streaming</td>
<td>表示响应用字节流的形式返回.如果没使用该注解,默认会把数据全部载入到内存中.该注解在在下载大文件的特别有用</td>
</tr>
</tbody>
</table>
<p>使用示例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Headers(&#123;</span></span><br><span class="line"><span class="meta">            &quot;User-Agent: android&quot;,</span></span><br><span class="line"><span class="meta">            &quot;apikey: 28&quot;,</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      设置Url的三种方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@POST()</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">post1</span><span class="params">(<span class="meta">@Url</span> String url, <span class="meta">@QueryMap</span> Map&lt;String, String&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST(&quot;api/en/login&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">post2</span><span class="params">(<span class="meta">@QueryMap</span> Map&lt;String, String&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST(&quot;api/&#123;url&#125;/login&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">post3</span><span class="params">(<span class="meta">@Path(&quot;url&quot;)</span> String url, <span class="meta">@QueryMap</span> Map&lt;String, String&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> getId Query请求参数设置，将会以&quot;?id=getId&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET(&quot;...&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">get</span><span class="params">(<span class="meta">@Header(&quot;token&quot;)</span> String token, <span class="meta">@Query(&quot;id&quot;)</span> <span class="keyword">int</span> getId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用<span class="doctag">@Body</span>注解实现传入实体，自行转化成Json</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@POST(&quot;api/&#123;url&#125;/login&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">login</span><span class="params">(<span class="meta">@Path(&quot;url&quot;)</span> String url, <span class="meta">@Body</span> Entity post)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传图片</span></span><br><span class="line"><span class="comment">     * retrofit 2.0的上传和以前略有不同，使用<span class="doctag">@Multipart</span>注解和<span class="doctag">@Part</span> MultipartBody实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Multipart</span></span><br><span class="line">    <span class="meta">@POST(&quot;&#123;url&#125;&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">upload</span><span class="params">(<span class="meta">@Path(&quot;url&quot;)</span> String url, <span class="meta">@Part</span> MultipartBody.Part file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多张图片上传</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Multipart</span></span><br><span class="line">    <span class="meta">@POST(&quot;upload&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">upload</span><span class="params">(<span class="meta">@PartMap</span> Map&lt;String, MultipartBody.Part&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传图文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Multipart</span></span><br><span class="line">    <span class="meta">@POST(&quot;&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">register</span><span class="params">(<span class="meta">@Body</span> Entity post, <span class="meta">@PartMap</span> Map&lt;String, MultipartBody.Part&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件下载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Streaming</span></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function">Call&lt;Entity&gt; <span class="title">downloadPicture</span><span class="params">(<span class="meta">@Url</span> String fileUrl)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若要下载大体积的文件，如10m以上，强烈建议使用<span class="doctag">@Streaming</span>进行注解，否则将会出现IO异常.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Streaming</span></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function">Observable&lt;Entity&gt; <span class="title">downloadPicture2</span><span class="params">(<span class="meta">@Url</span> String fileUrl)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST()</span></span><br><span class="line">    <span class="meta">@FormUrlEncoded</span></span><br><span class="line">    <span class="function">Observable&lt;Entity&gt; <span class="title">executePost</span><span class="params">(<span class="meta">@FieldMap</span> Map&lt;String, Object&gt; maps)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注：使用@Path出现url被转义问题<br>设置Url的方法中，如果这样使用,就会出现url被转义，即‘/’被转义为乱码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@POST(&quot;&#123;url&#125;&quot;)</span></span><br><span class="line"><span class="function">Call&lt;Entity&gt; <span class="title">post</span><span class="params">(<span class="meta">@Path(&quot;url&quot;)</span> String url)</span></span>;</span><br></pre></td></tr></table></figure><br>因此使用这种方式需要这样写<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@POST(&quot;&#123;url&#125;&quot;)</span></span><br><span class="line"><span class="function">Call&lt;Entity&gt; <span class="title">post</span><span class="params">(<span class="meta">@Path(value = &quot;url&quot;, encoded = true)</span> String url)</span></span></span><br></pre></td></tr></table></figure></p>
<h1 id="使用与配置"><a href="#使用与配置" class="headerlink" title="使用与配置"></a>使用与配置</h1><p>说了这么多，终于开始具体使用。</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>首先需要创建一个请求方法接口ApiService，在其中编写需要用到的请求方法接口；<br>在创建一个RetrofitService类用于初始化及启动retrofit。代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRetrofitService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyRetrofitService</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">            .connectTimeout(<span class="number">10000L</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">            .readTimeout(<span class="number">10000L</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">&quot;URL&quot;</span>)</span><br><span class="line">            .client(okHttpClient)</span><br><span class="line">            <span class="comment">// 设置json转换器</span></span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>具体调用</strong> 时：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApiService api = MyRetrofitService.retrofit.create(ApiService.class);</span><br><span class="line">Call&lt;ResponseBody&gt; mData = api.get();</span><br><span class="line">mData.enqueue(<span class="keyword">new</span> Callback&lt;ResponseBody&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;ResponseBody&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="关于OkHttpClient更多具体配置"><a href="#关于OkHttpClient更多具体配置" class="headerlink" title="关于OkHttpClient更多具体配置"></a>关于OkHttpClient更多具体配置</h2><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><blockquote>
<p>addNetworkInterceptor 用于添加网络拦截器Network Interfacetor，它会在request和response时分别被调用一次；<br>addInterceptor 用于添加应用拦截器Application Interceptor，<strong>只会在response被调用一次</strong>。</p>
</blockquote>
<h4 id="1-日志拦截器"><a href="#1-日志拦截器" class="headerlink" title="1. 日志拦截器"></a>1. 日志拦截器</h4><p>使用addNetworkInterceptor()添加到OkHttpClient中<br>日志拦截器有两种创建方式:</p>
<ol>
<li>使用HttpLoggingInterceptor<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpLoggingInterceptor <span class="title">getHttpLoggingInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HttpLoggingInterceptor loggingInterceptor = <span class="keyword">new</span> HttpLoggingInterceptor(</span><br><span class="line">            <span class="keyword">new</span> HttpLoggingInterceptor.Logger() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;OkHttp&quot;</span>, <span class="string">&quot;log : &quot;</span> + message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</span><br><span class="line">    <span class="keyword">return</span> loggingInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>普通Interceptor<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> okhttp3.<span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">        Log.d(<span class="string">&quot;OkHttp&quot;</span>, <span class="string">&quot;HttpHelper1&quot;</span> + String.format(<span class="string">&quot;Sending request %s on %s%n%s&quot;</span>,</span><br><span class="line">                request.url(), chain.connection(), request.headers()));</span><br><span class="line"></span><br><span class="line">        okhttp3.Response response = chain.proceed(request);</span><br><span class="line">        <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        Log.d(<span class="string">&quot;OkHttp&quot;</span>, <span class="string">&quot;HttpHelper2&quot;</span> + String.format(<span class="string">&quot;Received response for %s in %.1fms%n%s&quot;</span>,</span><br><span class="line">                response.request().url(), (t2 - t1) / <span class="number">1e6d</span>, response.headers()));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-请求头拦截器"><a href="#2-请求头拦截器" class="headerlink" title="2. 请求头拦截器"></a>2. 请求头拦截器</h4>使用addInterceptor()添加到OkHttpClient中<blockquote>
<p>请求头拦截器为了让服务端能更好的识别该请求，服务器那边通过请求头判断该请求是否为有效请求等…</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用addHeader()不会覆盖之前设置的header,若使用header()则会覆盖之前的header</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Interceptor <span class="title">getRequestHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Interceptor headerInterceptor = <span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> okhttp3.<span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Request originalRequest = chain.request();</span><br><span class="line">            Request.Builder builder = originalRequest.newBuilder();</span><br><span class="line">            builder.addHeader(<span class="string">&quot;version&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">            builder.addHeader(<span class="string">&quot;time&quot;</span>, System.currentTimeMillis() + <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Request.Builder requestBuilder = builder.method(originalRequest.method(), originalRequest.body());</span><br><span class="line">            Request request = requestBuilder.build();</span><br><span class="line">            <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> headerInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-统一请求拦截器"><a href="#3-统一请求拦截器" class="headerlink" title="3. 统一请求拦截器"></a>3. 统一请求拦截器</h4><p>使用addInterceptor()添加到OkHttpClient中<br>统一请求拦截器的功能跟请求头拦截器相类似<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器Interceptors</span></span><br><span class="line"><span class="comment"> * 统一的请求参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Interceptor <span class="title">commonParamsInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Interceptor commonParams = <span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> okhttp3.<span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Request originRequest = chain.request();</span><br><span class="line">            Request request;</span><br><span class="line">            HttpUrl httpUrl = originRequest.url().newBuilder().</span><br><span class="line">                    addQueryParameter(<span class="string">&quot;paltform&quot;</span>, <span class="string">&quot;android&quot;</span>).</span><br><span class="line">                    addQueryParameter(<span class="string">&quot;version&quot;</span>, <span class="string">&quot;1.0.0&quot;</span>).build();</span><br><span class="line">            request = originRequest.newBuilder().url(httpUrl).build();</span><br><span class="line">            <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> commonParams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-时间拦截器"><a href="#4-时间拦截器" class="headerlink" title="4. 时间拦截器"></a>4. 时间拦截器</h4><p>使用addInterceptor()方法添加到OkHttpClient中<br>从响应中获取服务器返回的时间<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过响应拦截器实现了从响应中获取服务器返回的time</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Interceptor <span class="title">getResponseHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Interceptor interceptor = <span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> okhttp3.<span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            okhttp3.Response response = chain.proceed(chain.request());</span><br><span class="line">            String timestamp = response.header(<span class="string">&quot;time&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (timestamp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取到响应header中的time</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>使用okhttp缓存，先要创建Cache，然后在创建缓存拦截器<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Cache</span></span><br><span class="line">File httpCacheDirectory = <span class="keyword">new</span> File(MyApp.getContext().getCacheDir(), <span class="string">&quot;OkHttpCache&quot;</span>);</span><br><span class="line">Cache cache = <span class="keyword">new</span> Cache(httpCacheDirectory, <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">httpClientBuilder.cache(cache);</span><br><span class="line"><span class="comment">// 设置缓存</span></span><br><span class="line">httpClientBuilder.addNetworkInterceptor(getCacheInterceptor2());</span><br><span class="line">httpClientBuilder.addInterceptor(getCacheInterceptor2());</span><br></pre></td></tr></table></figure></li>
<li>缓存拦截器<br>缓存时间自己根据情况设定<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在无网络的情况下读取缓存，有网络的情况下根据缓存的过期时间重新请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Interceptor <span class="title">getCacheInterceptor2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Interceptor commonParams = <span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> okhttp3.<span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Request request = chain.request();</span><br><span class="line">            <span class="keyword">if</span> (!NetworkUtils.isConnected()) &#123;</span><br><span class="line">                <span class="comment">//无网络下强制使用缓存，无论缓存是否过期,此时该请求实际上不会被发送出去。</span></span><br><span class="line">                request = request.newBuilder().cacheControl(CacheControl.FORCE_CACHE)</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            okhttp3.Response response = chain.proceed(request);</span><br><span class="line">            <span class="keyword">if</span> (NetworkUtils.isConnected()) &#123;<span class="comment">//有网络情况下，根据请求接口的设置，配置缓存。</span></span><br><span class="line">                <span class="comment">//这样在下次请求时，根据缓存决定是否真正发出请求。</span></span><br><span class="line">                String cacheControl = request.cacheControl().toString();</span><br><span class="line">                <span class="comment">//当然如果你想在有网络的情况下都直接走网络，那么只需要</span></span><br><span class="line">                <span class="comment">//将其超时时间这是为0即可:String cacheControl=&quot;Cache-Control:public,max-age=0&quot;</span></span><br><span class="line">                <span class="keyword">int</span> maxAge = <span class="number">60</span> * <span class="number">60</span>; <span class="comment">// read from cache for 1 minute</span></span><br><span class="line">                <span class="keyword">return</span> response.newBuilder()</span><br><span class="line">                        .header(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;public, max-age=&quot;</span> + maxAge)</span><br><span class="line">                        .removeHeader(<span class="string">&quot;Pragma&quot;</span>)</span><br><span class="line">                        .build();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//无网络</span></span><br><span class="line">                <span class="keyword">int</span> maxStale = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">28</span>; <span class="comment">// tolerate 4-weeks stale</span></span><br><span class="line">                <span class="keyword">return</span> response.newBuilder()</span><br><span class="line">                        .header(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;public,only-if-cached,max-stale=&quot;</span> + maxStale)</span><br><span class="line">                        .removeHeader(<span class="string">&quot;Pragma&quot;</span>)</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> commonParams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义CookieJar"><a href="#自定义CookieJar" class="headerlink" title="自定义CookieJar"></a>自定义CookieJar</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">httpClientBuilder.cookieJar(<span class="keyword">new</span> CookieJar() &#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;HttpUrl, List&lt;Cookie&gt;&gt; cookieStore = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveFromResponse</span><span class="params">(HttpUrl url, List&lt;Cookie&gt; cookies)</span> </span>&#123;</span><br><span class="line">        cookieStore.put(url, cookies);<span class="comment">//保存cookie</span></span><br><span class="line">        <span class="comment">//也可以使用SP保存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Cookie&gt; <span class="title">loadForRequest</span><span class="params">(HttpUrl url)</span> </span>&#123;</span><br><span class="line">        List&lt;Cookie&gt; cookies = cookieStore.get(url);<span class="comment">//取出cookie</span></span><br><span class="line">        <span class="keyword">return</span> cookies != <span class="keyword">null</span> ? cookies : <span class="keyword">new</span> ArrayList&lt;Cookie&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="使用RxJava"><a href="#使用RxJava" class="headerlink" title="使用RxJava"></a>使用RxJava</h1>使用RxJava的目的是，RxJava可以更加简洁的实现异步操作。<h2 id="RxJava的简单理解"><a href="#RxJava的简单理解" class="headerlink" title="RxJava的简单理解"></a>RxJava的简单理解</h2>Rxjava使用观察者模式实现，因此其中有几个基本概念就是Observable被观察者，Observer观察者，subscribe订阅事件。（关于观察者模式最经典的实现就是OnClickListener）Observable与Observer通过subcribe()实现订阅关系，Observable就可以在发生指定事件时通知Observer。<br>不同于传统的观察者模式，Rxjava的回调方法除了onNext()（相当于onClick()），还有onCompleted()和onError()方法。由于Rxjava会将每个事件作为一个事件队列处理，并把每个事件单独处理。以此为前提既可以理解另外两个方法：</li>
<li>onCompleted() 当事件队列结束，不会有新的onNext()发出时，即会触发onCompleted()方法。</li>
<li>onError() 当事件队列出现异常是会触发onError()，并且会同时停止事件队列，不允许新的事件发出。</li>
<li>那么可能会有疑问，异常以后没有事件发出，是否会调用onCompleted()。答案是不会，在一个正常的时间序列中，onCompleted()与onError()方法有且只有一个，二者互斥，即调用其中一个就不会调用另外一个，且都是事件队列中最后一个调用。</li>
</ul>
<h2 id="Rxjava的简单实现"><a href="#Rxjava的简单实现" class="headerlink" title="Rxjava的简单实现"></a>Rxjava的简单实现</h2><p>注：一下代码的实现依据rxjava版本为，io.reactivex.rxjava:1.3.8，是一个比较旧的版本了，从这以后rxjava开始2.0版本，有了一些新的改动。但是以此版本理解RxJava的使用思想还是没有问题，而且更加简易更好理解。</p>
<ol>
<li><p>创建观察者Observer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">&quot;Item: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">&quot;Completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除了Observer接口，RxJava还内置了一个实现了Observer的抽象类：Subscriber。 Subscriber是Observer的扩展，但他们的基本使用方式完全一样（同上）。<br>实质上，在RxJava的subscribe过程中，Observer也总是会先被转换成一个Subscriber再使用。</p>
<blockquote>
<p>关于区别<br>onStart(): 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法，具体可以在后面的文中看到。<br>unsubscribe(): 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe()来解除引用关系，以避免内存泄露的发生。</p>
</blockquote>
</li>
<li><p>创建Observable被观察者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">&quot;Aloha&quot;</span>);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>create()方法中传入了参数<strong>OnSubscribe</strong>对象会被存储在Observable对象中，相当于一个计划表。当Observable被订阅，将回调call()方法，依次触发call中的事件序列。因此例如实际使用中，就可以在call()中进行异步操作，如网络请求，然后将请求的结果通过onNext()的参数发送出去。<br>除了使用create()方法，Rxjava还提供其他方法创建事件队列</p>
<ul>
<li>just(T…)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用等同上例</span></span><br><span class="line">Observable observable = Observable.just(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Aloha&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>from(T[]) / from(Iterable&lt;? extends T&gt;)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将传入的数组或可迭代对象拆分成具体对象后，依次发送出来。</span></span><br><span class="line">String[] words = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Aloha&quot;</span>&#125;;</span><br><span class="line">Observable observable = Observable.from(words);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>实现订阅Subscribe<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这看起来是『observalbe 订阅了 observer / subscriber』，思维逻辑上虽然有些别扭，但是这有利于流式api的设计<br>Observable.subscribe()内部代码结构如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</span><br><span class="line">    subscriber.onStart();</span><br><span class="line">    onSubscribe.call(subscriber);</span><br><span class="line">    <span class="keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将传入的 Subscriber 作为 Subscription 返回。这是为了方便 unsubscribe().</p>
</blockquote>
</li>
</ol>
<h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><p>subscriber()支持不完整定义的回调，可以根据定义自动创建Subscriber。使用方式如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Action1&lt;String&gt; onNextAction = <span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda表达式写法，内容同上</span></span><br><span class="line">Action1&lt;Throwable&gt; onErrorAction = (e) -&gt; System.out.println(<span class="string">&quot;error&quot;</span> + e);</span><br><span class="line"></span><br><span class="line">Action0 onComAction = () -&gt; System.out.println(<span class="string">&quot;com&quot;</span>);</span><br><span class="line"></span><br><span class="line">Observable observable = Observable.just(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Aloha&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动创建Subscriber</span></span><br><span class="line">observable.subscribe(onNextAction);</span><br><span class="line">observable.subscribe(onNextAction, onErrorAction);</span><br><span class="line">observable.subscribe(onNextAction, onErrorAction, onComAction);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>简单解释一下这段代码中出现的 Action1 和 Action0。<br>Action0 是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；由于 onCompleted() 方法也是无参无返回值的，因此 Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数（onComAction）传入 subscribe() 以实现不完整定义的回调。这样其实也可以看做将 onCompleted() 方法作为参数传进了 subscribe()，相当于其他某些语言中的『闭包』。<br>Action1 也是一个接口，它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；与 Action0 同理，由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj) 和 onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。事实上，虽然 Action0 和 Action1 在 API 中使用最广泛，但 RxJava 是提供了多个 ActionX 形式的接口 (例如 Action2, Action3) 的，它们可以被用以包装不同的无返回值的方法。</p>
</blockquote>
<p>简单来说就是一个有参一个无参的包装类，无参的类可以用于构建onCompleted()，有参的可以用于构建onNext()或onError()。subsrcribe()重载了3个关于ActionX的方法，就是上述代码中的3个。比如第三个方法参数表为(Action1&lt;? super T&gt;, Action1<Throwable>, Action0)，以此限定了三个参数的位置。</p>
<p>接下来用一个例子小结一下：</p>
<blockquote>
<p>由 id 取得图片并显示： 由指定的一个 drawable 文件 id drawableRes 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> drawableRes = ...;</span><br><span class="line">ImageView imageView = ...;</span><br><span class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Drawable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        Drawable drawable = getTheme().getDrawable(drawableRes));</span><br><span class="line">        subscriber.onNext(drawable);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Drawable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123;</span><br><span class="line">        imageView.setImageDrawable(drawable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(activity, <span class="string">&quot;Error!&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>以上代码，对上面RxJava的内容进行了小结。可以看到，在Observable的call()方法中进行所要进行的异步操作，然后在subcribe的Observer（Subscriber）中通过onNext，onError，onCompleted设置回调方法。这就是Rxjava的基础使用格式。</p>
</blockquote>
<h2 id="异步-线程控制Scheduler"><a href="#异步-线程控制Scheduler" class="headerlink" title="异步-线程控制Scheduler"></a>异步-线程控制Scheduler</h2><p>然而到这里，都和开头所说RxJava的主要作用异步还没有什么关系。因为Rxjava默认是在运行在同一线程。<br>想要实现异步机制，就需要用到RxJava的第四个概念Scheduler。</p>
<blockquote>
<p>观察者模式本身的目的就是『后台处理，前台回调』的异步机制<br>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。</p>
</blockquote>
<p>RxJava通过Scheduler指定一个代码段需要运行在哪一个进程。</p>
<ul>
<li><strong>subscribeOn()</strong> 指定subscribe()发生的进程。即 Observable.OnSubscribe 被激活时所处的线程，事件产生的线程。</li>
<li><strong>observeOn()</strong> 指定Subscriber所运行的线程。即事件消费进程。</li>
</ul>
<p>RxJava中内置了几个进程，以适用一些默认场景：</p>
<blockquote>
<ul>
<li>Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</li>
<li>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</li>
<li>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</li>
<li>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</li>
<li>Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。</li>
</ul>
</blockquote>
<p>还是使用Android中图片显示的例子</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> drawableRes = ...;</span><br><span class="line">ImageView imageView = ...;</span><br><span class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Drawable&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</span><br><span class="line">       Drawable drawable = getTheme().getDrawable(drawableRes));</span><br><span class="line">       subscriber.onNext(drawable);</span><br><span class="line">       subscriber.onCompleted();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.subscribeOn(Schedulers.io()) <span class="comment">// 指定 subscribe() 发生在 IO 线程</span></span><br><span class="line">.observeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定 Subscriber 的回调发生在主线程</span></span><br><span class="line">.subscribe(<span class="keyword">new</span> Observer&lt;Drawable&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123;</span><br><span class="line">       imageView.setImageDrawable(drawable);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">       Toast.makeText(activity, <span class="string">&quot;Error!&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>即 加载图片将会发生在 IO 线程，而设置图片则被设定在了主线程。这就意味着，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成丝毫界面的卡顿。</p>
</blockquote>
<h2 id="Schedule的原理：变换"><a href="#Schedule的原理：变换" class="headerlink" title="Schedule的原理：变换"></a>Schedule的原理：变换</h2><h2 id="先具体实现一下RxJava-Retrofit"><a href="#先具体实现一下RxJava-Retrofit" class="headerlink" title="先具体实现一下RxJava+Retrofit"></a>先具体实现一下RxJava+Retrofit</h2><p><a href="https://www.jianshu.com/p/73216939806a">Retrofit参考链接</a><br><a href="http://gank.io/post/560e15be2dca930e00da1083">RxJava参考链接</a></p>
<hr>
<div class="note default">
            <p>未完待续…</p>
          </div>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>秘籍帖</tag>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title>来吧设计模式</title>
    <url>/2019/10/14/%E6%9D%A5%E5%90%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="关于设计模式"><a href="#关于设计模式" class="headerlink" title="关于设计模式"></a>关于设计模式</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>  写了两年的Java和Android，对于面向对象的思想已然有了自己的一份体会，并在一次次的实践中，加深对这种思想的体会。每一次对代码封装复用，松耦合设计的过程中，都能感受到面向对象思想带来的愉悦，这大概就是其魅力所在。关于设计模式，也不可避免的接触了一些想观察者模式，单例模式，工厂模式等，但对于他们都是只停留在简单的实践阶段，对于其思想并没有太深刻的体会。<br>  在我看来，作为一个Java程序员，面向对象以及设计模式的思想深度，将决定其写出来的代码，是一个精致巧妙的艺术品，还是如书中所说是一团毫无弹性的意大利面。<br>  决定需要好好恶补一下关于设计模式的知识，我选择了《Head First 设计模式》，就目前所翻阅到章节看来，我选对了！<br><a id="more"></a></p>
<h1 id="来吧设计模式"><a href="#来吧设计模式" class="headerlink" title="来吧设计模式"></a>来吧设计模式</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>  这个模式一直有所耳闻，但一直没有了解。书中没有一开始就点明使用策略模式，最后一刻道破的时候，真的使我有种茅塞顿开的通透感。<br>  原来平时代码中面向接口，继承组合，都是在践行这种设计模式。关于定义，书中给出的描述是：</p>
<blockquote>
<p>定义了算法族，分别封装起来，使他们之间可以互相替换，使得算法的变化独立于使用该算法的用户</p>
</blockquote>
<p>我的理解是，<strong>将有可能变化的代码抽离出来与稳定不变的代码分开</strong>，成为所谓的算法族（其实就是行为组，对象的所有行为），<strong>使得新的业务逻辑的改变不会影响的旧的代码</strong>。<strong>通过组合的方式，为特定的对象赋予特定的方法组</strong>。<br>  书中使用定义多种类的鸭子作为例子，即将鸭子的行为（不同鸭子行为不同，即为可能变化的部分）抽象出来，成为一个接口，使用该接口实现不同的行为类，这是<strong>封装变化</strong>。然后在鸭子的实际类中，持有一个行为接口的引用，通过setter灵活的对该接口进行实例化，从而达到在运行时，动态的修改增加鸭子行为的效果，这是<strong>使用组合</strong>。<br>关于类的组合，看《Java编程思想》时候就有所了解，当时并不理解为什么说“少用继承，多用组合”，“‘有一个’比‘是一个’更好”，但现在终于有了自己的一点理解。使用继承，意味着可能会出现大量重复的代码，或者局部的修改影响到大部分的代码的情况；而使用组合，可以很容易的知道类的所有算法族，通过setter的方式，灵活修改算法族，并且对于新的算法族的增加，不会影响到已有的代码逻辑。这就是组合优于继承地方。关于组合的缺点，个人觉得可能与增加了类和接口的数量，或者使得类的结构变得复杂有关。</p>
<blockquote>
<p>OO设计原则<br>将代码中可能需要变化之处独立出来，不要和那些不需要变化的代码混合在一起。<br>针对接口编程，而不针对实现编程<br>多用组合，少用继承</p>
</blockquote>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>  这是一个相对来说已经十分熟悉的设计模式，在android中，有许多类似的实现，如button的点击事件设置等，甚至常用的接口回调，我都觉得有点观察者模式的味道。<br>  关于观察者模式，我的理解是，<strong>对象A对对象B的状态感兴趣（关注），于是A对B进行订阅，则B的状态发生变化时，则会对所有订阅的对象进行通知，订阅对象A再根据B的通知作出相应的动作。因此如果B迟迟没有发生变化，则A不会出现相应的反应。</strong><br>  再来看看书中的理解。观察者模式定义是：定义了对象间的一对多的依赖，当一个对象改变状态时，其所有依赖者将收到通知并自动更新。我认为这与我的理解基本一致。<br>  关于观察者模式的实现，书中介绍了两种方式，一种是面向接口式的实现，一种是java.util中内置的Observer实现方式。<br>  提出内置观察者模式的原因，主要为了解决，主题向观察者推送更新时，会把所有的新数据都推送给观察者，或者将一些细微的变化都推送出去，但其实有的观察者只需要其中的某几个数据足矣。因此可以使用观察者拉取的方式，观察者主动向主题拉取数据。<br>  java.util内置的Observer，只通知观察者更新，但观察者需要自己拉取的方式实现。这是我有些困惑，其本质其实相似，主题通过observer.update()方法通知observer更新的消息，并附上对象实例作为参数，让观察者用getter的方式获取部分特定的数据。<br>  重新看过这一章，发现果然有遗漏的地方。其实java.util的观察者模式，支持主题向观察者推送数据，也支持观察者自己向主题拉取数据。Observer.update(Observable, Object)方法，需要将Observable传入以告知观察者是哪一个主题的更新。<strong>如果使用主题推送的方式，则将数据以Object的方式推送给观察者，如果是观察者拉取的方式，则观察者收到通知后，自己通过主题的实例获取更新的数据。</strong>关于细微变化的推送，内置的观察者是在notify之前加了一层判断，判断当前的更新是否需要推送。<br>  有一点需要注意，<strong>不可依赖观察者接收通知的次序</strong>。毕竟主题是通过对订阅列表的遍历进行通知的，所以接收通知的次序不可被过分依赖。<br>  关于java内置的观察者，书中还提到一件事。就是其Observable是需要通过继承实现的并且其中像setChange()方法都是受保护的（protected），因此也不能通过组合的方式实现。这也就违背了“多用组合少用继承”的原则。</p>
<blockquote>
<p>因为Observable是一个类，你必须设计一个类继承它。…<strong>毕竟Java不支持多重继承，这限制了Observable的复用潜力。</strong><br>除非你继承自Observable，否则你无法创建Observable实例并组合到你的对象中来。<br>观察者模式作为一种新的模式，以松耦合的方式在一系列对象之间沟通状态。其典型的代表即为之前Android中常用的MVC模式。</p>
</blockquote>
<blockquote>
<p>观察者模式中，主题的状态，观察者的数目和类型都会改变，使用该模式，可以改变依赖主题状态的对象，而不用改变主题。<br>观察者模式使用组合，在运行时将观察者动态的“组合”进主题中。对象间的这种关系不是通过继承产生而是通过运行时的组合实现。<br>观察者利用主题的接口进行订阅，主题通过观察者的接口进行更新的通知。使两者之间运作正常却又松耦合。</p>
</blockquote>
<p>  又注意到一个问题，观察者模式的写法，跟回调函数好像有点相似。看了几篇博客，印证了自己的猜想。总结就是，回调模式是观察者模式的特殊实现，不同于一般的一对多的观察者模式，回调模式是一对一的观察者模式。</p>
<blockquote>
<p>OO设计原则<br>为了交互对象之间的松耦合设计而努力，即对象之间依然可以正常交互，但是不太清楚彼此的细节。</p>
</blockquote>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><blockquote>
<p>我曾以为男子汉应该用继承处理一切。后来我领教到<strong>运行时扩展，远远比编译时期的继承</strong>威力大…</p>
</blockquote>
<p>  说到装饰者模式，我依然只是有所耳闻，但始终没有去了解这是一个怎样的模式，只是隐隐觉得它好像和工厂模式或者build有所关联。<br>  这一章节中经常出现的一句话：<strong>类的设计应当对扩展开放，对修改关闭</strong>，即“开放-关闭原则”。大概意思是在需求发生变化或者新增时，应当通过扩展原有类的方式进行更新，而不是通过修改原有类的方式。但说实在，对于这句话我没有在更深层次的体会和理解，大概还是OO检验欠缺的缘故。<br>  使用装饰者模式，大概就是对类的一种扩展实现。<strong>装饰者模式，旨在使用扩展+委托的方式代替继承</strong>。书中的定义是：<strong>动态的将责任附加到对象上，提供了一种比继承更有弹性的的扩展的方案。</strong><br>  基本的实现是：首先要求装饰者与被装饰者属于同一类型（基类），通过不断使用装饰类包装（组合）被装饰类的方式，实现类功能属性的拓展更新。即实现扩展的效果，又不修改原有的类实现。<br>  关于装饰者与被装饰者需要继承同一基类，书中这样解释：</p>
<blockquote>
<p>这里利用继承达到“类型匹配”的效果，而不是利用继承获取“行为”。</p>
</blockquote>
<p>  为了装饰类可以对被装饰类进行包装去取代，需要它们有相同的类型，而行为的获得，是通过组合实现，所以这里使用继承，并不影响OO的设计原则。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被装饰者（茶）</span></span><br><span class="line">Tea tea = <span class="keyword">new</span> Tea();</span><br><span class="line"><span class="comment">// 装饰者开始装饰</span></span><br><span class="line">Decoration decoration = <span class="keyword">new</span> Milk(tea);</span><br><span class="line">decoration = <span class="keyword">new</span> Sugar(decoration);</span><br><span class="line">decoration = <span class="keyword">new</span> Soy(decoration);</span><br><span class="line">decoration = <span class="keyword">new</span> Coffee(decoration);</span><br></pre></td></tr></table></figure><br>  最简单的装饰者模式实现如上，有点奇怪，好像没有见过这种代码，又好像似曾相识。书中预示道：工厂模式和生成器模式会对装饰者模式有更好的实现方式，这便是我想起了见过生成器模式代码中相似的类的包装。<br>  如果用户需要窥视装饰者链中的每一个装饰者，可以使用一个数据结构如列表等实现方式实现。<br>  关于装饰者模式的经典实现，书中介绍了Java I/O，我立即回想起了当初使用java的文件IO流时，构造流的一系列摸不着头脑的麻烦操作，原来那个过程就是对IO流的一系列装饰以使其获得更多功能如LineNumberInputStream计算行数功能，BufferedInputStream增加缓冲输入改进性能。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>  终于啃完了这一章。工厂方法，也许是听的最早的设计模式，早在学习Java的时候，就了解过通过静态工厂方法初始化对象的操作。因此对其印象一直只是对对象实例化的封装，然而这一章的诸多概念，确看的一头雾水，一翻目录发现这一章的篇幅竟是其他的两倍！我一共读了三遍，才得以稍微理解。<br>  关于工厂模式书中介绍了三个概念，简单工厂，工厂方法模式，抽象工厂模式。</p>
<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>  简单工厂并不是一种设计模式，只能说是一种变成习惯，即是<strong>将对象初始化的工程封装到一个工厂类中</strong>，由该工厂对该类进行初始化。其中工厂的方法一般设为静态，即是所谓静态工厂方法。<br>  其实说白，就是将一个类的实例化（new过程），放到另一个类（工厂类）的静态方法中，使得类的初始化与客户代码分离。<br>  关于静态工厂，可以实现不创建工厂实例的情况下创建对象。但因为也因为是静态的不能通过继承扩展方法。</p>
<h3 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>  工厂模式，是将实际创建对象的工厂方法，从工厂类移到需要创建对象的类中，并设为抽象，由该类的子类决定其该创建具体的子类。<br>  所谓让子类决定，使用书中的比萨店的例子说，在PizzaStore中通过工厂方法实例化Pizza对象，并在orderPizza()中使用该对象。其中由于工厂方法是抽象的，所以orderPizza()在使用Pizza对象时，并不能确定该对象的类型，只有PizzaStore子类实现工厂方法时，Pizza的具体对象类型才能确定。其中，PizzaStore类即为Creator，Pizza为Product，PizzaStore的子类为ConcreteCreator，Pizza的子类为ConcreteProduct。<br>  <strong>orderPizza()方法中使用的Pizza类型是抽象的，所以它不清楚Pizza的具体类型，这就是所谓的 解耦</strong>。<br>  工厂方法：定义一个创建对象的接口，但由子类决定要实例化哪一个类。<strong>工厂方法将类的实例化推迟到子类</strong>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂方法的一般形式，让子类处理类的创建，并必须返回一个产品。</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> Product <span class="title">factoryMethod</span><span class="params">(String type)</span></span></span><br></pre></td></tr></table></figure><br><strong>通过工厂方法对象的使用者与对象的具体创建分割开来。</strong></p>
<blockquote>
<p>一个工厂方法与其使用者的联合，可以视为一个框架；<br>此外，工厂方法将创建对象的方法封装到每一个创建者中，这样的做法也可视为一个框架。</p>
</blockquote>
<ul>
<li><p><strong>工厂模式与简单工厂的区别</strong><br>每一个ConcreteCreator看起来都有点像一个简单工厂，但其实有很大区别。在工厂模式中，工厂方法扩展自所有Creator共有的基类中的抽象方法，由每一个ConreteCreator负责实现，而简单工厂中的工厂，只是Creator中使用的对象。简单工厂中，将所有的事情放在一个地方全部实现，因此其代码缺乏弹性。<br>而工厂模式中，通过一个框架的形式，让子类去决定如何实现。而简单工厂仅是封装了对象的创建过程，却<strong>无法变更正在创建的产品</strong>。（其实这句话没能完全理解，可能对运行时还是没有很透彻吧）</p>
</li>
<li><p>工厂方法不一定要抽象，可以存在一个默认实现的工厂方法，由它实现默认生产的产品。</p>
</li>
</ul>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><blockquote>
<p>要依赖抽象，不要依赖具体类<br>不能让高层组件依赖底层组件，两者都应该依赖抽象<br>  例如在工厂方法模式中，ConcreteProduct类和Creator都依赖于Product抽象类。而一般的OO思想是Creator类依赖于ConcreteProduct，因为ConcreteProduct都在Creator中被实例化，但在工厂模式中就都依赖于抽象的Product，就是依赖倒置。因此工厂模式也是遵循对象倒置的重要手段。</p>
<ul>
<li><strong>依赖倒置原则</strong>的建议<ol>
<li>变量不可以持有具体类的引用（使用工厂方法可以实现这一点</li>
<li>不要让类派生自具体类（这样会依赖一个具体类</li>
<li>不要覆盖基类的方法（基类中已经实现的方法，应该被子类共享</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>  创建一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。<strong>允许用户通过一组接口方法来创建一组对象，而不需要关心实际创建的对象的具体类，使得客户与创建的具体对象解耦</strong>。<br>  <strong>抽象工厂的方法经常使用工厂方法实现</strong>，由此也能看出，抽象工厂一般用于实现一组对象，工厂方法一般用于实现一种对象</p>
<ul>
<li><strong>抽象工厂与工厂方法的区别</strong><br>工厂方法通过继承创建对象，而抽象工厂使用的是对象的组合。这是说工厂方法创建具体的对象，将该对象实例化进行包装，需要继承扩展一个基类，实现其中的工厂方法。而抽象工厂需要提供一个交代了产品中的对象的生产方法的接口实现类，通过该类实现整个产品家族的创建，以这种方式实现用户与实际产品的解耦。而工厂方法不需要提供一个接口，只需要实现一个工厂方法就好了。<br>其实只要认真研读，书中的思路还是很清晰的，只能怪自己第一遍看的不仔细吧…=_=。</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>  关于单例模式大概是目前我用过的比较清晰地设计模式，因为单例模式其实很好理解，<strong>就是对外隐藏自身的构造方法，只在类的内部初始化一个唯一的实例变量并提供一个外部获取该实例的方法，实现类似全局变量的效果且在代码中只有一个唯一的对象实例</strong>。<br>  当然我也了解到，我一般使用的都还是最为基础的单例实现，关于单例模式还有很多的实现平时很少使用，如懒汉单例，线程安全的单例等。<br>  关于单例模式的使用场景，书中举例有：线程池，缓存，对话框，偏好设置或注册表的对象，日志，设备驱动或网络连接的对象等。<br>  书中的定义为：单件模式确保一个类只有一个实例，并提供一个全全局的访问点。</p>
<h3 id="懒汉式实现"><a href="#懒汉式实现" class="headerlink" title="懒汉式实现"></a>懒汉式实现</h3><p>  最经典的实现方式，也叫懒汉式实现，实现了一种延迟实例化的效果。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  该单例通过getInstance()方法获取到Singleton实例，每一次调用时判断实例对象是否为空，为空则初始化。因此，如果在代码中一直没有用到该单例，则该单例对象永远不会被初始化，即所谓的延迟实例化。</p>
<h3 id="线程安全的懒汉式实现"><a href="#线程安全的懒汉式实现" class="headerlink" title="线程安全的懒汉式实现"></a>线程安全的懒汉式实现</h3><p>  当然这种实现方式在多线程下是不安全的，因为当两个线程同时执行getInstance()中时，同时判断instance为空从而分别创建了对象。<br>  解决方法可以是使getInstance()方法同步，即加上synchronized修饰getInstance()。但这种解决方式的缺陷是，代码会在每次调用getInstance()时，因为同步机制消耗不必要的性能。但其实我们只需要对创建对象的过程进行同步。</p>
<h3 id="急切实例化的饿汉式实现"><a href="#急切实例化的饿汉式实现" class="headerlink" title="急切实例化的饿汉式实现"></a>急切实例化的饿汉式实现</h3><p>  饿汉式的实现方式，其实就是在类加载的过程中对instance进行实例化。这样实现的好处是，代码中任何时刻使用getInstance()获取单例时，单例都已经被初始化了。</p>
<blockquote>
<p>在静态初始化器中创建单件，保证了线程的安全。<br>JVM保证在任何线程访问instance之前一定对其进行初始化。</p>
</blockquote>
<h3 id="双重校验锁式实现"><a href="#双重校验锁式实现" class="headerlink" title="双重校验锁式实现"></a>双重校验锁式实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双重校验锁式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>)				</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该实现方式，只有在第一次调用时才会进行同步。且进入同步区以后还会对instance进行检查，还是为null时才进行对象的创建。该方式可以大大减少getInstance()时的时间消耗。<br><strong>注：</strong>在Java1.5以前的jvm对volatile的实现会导致双重检查加锁的失效。因此如果对性能没有很大的要求，尽量不要使用该实现方式，因为较为繁琐还需要考虑Java的版本。</p>
<blockquote>
<p>是否可以使用类的单件代替对象的单件，即设置一个类和字段都为静态的类？<br>如果该类可以自给自足且初始化过程不是很复杂，可以使用。但是静态初始化的控制权在Java手上，当涉及较多的类时，可能出现由于类的初始化次序导致的问题。</p>
</blockquote>
<blockquote>
<p>因为每一个类加载器都会定义一个命名空间，所以不同的类加载器可能会加载同一个类，使得程序中出现两个单件。解决方式是，自行指定类加载器，并指定同一个类加载器。</p>
</blockquote>
<p>饿汉式实现</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><div class="note default">
            <p>未完待续…</p>
          </div>
<h1 id="总结设计模式"><a href="#总结设计模式" class="headerlink" title="总结设计模式"></a>总结设计模式</h1><ul>
<li>愈往下读，愈发感觉<strong>继承，多态，封装</strong>这几个字更加厚重</li>
<li>书中介绍的<strong>设计原则</strong>，也许比介绍的设计模式更加精辟重要，因为感觉所有的设计模式，隐约都存在着共通点，而这些共通点，就是设计原则！</li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>秘籍帖</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>计算机网络协议：语法，语义，时序<ul>
<li>语法：描述实体间信息交换格式</li>
<li>语义：控制信息的具体含义</li>
<li>时序：交换信息的顺序以及速度配合</li>
</ul>
</li>
<li>功能：硬件，软件，信息</li>
<li>分类：覆盖范围，拓扑结构，交换方式，用户属性<ul>
<li>树形，星形拓扑：易于管理，中心节点是网络的关键，线路较多成本较高</li>
<li>环形，总线拓扑：成本效率不高，排错，增删，不便于管理</li>
<li>网状拓扑：节点间通信多路径选择，结构复杂成本高<a id="more"></a>
<h2 id="计算机网络结构"><a href="#计算机网络结构" class="headerlink" title="计算机网络结构"></a>计算机网络结构</h2><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><h3 id="接入网络方式"><a href="#接入网络方式" class="headerlink" title="接入网络方式"></a>接入网络方式</h3></li>
</ul>
</li>
<li>电话拨号</li>
<li>数字线ADSL，使用电话的物理线路，但不同信道传输</li>
<li>混合光纤同轴电缆HFC</li>
<li>局域网</li>
<li>移动接入网络（移动设备）</li>
</ul>
<h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><ul>
<li>网络核心是交换节点和传输介质的集合，实现网络边缘中主机数据的中继与转发。</li>
<li>网络核心（通信子网）不对数据进行处理，不提供网络服务。这些功能由网络边缘（资源子网）提供</li>
</ul>
<h2 id="数据交换技术"><a href="#数据交换技术" class="headerlink" title="数据交换技术"></a>数据交换技术</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul>
<li>主机间建立专用的通信线路，通信结束后通道拆除</li>
<li>实时性高，时延与时延抖动小</li>
<li>突发性数据传输（网页浏览）中，信道利用率低，传输速率单一</li>
</ul>
<h3 id="电报交换"><a href="#电报交换" class="headerlink" title="电报交换"></a>电报交换</h3><ul>
<li>无需建立连接</li>
<li>只有报文被转发（传输数据）时才会占用信道，不会独占信道</li>
<li>以存储-转发形式传送。交换节点需要缓冲储存，报文需要排队，增加时延</li>
</ul>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a><strong>分组交换</strong></h3><ul>
<li>拆分报文为若干分组，在进存储转发</li>
<li>存储设备容量要求低，速率效率高</li>
<li>更加公平，第一个报文为全部传完，可以先开始下一个报文</li>
<li>延迟时间，误码率</li>
</ul>
<h2 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h2><h3 id="带宽（频带宽度）"><a href="#带宽（频带宽度）" class="headerlink" title="带宽（频带宽度）"></a>带宽（频带宽度）</h3><ul>
<li>单位赫兹，频率极差</li>
<li>带宽越大，速率越大，故带宽有时候用来代替速率描述网络性能</li>
</ul>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><ul>
<li>数据从一节点到另一节点所需时间</li>
<li>延迟分类：<ul>
<li><strong>处理时延</strong></li>
<li><strong>排队时延</strong></li>
<li><strong>传输时延，数据传输到线路上所需时间</strong></li>
<li><strong>传播时延，数据在线路上的传播时间</strong></li>
</ul>
</li>
</ul>
<h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>链路上可以容纳的数据位数</p>
<h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><ul>
<li>网络可靠性，反映拥塞程度</li>
<li>丢包率 = 丢失分组数/发送分组数</li>
</ul>
<h3 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h3><p>度量数据传送能力</p>
<h2 id="计算机网络分层体系结构"><a href="#计算机网络分层体系结构" class="headerlink" title="计算机网络分层体系结构"></a>计算机网络分层体系结构</h2><p>各层次封装各自的头部信息后传递下一层次处理</p>
<ul>
<li>OSI参考模型（七层）</li>
<li>TCP/IP参考模型</li>
<li>五层模型：<strong>应用层（报文），传输层（段），网络层（数据报），链路层（帧，若干比特组织的数据处理单元），物理层（比特流）</strong></li>
</ul>
<h1 id="网络应用"><a href="#网络应用" class="headerlink" title="网络应用"></a>网络应用</h1><h2 id="网络应用体系结构"><a href="#网络应用体系结构" class="headerlink" title="网络应用体系结构"></a>网络应用体系结构</h2><ul>
<li>三种类型<ul>
<li><strong>客户端/用户（C/S）结构</strong>，两端角色固定，且用户之间不通信</li>
<li><strong>P2P（Peer To Peer）结构</strong> 客户端与服务端的结合体，客户端与服务端的地位只是在一次通信过程中不变</li>
<li><strong>混合结构</strong> 中心服务器+对等客户端直接通信</li>
</ul>
</li>
<li><strong>网络应用基本原理</strong><ul>
<li>本质都是CS结构</li>
<li>服务器端被动等待请求，客户端主动发起通信请求服务</li>
<li>应用进程遵循应用层协议</li>
</ul>
</li>
</ul>
<h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><p>用IP地址唯一的标识通信双方，但IP不方便记忆使用。使用域名，再由系统解析为IP地址</p>
<ul>
<li>顶级域名命名方法：<br>1 国家域名nTLD； [cn中国 …]<br>2 通用顶级域名gTLD（组织）； [com企业 net网络组织 org非营利性组织 edu教育机构 gov政府 …]<br>3 基础结构域名<br>三级域名一般代表企业内部的主机名，使用时由叶节点级级往上<br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/域名树状结构.png" alt="层次树状结构"></li>
<li>目前存在13个DNS根域名服务器，a.root-server.net为一台根域名服务器域名</li>
<li>大部分根域服务器由多台独立物理服务器构成的服务器集群，而有的是由分布在不同位置的多台镜像服务器</li>
<li>域名服务器<ul>
<li>建立分布式数据库储存域名，根据用户请求将域名映射为IP地址</li>
<li>服务器分类：根域名，顶级域名，权威域名，本地域名服务器</li>
</ul>
</li>
<li>域名解析<ul>
<li>递归查询，服务器代替主机进行查询</li>
<li>迭代查询。服务器返回下一服务器，由主机自行查询<h2 id="万维网应用"><a href="#万维网应用" class="headerlink" title="万维网应用"></a>万维网应用</h2></li>
</ul>
</li>
<li>web服务器，发送超文本，再由浏览器解析</li>
<li>浏览器，网页超链接，包含URL（统一资源定位符），URL包含服务器域名。</li>
<li>TCP连接（保证传输可靠性）</li>
<li>超文本传输协议HTTP（由HTML编写）<ul>
<li>非持久连接 首次建立TCP连接，请求HTML页面，连接断开。解析页面后，需要再向服务器获取若干资源对象。<ul>
<li>串行连接：每次只向服务器请求一个对象，且每次都要重新建立TCP连接。</li>
<li>并行连接：一次向服务器同时发送若干请求，建立若干连接<br>要求对方服务器允许建立三条连接</li>
</ul>
</li>
<li>持久连接<ul>
<li>非流水方式持久连接 建立TCP，请求html，再依次请求资源，直到所有资源请求完毕再释放连接</li>
<li>流水方式持久连接 获取html后，同时发出三个TCP连接。对服务器压力较大</li>
</ul>
</li>
<li>HTTP报文 请求报文 &amp; 响应报文<ul>
<li>典型的请求方法：GET, HEAD, POST, OPTION, PUT等。<br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP报文.png" alt="HTTP报文"><br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/请求报文和响应报文.png" alt="请求报文和响应报文"><br>（状态码的短语是对状态码的简单描述）</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>状态码</th>
</tr>
</thead>
<tbody>
<tr>
<td>1××</td>
<td>信息提示，需进一步交互</td>
</tr>
<tr>
<td>2××</td>
<td>成功</td>
</tr>
<tr>
<td>3××</td>
<td>重定向，资源已转移</td>
</tr>
<tr>
<td>4××</td>
<td>客户端错误</td>
</tr>
<tr>
<td>5××</td>
<td>服务端器错误</td>
</tr>
</tbody>
</table>
<ul>
<li>Cookie 小型文本文件，弥补了http无状态性的不足，有利于对用户进行跟踪或进行针对性服务</li>
</ul>
<ul>
<li>首次访问，服务器给用户编号并设置ID，将带编号的Cookie发送回给用户</li>
<li>用户浏览器保存该Cookie文件，并在下一次访问时一并发送给服务端<br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Cookie.png" alt="Cookie工作原理"></li>
</ul>
<h2 id="Internet电子邮件"><a href="#Internet电子邮件" class="headerlink" title="Internet电子邮件"></a>Internet电子邮件</h2><ul>
<li>电子邮件系统包括邮件服务器，简单邮件传输协议（SMTP），用户代理，邮件读取协议等。</li>
<li>SMTP是Internet电子邮件中核心应用层协议，实现邮件服务器之间或用户代理到邮件服务器的传输，默认端口为25。使用传输层TCP协议进行可靠信息传输</li>
<li><p>应用层交互阶段：握手阶段，邮件传输阶段，关闭阶段</p>
<blockquote>
<p><strong>SMTP协议示例</strong><br>C: telent SMTP.163.com 25  //以telenet方式连接163邮件服务器<br>S: 220 163.com Anti-spam GT for Coremail System  //220为响应数字，其后为欢迎信息<br>C: HELO SMTP.163.com //HELO发出握手请求。除此之外，HELO主要用来查询服务器支持的扩充功能<br>S: 250-mail<br>S: 250-AUTH LOGIN PLAIN<br>S: 250 8BITMIME //最后一个响应数字应答码之后跟的是一个空格，而不是’-‘<br>C: AUTH LOGIN   //请求认证<br>S: 334 dxNlcm5hbWU6  //服务器的响应——经过base64编码了的“Username”=<br>C: Y29zdGFAYW1heGl0Lm5ldA==  //发送经过BASE64编码了的用户名<br>S: 334 UGFzc3dvcmQ6  //经过BASE64编码了的”Password:”=<br>C: MTk4MjIxNA==  //客户端发送的经过BASE64编码了的密码<br>S: 235 auth successfully  //认证成功<br>// 进入邮件传输阶段<br>C: MAIL FROM: <a href="mailto:bripengandre@163.com">bripengandre@163.com</a>  //发送者邮箱<br>S: 250 <a href="mailto:bripengandre@163.com">bripengandre@163.com</a> … Sender ok //“…”代表省略了一些可读信息<br>C: RCPT TO: <a href="mailto:bripengandre@smail.hust.edu.cn">bripengandre@smail.hust.edu.cn</a>　//接收者邮箱<br>S: 250 <a href="mailto:bripengandre@163.com">bripengandre@163.com</a> … Recipient ok<br>C: DATA //请求发送数据<br>S: 354 Enter mail, end with “.” on a line by itself<br>C: Enjoy Protocol Studing   // 邮件内容<br>C: .<br>S: 250 Message sent<br>C: QUIT //退出连接<br>S: 221 Bye    // closing connection</p>
</blockquote>
</li>
<li><p>电子邮件格式：首部，空白行，主体。To, Subject, Cc, From, Date, Reply-To等关键字。</p>
</li>
<li>MIME 多用途互联网邮件扩展。将非AScII转换为ASCII，再利用SMTP进行传输。邮件首部增加MIME，说明主体原本数据类型及编码标准</li>
<li>邮件读取协议<ul>
<li>邮局协议 POP3(将邮件下载到本地操作，不会同步，下载后无需联网后)。<strong>默认端口号110</strong></li>
<li>互联网邮件访问协议 IMAP（直接操作邮件服务器）</li>
<li>HTTP（通过服务器网址访问）</li>
</ul>
</li>
</ul>
<h2 id="FTP文件传输协议"><a href="#FTP文件传输协议" class="headerlink" title="FTP文件传输协议"></a>FTP文件传输协议</h2><p>互联网中实现两主机间文件传输的 <strong>应用层</strong> 协议。利用传输层TCP协议。<br>CS模式。但不同于其他服务，需要采用两种连接。控制连接（<strong>21端口</strong>）传输控制命令，数据连接（<strong>20端口</strong>）传输文件内容<br>适用于传输较大文件。使控制命令更好更快传输</p>
<h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><ul>
<li>充分聚集端系统的计算能力及网络传输带宽，对服务器依赖很小</li>
<li>可以请求对等的端系统进行数据获取。同时也可以请求服务器，各获取一部分数据在组合</li>
</ul>
<h2 id="Socket接口模型"><a href="#Socket接口模型" class="headerlink" title="Socket接口模型"></a>Socket接口模型</h2><p>网络应用进程通信通过API接口请求的底层协议的服务。根据实际使用传输层的TCP或UDP传输。<br>创建相应提供的接口调用不同的传输协议</p>
<ul>
<li>数据报类型Sock_dgram对应UDP服务<ul>
<li>客户端通过临时端口直接向服务器发送数据。服务器通过绑定固定端口号，无需建立连接，直接监听等待客户端数据</li>
</ul>
</li>
<li>流式套接字Sock_stream对应TCP服务<ul>
<li>服务端通过绑定固定的端口号，监听请求。客户端无需绑定端口，通过socket()临时获取端口号</li>
<li>建立TCP连接，开始数据交互</li>
<li>交互结束，客户端关闭接口；服务端关闭连接，最后在关闭端口</li>
</ul>
</li>
<li>原始套接字Sock_raw直接调用网络层的服务，直接构建IP包访问。不再依赖传输层的服务</li>
</ul>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h3 id="传输层基本服务"><a href="#传输层基本服务" class="headerlink" title="传输层基本服务"></a>传输层基本服务</h3><p>核心任务是为应用进程之间提供端到端的逻辑通信服务。<br>网络层实现的是主机到主机的传输服务。传输层端点指的是主机中运行的应用进程。<br>传输层功能：<strong>传输层协议提供逻辑通信服务，只需在端系统中实现</strong>。中间的节点如路由器交换机无需实现传输层功能，提高效率<br>主要功能：</p>
<ul>
<li>传输层寻址<ul>
<li>通过 <strong>端口号</strong> 找到对应应用程序。在全网范围内利用 <strong>IP+端口号</strong> 唯一的标示一个通信端点（应用程序）</li>
<li>传输层端口号为16位二进制。分为三类：</li>
</ul>
<ol>
<li>熟知端口号：1～1023。如http:80</li>
<li>登记端口：1024~49151。为无熟知端口号的程序使用，需要在IANA登记以防重复</li>
<li>客户端口号/短暂端口号：49152～65535。用于临时申请分配按使用。不固定。</li>
</ol>
</li>
<li>应用层报文的分段和寻址</li>
<li>报文的差错检测</li>
<li>进程间端到端的可靠数据传输控制（是否收到）</li>
<li>面向应用层的复用和分解</li>
<li>端到端的流量控制</li>
<li>拥塞控制</li>
</ul>
<ul>
<li>无连接服务UDP：数据交互之前无需对端进行任何信息交换（握手），直接构造传输层报文段并向接收端发送</li>
<li>面向连接的服务TCP：传输前双方交换控制信息，建立逻辑连接，在传输数据，最后拆除连接</li>
</ul>
<h3 id="传输层的复用与分解"><a href="#传输层的复用与分解" class="headerlink" title="传输层的复用与分解"></a>传输层的复用与分解</h3><p>支持众多进程使用通过同一协议进行传输</p>
<ul>
<li>多路复用：从每个应用中获取是数据进行封装发送</li>
<li>多路分解：从数据中通过端口号分各个应用</li>
</ul>
<h4 id="无连接的多路复用与多路分解"><a href="#无连接的多路复用与多路分解" class="headerlink" title="无连接的多路复用与多路分解"></a>无连接的多路复用与多路分解</h4><ul>
<li>UDP套接字：&lt;目的IP, 目的端口号&gt;</li>
<li>端口号是UDP实现多路复用的重要依据</li>
</ul>
<h4 id="面向连接的多路复用与多路分解"><a href="#面向连接的多路复用与多路分解" class="headerlink" title="面向连接的多路复用与多路分解"></a>面向连接的多路复用与多路分解</h4><ul>
<li>TCP套接字标示一条TCP连接：&lt;源IP, 源端口，目的IP, 目的端口号&gt;</li>
<li>一段TCP报文到达主机时，根据此将报文分解到相应套接字（同一连接）</li>
</ul>
<h3 id="停-等协议与滑动窗口协议"><a href="#停-等协议与滑动窗口协议" class="headerlink" title="停-等协议与滑动窗口协议"></a>停-等协议与滑动窗口协议</h3><h4 id="实现可靠传输的措施："><a href="#实现可靠传输的措施：" class="headerlink" title="实现可靠传输的措施："></a>实现可靠传输的措施：</h4><ol>
<li>差错检测：利用差错编码实现数据包检测</li>
<li>确认：向发送方反馈接受状态</li>
<li>重传</li>
<li>序号：确保数据按序提交</li>
<li>计时器：解决数据丢失问题</li>
</ol>
<h4 id="停等协议"><a href="#停等协议" class="headerlink" title="停等协议"></a>停等协议</h4><p>每发送一个报文后就停下等待接收方确认</p>
<ul>
<li>发送经过差错编码与编号的报文段</li>
<li>确认接收则发送ACK，否则丢弃报文发送NCK</li>
<li>根据反馈状态选择重发或者继续</li>
</ul>
<h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><p>性能问题：停等机制降低信道利用率。<br>解决方案：流水线协议/管道协议：允许发送方在未收到确认前不断发送多个(后续)分组。<br>继续改进：增加分组序号范围；发，收方必须可以缓存多个分组（对未收到确认的数据进行缓存）<br>两种有代表性的滑动窗口协议：</p>
<ul>
<li>回退N步协议（Go-Back-N, GBN）：接收窗口大小为1，只接收1个按按序到达的分组。出错分组以后的全部丢弃重传</li>
<li>选择重传协议（Selective RePeat, SR）：接收窗口&gt;1，缓存正确但失序的分组</li>
</ul>
<h3 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 UDP"></a>用户数据报协议 UDP</h3><p>UDP数据报结构</p>
<ul>
<li>源和目的端口号：用于UDP复用分解</li>
<li>长度字段：UDP报文段中的字节数</li>
<li>校验和：接收方检测报文段是否出错<br>校验和计算<ol>
<li>对所有参加运算的内容按16位对齐求和</li>
<li>求和过程中遇到溢出（进位）都会被回卷（进位与和的最低位再加）</li>
<li>得到的和取反码</li>
</ol>
</li>
</ul>
<h3 id="传输控制协议-TCP"><a href="#传输控制协议-TCP" class="headerlink" title="传输控制协议 TCP"></a>传输控制协议 TCP</h3><p>TCP报文首部结构</p>
<ul>
<li>源与目的端口号</li>
<li>序号 标示该报文在整个分组中的序号</li>
<li>确认号 反馈某分组发送状态</li>
<li>数据偏移 同序号的报文再拆分后的数据位置</li>
<li>URG，标示紧急指针位是否有效</li>
<li><strong>ACK</strong> 确认位，标示确认号是否有效</li>
<li>PSH 通知可以很快对数据进行提交</li>
<li>RST 复位，出现错误，需要重置连接</li>
<li><strong>SYN</strong> 同步请求，协商序号等信息</li>
<li>FIN 通知拆除连接</li>
<li>窗口 流量控制，窗口大小可有双方控制</li>
<li>校验和<br>// 以上为 <strong>TCP的固定首部，20字节</strong></li>
<li>选项</li>
<li>填充 首部大小需为4字节的倍数<br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP报文结构.jpg" alt="TCP报文结构"></li>
</ul>
<h4 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h4><p>TCP传输机制包括差错编码，确认，序号，重传，计时器（实现重传）等<br>TCP的可靠数据传输基于滑动窗口协议，发送窗口动态变化（流量控制）</p>
<h5 id="连接建立-三次握手"><a href="#连接建立-三次握手" class="headerlink" title="连接建立-三次握手"></a>连接建立-三次握手</h5><ol>
<li><strong>SYN连接请求</strong> syn = 1, seq = x(同步请求，且初始序号为x)【客户端状态为SYN-SENT】</li>
<li><strong>SYNACK确认</strong> syn = 1, ACK = 1, seq = y, ack = x+1（x已收到请求x+1，告知服务端初始序号）【服务端状态SYN-RVD】</li>
<li><strong>ACK确认</strong> ACK = 1, seq = x+1, ack = y+1<br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP三次握手.png" alt="TCP三次握手"><h5 id="TCP断开-四次挥手"><a href="#TCP断开-四次挥手" class="headerlink" title="TCP断开-四次挥手"></a>TCP断开-四次挥手</h5></li>
<li><strong>任意一方发起断开请求</strong> FIN = 1, seq = u</li>
<li><strong>返回确认</strong> ACK = 1, seq = v, ack = u+1。请求方停止发送数据。另一方继续发送数据。</li>
<li><strong>发送请求释放连接</strong> FIN = 1, ACK = 1, seq = w, ack = u+1</li>
<li><strong>接收方返回确认</strong> ACK = 1, seq = u+1, ack = w+1。接收端接收到以后关闭连接，发送端进入TIME-WAIT阶段，一段时间后关闭连接</li>
</ol>
<ul>
<li><strong>封装TCP报文段</strong></li>
<li><strong>发出一个报文段后启动一个计时器</strong></li>
<li><strong>校验和发现数据差错</strong></li>
<li><strong>重排序，丢弃重复</strong></li>
<li><strong>流量控制</strong></li>
</ul>
<h5 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h5><ul>
<li>TCP利用窗口机制实现流量控制，但不是简单的滑动窗口协议（窗口动态变换）</li>
<li>TCP连接建立时双方分配固定大小的缓冲空间，发送数据必须在缓冲区接纳的大小<ul>
<li>接收端给发送方发送确认时通知接收窗口大小</li>
<li>发送端发送数据时，保证未确认段应用层数据不超过接收端窗口大小，使对方窗口不会产生溢出</li>
</ul>
</li>
</ul>
<h5 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h5><ul>
<li>窗口机制 通过调节窗口大小实现发送速率调节</li>
<li>窗口调节基本策略 AIMD<ul>
<li>加性增加 网络未拥堵，逐渐增加</li>
<li>乘性减小 网络拥堵，逐渐减小</li>
</ul>
</li>
<li>TCP拥塞控制算法<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>快速重传</li>
<li>快速恢复</li>
</ul>
</li>
</ul>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>传输层主要保证数据传输的可靠性，网络层负责数据的转发和发送<br>网络层的主要作用是将网络数据报从源主机发送到目标主机<br>主要功能：</p>
<ul>
<li><strong>分组转发</strong>：分组从传输接口转移到输出接口  </li>
<li><strong>路由选择</strong>：决定分组经过的路由或路径<h2 id="路由器内部结构"><a href="#路由器内部结构" class="headerlink" title="路由器内部结构"></a>路由器内部结构</h2></li>
<li>路由选择处理机：路由选择协议 -&gt;路由表（记录下一跳的路由器）</li>
<li>输入端口进来的数据通过 <strong>转发表</strong> 记录的输出端口</li>
<li>通过路由表记录成转发表</li>
</ul>
<h2 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h2><p>按照目的主机的地址进行路由选择的网络（本质上不可靠，但效率与成本好。互联网依赖此技术建立）</p>
<ul>
<li>无连接</li>
<li>每个分组作为独立的数据报进行选路传输，路径可能不同</li>
<li>分组可能出现乱序与丢失</li>
</ul>
<h2 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h2><p>在网络层提供的面向连接的分组交换服务<br>互联网的数据报方式不可靠，所以需要在此之上建立面向连接的传输层来确保传输可靠性。</p>
<ul>
<li>建立一条网络层的逻辑连接</li>
<li>不需要为每条虚电路分配独享资源（区别与电路交换，信道利用率较高）</li>
<li>沿虚电路路径按序发送分组<br>异步传输模式的网络即采用此网络，成本较高但是传输较可靠</li>
</ul>
<h2 id="网络互连"><a href="#网络互连" class="headerlink" title="网络互连"></a>网络互连</h2><h3 id="异构网络互连"><a href="#异构网络互连" class="headerlink" title="异构网络互连"></a>异构网络互连</h3><p>两个网络使用的技术与协议不同</p>
<ul>
<li>协议转换</li>
<li>构建虚拟互联网络 使用IP协议作为这些网络技术和协议的下层协议，使用IP协议进行传输。在IP层次构建了虚拟网络<h3 id="网络设备–路由器"><a href="#网络设备–路由器" class="headerlink" title="网络设备–路由器"></a>网络设备–路由器</h3></li>
<li>输入输出端口 不同的网络技术有不同的端口<br>// 输入端口<ol>
<li>线路接收分组</li>
<li>物理层处理（处理不同网络技术）</li>
<li>数据链路层处理（提取其中网络层的IP数据）</li>
<li>网络层处理分组排队（查表转发输出，通过交换结构进入输出端口）<br>// 输出端口</li>
<li>网络层排队，缓存管理，每次取出一个数据</li>
<li>数据链路层处理（处理为不同技术）</li>
<li>物理层处理，发送到线路</li>
</ol>
</li>
<li>交换结构设计<ul>
<li>基于内存交换</li>
<li>基于总线交换</li>
<li>基于网络交换（节点开关）<br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/路由器交换结构.png" alt="路由器交换结构"></li>
</ul>
</li>
<li>路由处理器<br>执行路由器各种指令，包括路由协议运行，路由计算，路由表的更新维护等</li>
</ul>
<h2 id="网络层拥塞控制"><a href="#网络层拥塞控制" class="headerlink" title="网络层拥塞控制"></a>网络层拥塞控制</h2><h3 id="拥塞：持续过载的网络状态，用户对网络资源的需求（链路带宽，存储空间，处理能力）总需求超过固有容量"><a href="#拥塞：持续过载的网络状态，用户对网络资源的需求（链路带宽，存储空间，处理能力）总需求超过固有容量" class="headerlink" title="拥塞：持续过载的网络状态，用户对网络资源的需求（链路带宽，存储空间，处理能力）总需求超过固有容量"></a>拥塞：持续过载的网络状态，用户对网络资源的需求（链路带宽，存储空间，处理能力）总需求超过固有容量</h3><ul>
<li>缓冲区容量有限</li>
<li>带宽有限</li>
<li>结点处理能力有限</li>
<li>发生故障  <h3 id="流量感知路由"><a href="#流量感知路由" class="headerlink" title="流量感知路由"></a>流量感知路由</h3>根据负载状态动态调整，将网络流量引导到不同链路上，均衡负载，从而延缓或避免拥塞发生<br>解决网络负载的震荡现象</li>
<li>多路径路由</li>
<li>缓慢转移流量至另一链路<h3 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h3>主要应用于虚电路网络。对新建虚电路进行审核，若该电路会导致拥塞则拒绝建立。<br>拥塞状态的量化：基于平均流量与瞬时流量<h3 id="流量调节"><a href="#流量调节" class="headerlink" title="流量调节"></a>流量调节</h3></li>
</ul>
<ol>
<li>感知拥塞</li>
<li>处理拥塞：将拥塞信息通知到其上游结点<br>处理方法：<ul>
<li>抑制分组：给拥塞数据报源主机返回一个抑制分组（减少发送）</li>
<li>背压：让抑制分组从拥塞结点到源结点的路径上的每一跳都发挥抑制作用<h3 id="负载脱落"><a href="#负载脱落" class="headerlink" title="负载脱落"></a>负载脱落</h3>主动丢弃某些数据报</li>
</ul>
</li>
</ol>
<ul>
<li>丢弃新分组：如GBN</li>
<li>丢弃老分组：如实时视频流</li>
</ul>
<h2 id="Internet网络层"><a href="#Internet网络层" class="headerlink" title="Internet网络层"></a>Internet网络层</h2><h3 id="IPv4协议"><a href="#IPv4协议" class="headerlink" title="IPv4协议"></a>IPv4协议</h3><h4 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h4><ul>
<li>IP首部分装了来自传输层的数据</li>
<li>IP首部固定部分20字节</li>
<li>版本：IPv4/IPv6</li>
<li>首部长度 固定+可变</li>
<li>区分服务 区分不同服务质量</li>
<li>总长度 IP包总长度</li>
<li>标示 识别IP包。判断分片是否属于同一字段</li>
<li>标志 识别IP包是否被分割。判断是否为最后分片</li>
<li>片偏移 判断分片先后顺序</li>
<li>生存时间 多次转发仍未抵达目的地，生存时间过长丢弃</li>
<li>协议 标示数据部分使用的协议</li>
<li>检验和 差错</li>
<li>源，目的地址 发送与接收 数据的主机的IP地址。<strong>分别占4字节</strong>  </li>
</ul>
<p><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP数据报格式.png" alt="IP数据报格式"></p>
<h4 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h4><h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p>32位的二进制 点分十进制标记法 8位一组点分标<br><strong>网络号</strong>（同一网络下的主机具有相同的网络号） + <strong>主机号</strong><br>分类地址：A, B, C, D, E<br>特殊地址，私有地址<br>ABC：实际分配给联网的主机，没有重复的唯一地址<br>D：组播/多播地址。高四位为1110<br>E：保留使用。高四位为1111<br>A：前8位为网络号。最高位为0   0~127 主机数量：2^24-2<br>B：前16位为网络号。高二位为10   主机数量：2^16-2<br>C：前24位为网络号。高三位为110    主机数量：2^8-2<br><strong>ABC网络规模不同</strong></p>
<h5 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h5><p>将一个子网划分为多个子网<br>大子网具有较短网络前缀。小子具有稍长前缀  </p>
<ul>
<li>超网：子网合并为大网  </li>
<li>子网掩码：定义调节一个子网的网络前缀长度，用于划分子网。前部全为1，即为网络前缀，后部全为0</li>
</ul>
<ul>
<li><strong>IP ^ Mask = Subnet    IP地址与子网掩码进行与运算得到子网地址</strong>  </li>
<li><strong>同一子网中，网络前缀部分相同，后面为主机号不同，最小主机号代表子网地址，最大主机号代表直接广播地址</strong>  </li>
<li>后8为的前缀部分即为子网号，可作为连续标示</li>
<li>除去子网地址与广播地址，剩余即为可分配的主机数</li>
<li>子网掩码延长r位该子网划分为2^r 个子网<br><img src="/2019/01/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/子网划分.png" alt="子网划分"></li>
</ul>
<h5 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h5><p>将相同路由的连续子网合并<br>路由表中的分组转发：查找转发表（与运算匹配），最长前缀优先匹配<br>IP地址与分组表子网掩码坐与运算，所得是否匹配，再根据最长前缀进行选择</p>
<h4 id="动态主机配置协议"><a href="#动态主机配置协议" class="headerlink" title="动态主机配置协议"></a>动态主机配置协议</h4><p><strong>略</strong></p>
<h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><p>网络地址转换 NAT协议 –使用私有地址访问互联网<br>大量地址在互联网上不分配不使用只在内部使用，但保留地址在互联网上无法使用  </p>
<ul>
<li>源IP地址由Nat路由器替换为Nat拥有的合法使用的公共IP地址，同时替换端口号，并将替换关系记录到Nat转换表中</li>
<li>从互联网返回的IP数据报，依据其目的地址与目的端口号检索Nat转换表，获取内部ip与端口<br>同时起到隐藏实际IP地址，只公开公共地址的效果</li>
</ul>
<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><hr>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><p>传输层负责应用层的复用分用保证可靠传输，网络层负责将数据从主机传到主机<br>链路层负责把一个节点可靠的传输到另一个节点，为网络层提供服务  </p>
<h2 id="数据链路服务"><a href="#数据链路服务" class="headerlink" title="数据链路服务"></a>数据链路服务</h2><p>负责直接相邻节点的传输<br>链路层数据单元：帧<br>网络层将数据报封装交给链路层，链路层将数据添加帧头帧尾，构造数据帧  </p>
<ul>
<li>组帧</li>
<li>链路接入：点对点链路，广播链路（一条链路上有多个节点）</li>
<li>可靠交付（用于高出错链路）</li>
<li>差错控制</li>
</ul>
<h2 id="多路访问控制协议"><a href="#多路访问控制协议" class="headerlink" title="多路访问控制协议"></a>多路访问控制协议</h2><h3 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h3><p>纯ALOHA协议（Pure ALOHA）：直接发送 -&gt;信道侦听（反馈确认） -&gt;冲突重发<br>时隙ALOHA协议（Sloated ALOHA）：发送时间分为时隙，时隙开始时发送 -&gt;信道侦听 -&gt;冲突则下一时隙以概率P重发</p>
<h3 id="载波监听多路访问协议CSMA"><a href="#载波监听多路访问协议CSMA" class="headerlink" title="载波监听多路访问协议CSMA"></a>载波监听多路访问协议CSMA</h3><p>发送前监听信道是否空闲</p>
<ol>
<li>非坚持CSMA：忙则等待随机时间发送后在侦听</li>
<li>1-坚持CSMA：忙则持续侦听直到信道空闲</li>
<li>P-坚持CSMA：闲则概率P在最近时隙发送（避免同时侦听冲突）<h3 id="带冲突检测的载波监听多路访问CSMA-CD"><a href="#带冲突检测的载波监听多路访问CSMA-CD" class="headerlink" title="带冲突检测的载波监听多路访问CSMA/CD"></a>带冲突检测的载波监听多路访问CSMA/CD</h3>监听空闲后发送，发送时检测碰撞，碰撞后等待重发</li>
</ol>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="链路层寻址与ARP"><a href="#链路层寻址与ARP" class="headerlink" title="链路层寻址与ARP"></a>链路层寻址与ARP</h3><p>局域网广播通信，使用Mac地址进行标示通信。</p>
<h4 id="MAC地址-硬件地址"><a href="#MAC地址-硬件地址" class="headerlink" title="MAC地址/硬件地址"></a>MAC地址/硬件地址</h4><p>每个接口对应一个MAC地址，全球唯一。<br>路由器接口，网卡接口，交换机接口<br>长度48位，十六进制， 前24为厂商标示， 厂商分配代码</p>
<h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><p>根据本网内目的主机或默认网关的IP地址获取其MAC地址<br>查询/响应方式<br>所以ARP只为在同一只子网下的主机和路由器解析IP</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>秘籍帖</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin之协程-扔物线笔记</title>
    <url>/2021/04/06/Kotlin%E5%8D%8F%E7%A8%8B-%E6%89%94%E7%89%A9%E7%BA%BF%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>通过<a href="https://kaixue.io/kotlin-coroutines-1/">扔物线对于Kotlin协程的讲解介绍</a>，对协程有了更加清晰的认识</p>
</blockquote>
<h1 id="简单定义"><a href="#简单定义" class="headerlink" title="简单定义"></a>简单定义</h1><p>一个封装了线程的上层线程API，用于线程切换，后台执行耗时任务</p>
<a id="more"></a>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p><code>协程Scope.launch &#123;&#125;</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch &#123;</span><br><span class="line">	<span class="keyword">val</span> imgae = getImageFromIO(imageId)</span><br><span class="line">	imageView.setImageBitmap(image)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// launch方法需要使用某个Scope（作用域）调用，或者在runBloking &#123;&#125;中调用</span></span><br><span class="line"><span class="comment">// launch方法可以携带，指定目标线程；不携带参数时默认在本线程执行</span></span><br></pre></td></tr></table></figure></p>
<h1 id="概念及优势"><a href="#概念及优势" class="headerlink" title="概念及优势"></a>概念及优势</h1><p>一个类似Java的Executor，Android的AsycTask的线程框架。<br><strong>区别在于，利用Kotlin的语言优势，可以更方便实现线程切换，以及<code>写出看似阻塞（同步）的非阻塞（异步）代码</code></strong>，即Kotlin的<code>非阻塞式挂起</code>。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">val</span> imgae = getImageFromIO(imageId)</span><br><span class="line">    imageView.setImageBitmap(image)</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line">协程可以实现在一个代码块中编写不同线程的代码，即getImageFromIO()方法，可以切到后台进行耗时操作，然后切回UI线程进行界面操作。而如果是在Java中，这部分代码一般会使用回调实现，然后在耗时任务完成的回调中进行界面操作。相比之下，协程的代码逻辑就看似顺序，同步了起来。</span><br><span class="line">&gt; 通过消除回调，抹平了多线程开发的难度，甚至打破回调对开发能力的限制</span><br><span class="line">&gt; 如当有这样的需求：通过网络获取两个没有相关性的接口信息内容，本地进行合并后显示。</span><br><span class="line">&gt; 理论上没有相关性的接口，应该使用并行请求，然后本地作融合，然而如果是回调式实现，就会是先发第一个请求，回调中进行第二个请求，然后再在回调中合并显示，时间上看就是双倍的请求时间，即降低了一倍的性能。</span><br><span class="line">&gt; 但在kotlin可以这样实现。</span><br><span class="line">``` kotlin</span><br><span class="line">launch(Dispatchers.Main) &#123;</span><br><span class="line">	<span class="keyword">val</span> info1 = async &#123; api.getInfo1() &#125;</span><br><span class="line">	<span class="keyword">val</span> info2 = async &#123; api.getInfo2() &#125;</span><br><span class="line">	<span class="keyword">val</span> info = merge(info1.await(), info2.await())</span><br><span class="line">	show(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>使用async也可以创建一个协程，并且与launch相同，可以返回一个Coroutine对象。区别在于，async返回的Coroutine对象还实现了Deferred接口，使得可以通过调用Deferred.await()方法可以获得async任务结束后返回的结果</code><br>因此，使用协程最重要的目的是，实现在一个代码块中进行多次的线程切换，为了<strong>改变并发任务的操作难度</strong>，降低复杂并发任务的实现难度甚至实现Java中难以实现的任务</p>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>使用<code>launch</code>包含一个代码块，实现创建一个协程并且指定一个线程执行。所谓协程就是代码块内容，所以可以理解为一个任务。</p>
<p>withContext也可以实现线程切换执行任务，任务执行完成后切回原线程的功能。<code>自动切回原线程</code>的能力，大大减少了代码的嵌套，同时便于功能的封装。</p>
<p>withContext()作为一个suspend函数，需要在协程中使用或在另一个suspend函数中使用。给函数加上suspend修饰，函数即为suspend函数，标识该方法执行一个耗时任务，建议（要求）在协程中执行。</p>
<p>suspend即为暂停，挂起，即代码执行suspend会进行挂起操作，并且是非阻塞式挂起。该操作其实是进行了一个线程切换的工作，因此非阻塞式是相对于原线程来说，没有受到阻塞。</p>
<p>我理解的withContext和launch的区别在于，launch可以创建一个协程，并且指定线程执行；withContext方法是一个suspend方法，只能在协程中调用，用于线程的切换并且执行完毕后会切回原线程。</p>
<h1 id="协程的挂起"><a href="#协程的挂起" class="headerlink" title="协程的挂起"></a>协程的挂起</h1><p>launch创建的协程，执行到suspend方法时，会进行挂起操作。<br>所谓挂起，是将当前协程从线程上挂起，脱离原线程执行，即进行了线程切换操作。协程挂起后，不再在原线程执行，原线程的代码块（launch代码块）返回（return，类似提前结束）。挂起的协程，在执行的线程继续执行， 结束了suspend函数的内容以后，协程切回原线程（<strong>resume</strong>），执行剩余代码。<br>与handler.post机制类似，launch相当于往handler post了一个任务A执行，执行到suspend函数时，任务A提前结束返回（挂起），handler执行其他任务，suspend函数的内容在指定函数执行，工作内容结束以后，任务A剩余的工作再次被post到handler中执行（resume）。<br>所以所谓<code>挂起</code>，即可以理解为，<strong>一个暂时切走，然后会再切回来的线程切换</strong>。</p>
<p>因此，因为协程有了resume恢复功能，会自动把挂起的线程切回来，所以suspend函数必须在协程中使用，保证协程被切走后，能被切回来。</p>
<h1 id="如何挂起"><a href="#如何挂起" class="headerlink" title="如何挂起"></a>如何挂起</h1><p>定义一个suspend函数并且在其中使用withContext()函数（协程自带的，具备协程挂起功能的函数），线程切换发生在withContext中。<br>因此单纯的定义suspend并不能实现协程挂起，suspend只是一个函数定义者对该函数工作的标识，表示该函数是一个耗时函数，必须在协程中调用。<br>仅是对一个函数标识suspend却没有在其中使用挂起函数，只能实现限制该函数在协程中使用但并没有线程切换的能力。<br><strong>本质上是一个要求，实际上是一个提醒</strong>，尝试实现使所有的耗时操作都在后台执行的机制，降低主线程的卡顿。<br>综上，当一个函数中会进行耗时或者等待操作，则需要对其标识suspend，并且在其中进行挂起操作</p>
<h1 id="关于launch"><a href="#关于launch" class="headerlink" title="关于launch"></a>关于launch</h1><p>launch用于创建一个协程并返回一个Job对象，Job对象即可视为一个协程。其余创建协程的方法有launch，async，runBlocking等。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android</span></span><br><span class="line">Log.e(tag, <span class="string">&quot;0:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>    <span class="subst">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class="line">lifecycleScope.launch &#123;</span><br><span class="line">	Log.e(tag, <span class="string">&quot;1:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>    <span class="subst">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">    	Log.e(tag, <span class="string">&quot;2:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>    <span class="subst">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">3000</span>)</span><br><span class="line">    Log.e(tag, <span class="string">&quot;3:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>    <span class="subst">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">Log.e(tag, <span class="string">&quot;5:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>    <span class="subst">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MacOS Windows</span></span><br><span class="line">runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;0:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>    <span class="subst">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;1:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>    <span class="subst">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        withContext(Dispatchers.IO) &#123;</span><br><span class="line">            println(<span class="string">&quot;2:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>    <span class="subst">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        delay(<span class="number">3000</span>)</span><br><span class="line">        println(<span class="string">&quot;3:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>    <span class="subst">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;5:<span class="subst">$&#123;Thread.currentThread().name&#125;</span>    <span class="subst">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用以上代码进行测试，分别基于MacOS的kotlin环境，Windows10的Kotlin环境，以及Android系统环境进行测试，得到了不同的结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ---- Android ----</span><br><span class="line">&#x2F;&#x2F; 0:main    1</span><br><span class="line">&#x2F;&#x2F; 1:main    1</span><br><span class="line">&#x2F;&#x2F; 5:main    1</span><br><span class="line">&#x2F;&#x2F; 2:DefaultDispatcher-worker-1    14868</span><br><span class="line">&#x2F;&#x2F; 3:main    1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ---- Mac0S ----</span><br><span class="line">&#x2F;&#x2F; 0:main @coroutine#1    1</span><br><span class="line">&#x2F;&#x2F; 5:main @coroutine#1    1</span><br><span class="line">&#x2F;&#x2F; 1:DefaultDispatcher-worker-1 @coroutine#2    11</span><br><span class="line">&#x2F;&#x2F; 2:DefaultDispatcher-worker-2 @coroutine#2    12</span><br><span class="line">&#x2F;&#x2F; 3:DefaultDispatcher-worker-2 @coroutine#2    12</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 0:main @coroutine#1    1</span><br><span class="line">&#x2F;&#x2F; 5:main @coroutine#1    1</span><br><span class="line">&#x2F;&#x2F; 1:DefaultDispatcher-worker-1 @coroutine#2    11</span><br><span class="line">&#x2F;&#x2F; 2:DefaultDispatcher-worker-2 @coroutine#2    12</span><br><span class="line">&#x2F;&#x2F; 3:DefaultDispatcher-worker-2 @coroutine#2    11</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ---- Windows ----</span><br><span class="line">&#x2F;&#x2F; 0:main     1</span><br><span class="line">&#x2F;&#x2F; 5:main     1</span><br><span class="line">&#x2F;&#x2F; 1:DefaultDispatcher-worker-1 @coroutine#2    14</span><br><span class="line">&#x2F;&#x2F; 2:DefaultDispatcher-worker-2 @coroutine#2    14</span><br><span class="line">&#x2F;&#x2F; 3:DefaultDispatcher-worker-2 @coroutine#3    15</span><br></pre></td></tr></table></figure><br>可以看到，只有在Android平台下的表现才是符合上述的理论的，即<code>launch</code>没有进行线程切换，只有在<code>withContext()</code>中才进行线程切换。然而其他平台都是进入协程代码块（launch）即进入了新的线程。<br>起初我还以为，是<del>因为不同操作系统的线程调度机制差异，因此协程作为线程调度的上层API也产生了差异</del>。实际上不是这样。<br>网上有文章说<code>GlobalScope</code>启动的协程都是独立的，生命周期只受到Application影响。因此使用<code>GlobalScope.launch</code>创建的协程也会在一个独立的线程执行。<br>使用coroutineScope { }可以为其中的协程添加作用域，而该协程任务不会在后台线程中执行。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>秘籍贴</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Jetpack初识</title>
    <url>/2021/03/24/Android-Jetpack%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Navgation"><a href="#Navgation" class="headerlink" title="Navgation"></a>Navgation</h1><h2 id="Navigation基本使用"><a href="#Navigation基本使用" class="headerlink" title="Navigation基本使用"></a>Navigation基本使用</h2><ul>
<li>创建navgation文件夹，编写xml</li>
<li>引用navgation的fragment需指定xml文件，已经通过<code>name</code>指定一个NavHostFragment或其派生类，是一个空的Fragment容器</li>
<li>指定fragment以及相应action（通过Desgin拖动视图级箭头设置）</li>
</ul>
<a id="more"></a>
<h2 id="NavigationUI"><a href="#NavigationUI" class="headerlink" title="NavigationUI"></a>NavigationUI</h2><ul>
<li>设置点击返回键Back时的回退路径destination<ul>
<li><code>popUpToInclusive=true</code>时，返回栈帧删除fragment，连同制定fragment</li>
<li><code>popUpToInclusive=false</code>时，返回栈帧删除fragment，留下指定fragment </li>
</ul>
</li>
<li>若指定的destination是最初的fragment，且popUpToInclusive=true，则所有栈帧移除，返回键会推出该app</li>
<li>NavigationUI 设置菜单栏，返回键，抽屉等<ul>
<li>菜单栏是通过id指定navigation.xml中的fragment，注意对应</li>
</ul>
</li>
</ul>
<h2 id="NavDirection"><a href="#NavDirection" class="headerlink" title="NavDirection"></a>NavDirection</h2><ul>
<li>使用NavDirection实现fragment与activity之间的数据传输，代替Bundle。目的减少键值对使用出现的问题如key错误，类型不匹配等</li>
<li>需要安装gradle插件，因为编译期间需要创建Direction对象以携带数据<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// project gradle下添加</span></span><br><span class="line">classpath <span class="string">&quot;androidx.navigation:navigation-safe-args-gradle-plugin:$navigationVersion&quot;</span></span><br><span class="line"><span class="comment">// module gradle下添加</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;androidx.navigation.safeargs&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>调用Direction的静态方法实现跳转的action，携带的数据以Direction内部属性的形式传递</li>
<li>接收数据一端，通过Args对象，fromBundle(getArguments())获取Bundle并转换为对应的Args对象，其中保存着传输的数据</li>
</ul>
<h1 id="LifeCycle"><a href="#LifeCycle" class="headerlink" title="LifeCycle"></a>LifeCycle</h1><p>用于感知Activity与Fragment生命周期的组件。</p>
<h1 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h1><p><a href="https://developer.android.com/codelabs/kotlin-android-training-view-model?index=..%2F..android-kotlin-fundamentals#4">原文参考</a></p>
<blockquote>
<p>UI controller is a UI-based class such as Activity or Fragment. A UI controller should only contain logic that handles UI and operating-system interactions such as displaying views and capturing user input. Don’t put decision-making logic, such as logic that determines the text to display, into the UI controller.<br>UI控制不应该包含决策逻辑，只负责界面的显示绘制，以及感知界面变化，如有按钮被点击时将这一信息传递到ViewModel</p>
</blockquote>
<ul>
<li>ViewModel会在Activity被finish或Fragment被destroyed后调用onCleared()销毁<blockquote>
<p>During configuration changes such as screen rotations, UI controllers such as fragments are re-created. However, ViewModel instances survive. If you create the ViewModel instance using the ViewModel class, a new object is created every time the fragment is re-created. Instead, create the ViewModel instance using a ViewModelProvider.</p>
</blockquote>
</li>
<li>直接使用ViewModel创建实例，则UI控制器因为配置修改（经典旋转屏幕）而重新创建时，ViewModel会创建新的实例。所以使用ViewModelProvider创建ViewModel实例，ViewModel不会被重复创建，并且可以存储数据</li>
<li>ViewModelProvider创建ViewModel且关联一个给定作用域，如activity或fragment。并且保留数据直到作用域被销毁</li>
<li>在绑定变量（databinding）的定义之后使用ViewModelProvider获取ViewModel，并且传递关联的上下文及具体的ViewModel.class<blockquote>
<p>Because the app’s activities, fragments and views do not survive configuration changes, the ViewModel should not contain references to the app’s activities, fragments, or views.</p>
</blockquote>
</li>
<li>ViewModel不应该保存fragment，view等的引用。因为ViewModel在配置变化后存活，但frament和view不会存活（re-Create）</li>
<li>绑定变量以及Binding对象不应该存储到ViewModel中，因为他们包含了对view的引用。所有决定数据显示逻辑的代码应该在ViewModel中编写</li>
<li>AndroidViewModel。类似ViewModel的基类，区别在于携带一个Application参数</li>
</ul>
<p>最简单直白的使用，其实就是将控制逻辑和数据使用ViewModel包装起来，并且在View中使用ViewModelProvider加载，以实现View重建时，ViewModel不会重新加载而将保存的数据重复使用</p>
<h2 id="ViewModelFactory"><a href="#ViewModelFactory" class="headerlink" title="ViewModelFactory"></a>ViewModelFactory</h2><p>使用Factory的意义在于，单纯的使用ViewModelProvider创建ViewModel，无法向ViewModel传递参数，只能实例化没有参数的ViewModel<br>使用Factory，可以实现实例化ViewModel时传递多个参数</p>
<h1 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h1><ul>
<li>使用MutableLiveData代替数据类型，通过泛型设置数据的真正类型，数据真正的值通过liveData.value访问</li>
<li>LiveData的实现是基于观察者模式，因此需要在view中设置观察事件。在viewModel初始化以后，调用MutableLiveData.observe方法，设置回调事件。并且首先需要传入一个viewLifecycleOwner<br><strong>Why use viewLifecycleOwner?</strong></li>
<li>在回调方法中将回调参数进行使用，则当viewModel中的liveData发生变化时，回调函数执行<h2 id="LiveData封装"><a href="#LiveData封装" class="headerlink" title="LiveData封装"></a>LiveData封装</h2>由于在View中可以直接访问到ViewModel的内容，直接修改LiveData，所以需要通过封装以及kotlin的幕后属性（Backing Property）实现LiveData的读写限制<br><strong>尝试不使用ViewModel，只使用LiveData，理论上互不影响</strong></li>
</ul>
<h1 id="kotlin-Backing-property"><a href="#kotlin-Backing-property" class="headerlink" title="kotlin-Backing property"></a>kotlin-Backing property</h1><p>Kotlin的幕后属性，用于实现<strong>属性对外表现可读，对内表现可写可读</strong>。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _name = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> name : String</span><br><span class="line">	<span class="keyword">get</span>() = _name</span><br></pre></td></tr></table></figure><br>类内部使用<code>_name</code>进行读写，对外由于没有设置set()写访问器，只能访问<code>name</code></p>
<p>顺便说说kotlin的幕后字段<code>field</code>。在kotlin中，使用属性都是通过访问器，所以在get()中使用该属性，实际上也是调用get()，即出现递归，最后堆栈溢出，setter同理。<br>所以在getter，setter中，使用<code>field</code>表示该属性，且field也只能用于getter，setter。</p>
<h1 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fragmen中加载layout</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">		<span class="keyword">val</span> binding = DataBindingUtil.inflate&lt;FragmentTitleBinding&gt;(inflater, R.layout.fragment_title, container, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">return</span> binding.root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DataBinding-LiveData"><a href="#DataBinding-LiveData" class="headerlink" title="DataBinding+LiveData"></a>DataBinding+LiveData</h2><p>没有DataBinding的情况下，ViewModel与View直接没有直接的联系，其间通过UIController连接，如一个按钮被点击，UIController调用一个点击事件，通知ViewModel做出响应，然后更新<br>使用DataBinding，View与ViewModel直接通信，指的是在xml中直接与ViewModel通信，而不通过UIController，即直接在xml中编写逻辑。</p>
<ul>
<li>首先需要在xml中引入ViewModel实例，在<layout>以下建立<data>标签，其中通过<variable>引用viewModel对象，然后在UIController中，将viewModel传入<br>绑定的内容，主要分为两种，行为和数据</li>
<li>绑定行为，主要对象为按钮等。在<code>onClick</code>一项中通过<strong>@{() -&gt; viewModel.onSkip() }</strong>的方式，直接调用ViewModel中的方法</li>
<li>绑定数据，主要对象为TextView等。在<code>text</code>一项中通过<strong>@{viewModel.data}</strong>的方式设置文本<blockquote>
<p>If the value of word is null, the LiveData object displays an empty string.</p>
<ul>
<li>注意，需要把UIController的LifecycleOwner实例传入，否则LivaData的observe不生效。binding对象中自带lifecycleOwner属性，需要实例化</li>
<li>如果设置liveData时需要对文本进行修饰，可以使用<string name="score_format">Current Score：%d</string>的形式</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="DataBinding-Transformations"><a href="#DataBinding-Transformations" class="headerlink" title="DataBinding+Transformations"></a>DataBinding+Transformations</h2><p>实际上也是一种数据转换。即在ViewModel中另设一个变量，其值通过Transformtions.map(liveData)的方式定义，返回显示时需要的文本格式和内容</p>
<h2 id="BindingAdapter"><a href="#BindingAdapter" class="headerlink" title="BindingAdapter"></a>BindingAdapter</h2><p>在Kotlin中，允许通过扩展函数的方式增加类的能力。<br>例如<code>fun TextView.setFormatText(con: String)</code>，为TextView扩展了一个方法，在其中可以直接调用TextView的方法，有点类似于C++的友元函数<br>如果为该方法<strong>添加注解<code>@BindingAdapter</code>，并且传入属性名称，可以实现在xml中通过该属性名调用该方法</strong>。该方法即成为该属性的适配器。</p>
<h1 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h1><p>LiteSQL上层封装，实现更加便捷的数据库操作</p>
<ul>
<li>编写实体类，通过注解标志信息<ul>
<li>@Entity，默认使用类名创建数据表，可以通过参数name指定</li>
<li>@PrimaryKey，标识主键，通过参数autoGenrate设置是否自增</li>
<li>@ColumnInfo，标识表项</li>
</ul>
</li>
<li>与其他数据库框架相似，Room也需要编写Dao模块接口，可将视为自定义访问数据库的接口。<ul>
<li>需要使用@Dao标识，并且方法需要使用对应操作的注解标识，如@Insert，@Update</li>
<li>其他操作没有便捷的注解方式，如select或delete，需要在@Query注解內，传入对应的SQL语句</li>
<li>注意，当sql语句中需要引用接口方法传入的参数时，使用<code>where id = :key</code>的方式引用</li>
<li>使用@Delete可以删除多个特定数据项</li>
<li>通过使用LiveDate作为返回值类型，Room可以保持LiveData的持续更新，即只需要一次显式获取数据</li>
</ul>
</li>
<li>使用单例模式实现数据库实例。通过注解<code>@Database</code>标识，传入参数为实体列表（数据表），版本号。使用build模式创建数据库实例，传入参数为app上下文，该数据库类，数据库名</li>
</ul>
<blockquote>
<p>Execution failed for task ‘:app:kaptDebugKotlin’.</p>
<blockquote>
<p>A failure occurred while executing org.jetbrains.kotlin.gradle.internal.KaptExecution<br>java.lang.reflect.InvocationTargetException (no error message)<br>如果出现以上报错，可以检查一下以下部分</p>
<ol>
<li>room模块需要添加的依赖包是否完整<br> implementation “androidx.room:room-ktx:$room_version”<br> implementation “androidx.room:room-runtime:$room_version”<br> kapt “androidx.room:room-compiler:$room_version”</li>
<li>Dao，Entity，Database中room使用是否规范<br>例如我的问题则是：Dao中@Update修饰的方法设置了返回值…</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<p>建议：不要在启动应用时即联网获取数据显示，而是直接从数据库读取数据进行显示，从而减少程序加载的时间。<br>而当获取到网络的数据时，应将数据存到数据库中，而不是直接显示数据。更新完数据库后再更新屏幕中的内容。</p>
</blockquote>
<h1 id="关于协程"><a href="#关于协程" class="headerlink" title="关于协程"></a>关于协程</h1><p>关于从主线程获取任务完成的方式，有两种，<strong>回调</strong>和<strong>协程</strong><br>回调可以实现在后台长时间执行任务而<strong>不阻塞主线程</strong>，任务结束后执行作为参数传入的回调任务。<br>然而回调函数也有明显的确定，即回调方法块会以异步的形式在某一个时间执行，因此代码不是顺序执行，大量的回调函数使得代码可读性下降。另外，回调函数不允许使用某些语言特性，如<strong>异常</strong><br>在Kotlin中，可以直接使用协程实现线程协同。协程可以实现基于回调的代码转化为顺序执行，提升了可读性，甚至可以使用异常等语言特性<br>实际上，回调和协程都是完成了同样的事情，即等待一个耗时任务的结果，并继续执行。<br>使用<code>suspend</code>标记函数，代表其可以被协程调用。当该函数被调用，<strong>协程将暂停执行，而不是像普通函数一样阻塞直到函数返回</strong>，也就是说，当协程暂停等待耗时任务的结果时，他不会阻塞其原来运行的线程。<br>suspend可以理解为挂起或暂停。与阻塞的区别在于，线程挂起时，在等到其结果返回前可以进行其他的工作；而阻塞线程时，不能进行其他工作。</p>
<p>返回LiveData的方法Room默认会在后台线程执行，因此不需要使用suspend标记。</p>
<h1 id="关于RecyclerView"><a href="#关于RecyclerView" class="headerlink" title="关于RecyclerView"></a>关于RecyclerView</h1><p>使用<code>notifyDataSetChanged()</code>可以进行全列表的内容更新。但这实际上有些效率低下，因为每次更新的可能只是列表中的一个或几个Item，而不需要否定整个列表并对他进行重新绑定和绘制。<br>使用<code>notifyItemChange()</code>可以解决以上问题，他可以更新列表中的某些个Item而不需要重绘整个列表。然而所以增删改查操作都通过它实现，可能涉及较多代码并且不好实现。<br>RecyclerView提供了更好的方法。</p>
<h2 id="DiffUtil"><a href="#DiffUtil" class="headerlink" title="DiffUtil"></a>DiffUtil</h2><p>通过实现<code>DiffUtil.ItemCallback</code>接口，实现其中的比较方法逻辑，并将该子类实例化对象传入Adapter，实现自动进行代码比较与更新。<br>该接口中的两个比较方法，分别定义了Item对象的比较方式与Item内容的比较方式，并在内部通过比较算法，实现快速对比得到差异。</p>
<h2 id="DataBinding-1"><a href="#DataBinding-1" class="headerlink" title="DataBinding"></a>DataBinding</h2><p>使用<code>androidx.recyclerview.widget.ListAdapter</code>代替<code>RecyclerView.Adapter</code>，配合databinding使用。<br>通过向ViewHolder传入一个DataBinding对象，代替原来的View，实现数据的绑定。并且在数据发生变化时（observer），通过<code>adapter.submitList(data)</code>，进行数据更新。<code>submitList()</code>方法会对比新旧两个数据列表的数据，比较的原则则是我们在DiffCallback中实现的两个方法。比较完后根据差异自动进行数据增删修改。</p>
<h1 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h1><ul>
<li>Worker 接口中实现doWork()方法，指定后台工作内容</li>
<li>WorkRequest 用于请求后台工作，可以配置工作优先级，调用时机，如电量瓶颈，连上wifi等</li>
<li>WorkManager 安排并运行后台工作，分散系统负荷</li>
</ul>
<p><code>doWork()</code>作为一个suspend方法，会在一个后台线程调用。<code>Android系统最多会提供10min时间去完成一个任务，并返回一个Result对象。超过时间将会强制停止该工作。</code></p>
<p><a href="https://developer.android.com/topic/libraries/architecture/workmanager">Developer</a></p>
<ul>
<li>后台任务分为定时任务和一次性任务。定时任务的周期必须大于15min。</li>
<li>使用WorkRequestBuilder创建WorkRequest。PeriodicWorkRequestBuilder用于创建定时任务，需要传入周期和单位</li>
<li>使用setConstraints()设置约束</li>
<li>执行任务，使用WorkManager调用enqueueUniquePeriodicWork()，将任务传入任务队列</li>
<li>定时任务会多次执行，除非其被取消。第一次设定即执行，或者满足约束即执行</li>
<li>定时任务的时间间隔并不精准，取决于系统的电池优化。</li>
<li>取消任务可以通过work.id，word.name，work.tag<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setupRecurringWork</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">val</span> constraints = Constraints.Builder()</span><br><span class="line">               .setRequiredNetworkType(NetworkType.UNMETERED)</span><br><span class="line">               .setRequiresBatteryNotLow(<span class="literal">true</span>)</span><br><span class="line">               .setRequiresCharging(<span class="literal">true</span>)</span><br><span class="line">               .apply &#123;</span><br><span class="line">                   <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">                       setRequiresDeviceIdle(<span class="literal">true</span>)</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               .build()</span><br><span class="line">       <span class="keyword">val</span> repeatingRequest = PeriodicWorkRequestBuilder&lt;RefreshDataWorker&gt;(<span class="number">1</span>, TimeUnit.DAYS)</span><br><span class="line">               .setConstraints(constraints)</span><br><span class="line">               .build()</span><br><span class="line">       </span><br><span class="line">       Timber.d(<span class="string">&quot;Periodic Work request for sync is scheduled&quot;</span>)</span><br><span class="line">       WorkManager.getInstance().enqueueUniquePeriodicWork(</span><br><span class="line">               RefreshDataWorker.WORK_NAME,</span><br><span class="line">               ExistingPeriodicWorkPolicy.KEEP,</span><br><span class="line">               repeatingRequest)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>在ViewModel中，使用LiveData实现数据与界面协同，即数据变化时界面的变化<br>使用databinding，直接关联界面（xml）与数据</li>
</ul>
<h1 id="组件在实际项目中的应用"><a href="#组件在实际项目中的应用" class="headerlink" title="组件在实际项目中的应用"></a>组件在实际项目中的应用</h1>]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Jetpack</tag>
        <tag>秘籍贴</tag>
      </tags>
  </entry>
</search>
